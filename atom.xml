<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>薛8的个人网站 - xue8&#39;s Blog - DDND.CN</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ddnd.cn/"/>
  <updated>2019-03-13T11:06:23.341Z</updated>
  <id>http://ddnd.cn/</id>
  
  <author>
    <name>薛8</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CAS原理分析及ABA问题详解</title>
    <link href="http://ddnd.cn/2019/03/12/java-cas/"/>
    <id>http://ddnd.cn/2019/03/12/java-cas/</id>
    <published>2019-03-12T13:09:33.000Z</published>
    <updated>2019-03-13T11:06:23.341Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><img src="http://ws2.sinaimg.cn/large/e0e01e43ly1g11dcysv30j20t60jh1kx.jpg" alt="image" width="100%"></p><h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><p><code>CAS</code>即<code>Compare And Swap</code>的缩写，翻译成中文就是<strong>比较并交换</strong>，其作用是让CPU比较内存中某个值是否和预期的值相同，如果相同则将这个值更新为新值，不相同则不做更新，也就是CAS是<strong>原子性</strong>的操作，其实现方式是通过借助<code>C/C++</code>调用CPU指令完成的，所以效率很高。<br><code>CAS</code>的原理很简单，这里使用一段<code>Java</code>代码来描述<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public boolean compareAndSwap(int value, int expect, int update) &#123;</span><br><span class="line">//        如果内存中的值value和期望值expect一样 则将值更新为新值update</span><br><span class="line">    if (value == expect) &#123;</span><br><span class="line">        value = update;</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>大致过程是将内存中的值、我们的期望值、新值交给CPU进行运算，如果内存中的值和我们的期望值相同则将值更新为新值，否则不做任何操作。这个过程是在CPU中完成的，这里不好描述CPU的工作过程，就拿Java代码来描述了。    </p><h2 id="Unsafe源码分析"><a href="#Unsafe源码分析" class="headerlink" title="Unsafe源码分析"></a>Unsafe源码分析</h2><p>Java是在<code>Unsafe(sun.misc.Unsafe)</code>类实现<code>CAS</code>的操作，而我们知道Java是无法直接访问操作系统底层的API的(原因是Java的跨平台性限制了Java不能和操作系统耦合)，所以Java并没有在<code>Unsafe</code>类直接实现<code>CAS</code>的操作，而是通过<strong>JDI(Java Native Interface)</strong>本地调用<code>C/C++</code>语言来实现<code>CAS</code>操作的。<br><code>Unsafe</code>有很多个<code>CAS</code>操作的相关方法，这里举例几个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);</span><br><span class="line"></span><br><span class="line">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</span><br><span class="line"></span><br><span class="line">public final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6);</span><br></pre></td></tr></table></figure></p><p>我们拿<code>public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</code>进行分析，这个方法是比较内存中的一个值(整型)和我们的期望值(var4)是否一样，如果一样则将内存中的这个值更新为<code>var5</code>，参数中的<code>var1</code>是值所在的对象，<code>var2</code>是值在对象(var1)中的内存偏移量，<strong>参数var1和参数var2是为了定位出值所在内存的地址</strong>。<br><img src="http://wx3.sinaimg.cn/large/e0e01e43ly1g11dbvrjwoj21ay0bujtl.jpg" alt="image"><br><strong>Unsafe.java在这里发挥的作用有：</strong></p><ol><li>将对象引用、值在对象中的偏移量、期望的值和欲更新的新值传递给<code>Unsafe.cpp</code></li><li>如果值更新成功则返回<code>true</code>给开发者，没有更新则返回<code>false</code></li></ol><p><strong>Unsafe.cpp在这里发挥的作用有：</strong></p><ol><li>接受从<code>Unsafe</code>传递过来的对象引用、偏移量、期望的值和欲更新的新值，根据对象引用和偏移量<strong>计算出值的地址</strong>，然后将值的地址、期望的值、欲更新的新值传递给CPU</li><li>如果值更新成功则返回<code>true</code>给<code>Unsafe.java</code>，没有更新则返回<code>false</code></li></ol><p><strong>CPU在这里发挥的作用：</strong></p><ol><li>接受从<code>Unsafe.cpp</code>传递过来的地址、期望的值和欲更新的新值，执行指令<code>cmpxchg</code>，比较地址中的值是否和期望的值一样，一样则将值更新为新的值，不一样则不做任何操作</li><li>将操作结果返回给<code>Unsafe.cpp</code></li></ol><h2 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h2><p><code>CAS</code>虽然高效的实现了原子性操作，但是也存在一些缺点，主要表现在以下三个方面。</p><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>在多线程场景下<code>CAS</code>会出现<code>ABA</code>问题，关于ABA问题这里简单科普下，例如有2个线程同时对同一个值(初始值为A)进行CAS操作，这三个线程如下    </p><ol><li>线程1，期望值为A，欲更新的值为B</li><li>线程2，期望值为A，欲更新的值为B</li></ol><p>线程<code>1</code>抢先获得CPU时间片，而线程<code>2</code>因为其他原因阻塞了，线程<code>1</code>取值与期望的A值比较，发现相等然后将值更新为B，然后这个时候<strong>出现了线程<code>3</code>，期望值为B，欲更新的值为A</strong>，线程3取值与期望的值B比较，发现相等则将值更新为A，此时线程<code>2</code>从阻塞中恢复，并且获得了CPU时间片，这时候线程<code>2</code>取值与期望的值A比较，发现相等则将值更新为B，虽然线程<code>2</code>也完成了操作，但是线程<code>2</code>并不知道值已经经过了<code>A-&gt;B-&gt;A</code>的变化过程。   </p><p><strong><code>ABA</code>问题带来的危害</strong>：<br>小明在提款机，提取了50元，因为提款机问题，有两个线程，同时把余额从100变为50<br>线程1（提款机）：获取当前值100，期望更新为50，<br>线程2（提款机）：获取当前值100，期望更新为50，<br>线程1成功执行，线程2某种原因block了，这时，某人给小明汇款50<br>线程3（默认）：获取当前值50，期望更新为100，<br>这时候线程3成功执行，余额变为100，<br>线程2从Block中恢复，获取到的也是100，compare之后，继续更新余额为50！！！<br>此时可以看到，实际余额应该为100（100-50+50），但是实际上变为了50（100-50+50-50）这就是ABA问题带来的成功提交。</p><p><strong>解决方法</strong>：<br>在变量前面加上版本号，每次变量更新的时候变量的<strong>版本号都<code>+1</code></strong>，即<code>A-&gt;B-&gt;A</code>就变成了<code>1A-&gt;2B-&gt;3A</code>。</p><h3 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h3><p>如果<code>CAS</code>操作失败，就需要循环进行<code>CAS</code>操作(循环同时将期望值更新为最新的)，如果长时间都不成功的话，那么会造成CPU极大的开销。</p><blockquote><p>这种循环也称为自旋</p></blockquote><p><strong>解决方法</strong>：<br>限制自旋次数，防止进入死循环。</p><h3 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h3><p><code>CAS</code>的原子操作只能针对一个共享变量。</p><p><strong>解决方法</strong>：<br>如果需要对多个共享变量进行操作，可以使用加锁方式(悲观锁)保证原子性，或者可以把多个共享变量合并成一个共享变量进行<code>CAS</code>操作。</p><h2 id="CAS的应用"><a href="#CAS的应用" class="headerlink" title="CAS的应用"></a>CAS的应用</h2><p>我们知道<code>CAS</code>操作并不会锁住共享变量，也就是一种<strong>非阻塞</strong>的同步机制，<code>CAS</code>就是乐观锁的实现。</p><ol><li>乐观锁<br><strong>乐观锁</strong>总是假设最好的情况，每次去操作数据都认为不会被别的线程修改数据，<strong>所以在每次操作数据的时候都不会给数据加锁</strong>，即在线程对数据进行操作的时候，<strong>别的线程不会阻塞</strong>仍然可以对数据进行操作，只有在需要更新数据的时候才会去判断数据是否被别的线程修改过，如果数据被修改过则会拒绝操作并且返回错误信息给用户。</li><li>悲观锁<br><strong>悲观锁</strong>总是假设最坏的情况，每次去操作数据时候都认为会被的线程修改数据，<strong>所以在每次操作数据的时候都会给数据加锁</strong>，让别的线程无法操作这个数据，别的线程会一直阻塞直到获取到这个数据的锁。这样的话就会影响效率，比如当有个线程发生一个很耗时的操作的时候，别的线程只是想获取这个数据的值而已都要等待很久。</li></ol><p><code>Java</code>利用<code>CAS</code>的乐观锁、原子性的特性高效解决了多线程的安全性问题，例如JDK1.8中的集合类<code>ConcurrentHashMap</code>、关键字<code>volatile</code>、<code>ReentrantLock</code>等。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zl198751.iteye.com/blog/1848575" target="_blank" rel="noopener">JAVA CAS原理深度分析</a><br><a href="http://objcoding.com/2018/11/29/cas/" target="_blank" rel="noopener">Java并发之CAS原理分析</a><br><a href="https://segmentfault.com/a/1190000014858404#articleHeader3" target="_blank" rel="noopener">Java CAS 原理分析</a><br><a href="https://www.zhihu.com/question/23281499" target="_blank" rel="noopener">什么是ABA问题？</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;http://ws2.sinaimg.cn/large/e0e01e43ly1g11dcysv30j20t60jh1kx.jpg&quot; alt=&quot;image&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是CA
      
    
    </summary>
    
      <category term="Java编程基础" scheme="http://ddnd.cn/categories/Java-Programming/"/>
    
    
      <category term="CAS" scheme="http://ddnd.cn/tags/CAS/"/>
    
      <category term="多线程" scheme="http://ddnd.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>什么是Java内存模型？</title>
    <link href="http://ddnd.cn/2019/03/11/java-memory-model/"/>
    <id>http://ddnd.cn/2019/03/11/java-memory-model/</id>
    <published>2019-03-11T08:24:28.000Z</published>
    <updated>2019-03-12T09:40:16.167Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ws3.sinaimg.cn/large/e0e01e43ly1g0z8ongt9yj21qi15okjn.jpg" alt="image" width="100%"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>要想深入了解Java并发编程，就要先理解好<strong>Java内存模型</strong>，而要理解Java内存模型又不得不从硬件、计算机内存模型说起，本文从计算机内存模型产生的原因、解决的问题谈起，然后再对Java模型进行介绍，最后对计算机内存模型和Java内存模型进行总结，希望大家看完本文之后有所收获！</p><a id="more"></a><h2 id="CPU工作过程及出现的问题"><a href="#CPU工作过程及出现的问题" class="headerlink" title="CPU工作过程及出现的问题"></a>CPU工作过程及出现的问题</h2><h3 id="CPU执行过程"><a href="#CPU执行过程" class="headerlink" title="CPU执行过程"></a>CPU执行过程</h3><p>大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道，而计算机上面的临时数据，是储存在<strong>主存</strong>中的。    </p><blockquote><p>计算机内存包括<strong>高速缓存</strong>和<strong>主存</strong>。</p></blockquote><p>我们知道CPU执行指令的速度比从主存读取数据和向主存写入数据快很多，所以为了高效利用CPU，CPU增加了<strong>高速缓存(cache)</strong>来匹配CPU的执行速度，最终程序的执行过程如下</p><ol><li>首先会将数据从主存中复制一份到CPU的高速缓存中</li><li>当CPU执行计算的时候就可以直接从高速缓存中读取数据和写入数据</li><li>当运算结束后，再将高速缓存的数据更新到主存中    </li></ol><h3 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h3><p>上面的执行过程在单线程情况下并没有问题，但是在多线程情况下就会出现问题，<strong>因为CPU如果含有多个核心，则每个核心都有自己独占高速缓存</strong>，如果出现多个线程同时执行同一个操作，那么结果是无法预知。例如<code>2</code>个线程同时执行<code>i++</code>，假设i的初始值是<code>0</code>，那么我们希望<code>2</code>个线程执行完成之后<code>i</code>的值变为<code>2</code>，但是事实会是这样吗？<br><img src="http://wx2.sinaimg.cn/large/e0e01e43ly1g0z8qqzxgmj20p70kjwgk.jpg" alt="image"></p><p>可能出现的情况有：    </p><ol><li>线程1先将<code>i=0</code>从主存中读取到线程1的高速缓存中，然后CPU完成运算，再将<code>i=1</code>写入到主存中，然后线程2开始从主存中读取<code>i=1</code>到线程2的高速缓存中，然后CPU完成运算，再将<code>i=2</code>写入到主存中，那么<code>i=2</code>即为我们想要的结果。</li><li>线程1将<code>i=0</code>从主存中读取到线程1的高速缓存中的同时线程2也从主存中读取<code>i=0</code>到线程2的高速缓存中，然后线程1和线程2完成运算后，也都将<code>i=1</code>写入到主存中，那么结果<code>i=1</code>，结果就不是我们想要的了。出现这个情况，我们称为<strong>缓存不一致问题</strong>。</li></ol><p>那么如何解决CPU出现的<strong>缓存不一致问题</strong>呢？通常使用的解决方法有2种：     </p><ol><li>通过给总线加锁</li><li>使用<strong>缓存一致性协议</strong></li></ol><p><img src="http://ws3.sinaimg.cn/large/e0e01e43ly1g0z8qyxhv7j20qc092757.jpg" alt="image"><br>第<code>1</code>种方法虽然也达到了目的，但是在总线被锁住的期间，其他的CPU也无法访问主存，<strong>效率很低</strong>，所以就出现了缓存一致性协议即第<code>2</code>种方法，其中最出名的就是<code>Intel</code>的MESI协议，MESI协议保证每个CPU高速缓存中的变量都是一致的。它的核心思想是，当CPU写数据时候，如果发现操作的变量是共享变量(即其他CPU上也存在该变量)，就会发出信号通知<strong>其他CPU</strong>将它高速缓存中缓存这个变量的缓存行置为<strong>无效状态</strong>，因此当其他CPU需要读取这个变量时，发现自己高速缓存中缓存该变量的缓存行为无效状态，那么它就会从主存中<strong>重新读取</strong>。<br><img src="http://ws1.sinaimg.cn/large/e0e01e43ly1g0z8r8km5kj20q20bs40h.jpg" alt="image"></p><h3 id="处理器重排序问题"><a href="#处理器重排序问题" class="headerlink" title="处理器重排序问题"></a>处理器重排序问题</h3><p>在多线程场景下，CPU除了会出现缓存一致性问题，还会出现因为<strong>处理器重排序</strong>即<strong>处理器(CPU)为了提高效率可能会对输入的代码进行乱序执行</strong>，而造成多线程的情况下出现问题。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//线程1:</span><br><span class="line">context = loadContext();   //语句1</span><br><span class="line">inited = true;             //语句2</span><br><span class="line"> </span><br><span class="line">//线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure></p><p>线程1由于处理器重排序，先执行性了语句2，那么此时线程2会认为<code>context</code>已经初始化完成，那么跳出循环，去执行<code>doSomethingwithconfig(context)</code>方法，实际上此时context并未初始化(即线程1的语句1还未执行)，而导致程序出错。</p><h2 id="什么是计算机内存模型"><a href="#什么是计算机内存模型" class="headerlink" title="什么是计算机内存模型"></a>什么是计算机内存模型</h2><p>上面提到的<strong>缓存一致性问题</strong>、<strong>处理器重排序问题</strong>都是在多线程情况下CPU可能出现的问题，那我们应该怎么处理这些问题？实际上这些问题并不需要我们考虑，这些问题CPU都会处理好，而CPU处理这些问题的时候是按照特定的<strong>操作规范</strong>，对特定的主存进行访问或告诉CPU高速缓存怎么访问主存，保证了多线程场景下的<strong>原子性、可见性、有序性</strong>，这个操作规范就称为<strong>计算机内存模型</strong>。      </p><blockquote><p>可见性即当一个变量修改后，这个变量会马上更新到主存中，其他线程会收到通知这个变量修改过了，使用这个变量的时候重新去主存获取</p></blockquote><h2 id="什么是Java内存模型"><a href="#什么是Java内存模型" class="headerlink" title="什么是Java内存模型"></a>什么是Java内存模型</h2><p>从前面的介绍了解到计算机内存模型是一种解决多线程场景下的一个主存操作规范，既然是规范，那么不同的编程语言都可以遵循这种操作规范，在多线程场景下访问主存保证原子性、可见性、有序性。<br><strong>Java内存模型(Java Memory Model，JMM)</strong>即是Java语言对这个操作规范的遵循，<code>JMM</code>规定了所有的变量都存储在<strong>主存</strong>中，每个线程都有自己的<strong>工作区</strong>，线程将使用到的变量从主存中<strong>复制</strong>一份到自己的工作区，线程对变量的<strong>所有操作</strong>(读取、赋值等)都必须在工作区，不同的线程也无法直接访问对方工作区，线程之间的消息传递都需要通过主存来完成。<strong>可以把这里主存类比成计算机内存模型中的主存，工作区类比成计算机内存模型中的高速缓存</strong>。</p><p><img src="http://ws2.sinaimg.cn/large/e0e01e43ly1g0z8rfihfkj20qk09ft9l.jpg" alt="image"></p><p>而我们知道<code>JMM</code>其实是工作主存中的，Java内存模型中的工作区也是主存中的一部分，所以可以这样说Java内存模型解决的是<strong>内存一致性问题(主存和主存)</strong>而计算机内存模型解决的是<strong>缓存一致性问题(CPU高速缓存和主存)</strong>，这两个模型类似，但是作用域不一样，Java内存模型保证的是主存和主存之间的原子性、可见性、有序性，而计算机内存模型保证的是CPU高速缓存和主存之间的原子性、可见性、有序性。</p><p><img src="http://ws1.sinaimg.cn/large/e0e01e43ly1g0z8rlifrqj20zb0cbjsz.jpg" alt="image"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文很多观点都是按照笔者自己的理解然后总结出来的，若有偏颇，欢迎指正！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">Java并发编程：volatile关键字解析</a><br><a href="https://blog.csdn.net/u013256816/article/details/51510815" target="_blank" rel="noopener">Java内存模型</a><br><a href="http://developer.51cto.com/art/201807/579744.htm" target="_blank" rel="noopener">【教程】终于有人把Java内存模型说清楚了！</a><br><a href="https://www.zhihu.com/question/268021813" target="_blank" rel="noopener">关于JAVA内存模型与MESI协议？</a><br><a href="https://www.zhihu.com/question/277395220" target="_blank" rel="noopener">有了缓存一致性协议为什么还需要多线程同步？</a>  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ws3.sinaimg.cn/large/e0e01e43ly1g0z8ongt9yj21qi15okjn.jpg&quot; alt=&quot;image&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;要想深入了解Java并发编程，就要先理解好&lt;strong&gt;Java内存模型&lt;/strong&gt;，而要理解Java内存模型又不得不从硬件、计算机内存模型说起，本文从计算机内存模型产生的原因、解决的问题谈起，然后再对Java模型进行介绍，最后对计算机内存模型和Java内存模型进行总结，希望大家看完本文之后有所收获！&lt;/p&gt;
    
    </summary>
    
      <category term="Java编程基础" scheme="http://ddnd.cn/categories/Java-Programming/"/>
    
    
      <category term="Java内存模型" scheme="http://ddnd.cn/tags/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="计算机内存模型" scheme="http://ddnd.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>10分钟掌握ConcurrentHashMap 3分钟清楚和HashMap、Hashtable的区别</title>
    <link href="http://ddnd.cn/2019/03/10/jdk1-8-concurrenthashmap/"/>
    <id>http://ddnd.cn/2019/03/10/jdk1-8-concurrenthashmap/</id>
    <published>2019-03-10T14:02:55.000Z</published>
    <updated>2019-03-12T10:14:11.690Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://wx3.sinaimg.cn/large/e0e01e43ly1g0y4kkt2k3j21y013bb2b.jpg" alt="image" width="100%"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>ConcurrentHashMap</code>顾名思义就是同步的HashMap，也就是线程安全的HashMap，所以本篇介绍的ConcurrentHashMap和HashMap有着很重要的关系，所以建议之前没有了解过HashMap的可以先看看这篇关于HashMap的原理分析<a href="https://ddnd.cn/2019/03/07/jdk1.8-hashmap/">《HashMap从认识到源码分析》</a>，本篇继续以<code>JDK1.8</code>版本的源码进行分析，最后在介绍完ConcurrentHashMap之后会对ConcurrentHashMap、Hashtable和HashMap做一个比较和总结。</p><a id="more"></a><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>我们先看一下<code>ConcurrentHashMap</code>实现了哪些接口、继承了哪些类，对<code>ConcurrentHashMap</code>有一个整体认知。<br><img src="http://wx1.sinaimg.cn/large/e0e01e43ly1g0y4iof3w1j20qp0hvjsa.jpg" alt="image"><br><code>ConcurrentHashMap</code>继承<code>AbstractMap</code>接口，这个和<code>HashMap</code>一样，然后实现了<code>ConcurrentMap</code>接口，这个和<code>HashMap</code>不一样，<code>HashMap</code>是直接实现的<code>Map</code>接口。<br>再细看<code>ConcurrentHashMap</code>的结构，这里列举几个重要的成员变量<code>table</code>、<code>nextTable</code>、<code>baseCount</code>、<code>sizeCtl</code>、<code>transferIndex</code>、<code>cellsBusy</code></p><ul><li><strong>table</strong>：数据类型是Node数组，这里的Node和HashMap的Node一样都是内部类且实现了<code>Map.Entry</code>接口</li><li><strong>nextTable</strong>：哈希表扩容时生成的数据，数组为扩容前的2倍</li><li><strong>sizeCtl</strong>：多个线程的<strong>共享变量</strong>，是操作的控制标识符，它的作用不仅包括<code>threshold</code>的作用，在不同的地方有不同的值也有不同的用途<ul><li><code>-1</code>代表正在<strong>初始化</strong></li><li><code>-N</code>代表有<code>N-1</code>个线程正在进行<strong>扩容</strong>操作</li><li><code>0</code>代表hash表还没有被初始化</li><li>正数表示下一次进行扩容的容量大小</li></ul></li><li><strong>ForwardingNode</strong>：一个特殊的Node节点，Hash地址为-1，存储着nextTable的引用，只有table发生扩用的时候，ForwardingNode才会发挥作用，作为一个占位符放在table中表示当前节点为null或者已被移动<br><img src="http://wx4.sinaimg.cn/large/e0e01e43ly1g0y4j0xa3bj20m20j7gmq.jpg" alt="image"><br><code>ConcurrentHashMap</code>和<code>HashMap</code>一样都是采用<strong>拉链法</strong>处理哈希冲突，且都为了防止单链表过长影响查询效率，所以当链表长度超过某一个值时候将用红黑树代替链表进行存储，采用了<strong>数组+链表+红黑树</strong>的结构<br><img src="http://ws4.sinaimg.cn/large/e0e01e43ly1g0y4j8c72lj20zg0g60u3.jpg" alt="image"><br>所以从结构上看<code>HashMap</code>和<code>ConcurrentHashMap</code>还是很相似的，只是<code>ConcurrentHashMap</code>在某些操作上采用了<code>CAS</code> + <code>synchronized</code>来保证并发情况下的安全。<br>说到<code>ConcurrentHashMap</code>处理并发情况下的线程安全问题，这不得不提到<code>Hashtable</code>，因为<code>Hashtable</code>也是线程安全的，那<code>ConcurrentHashMap</code>和<code>Hashtable</code>有什么区别或者有什么高明之处嘛？以至于官方都推荐使用<code>ConcurrentHashMap</code>来代替<code>Hashtable</code></li><li><strong>线程安全的实现</strong>：<code>Hashtable</code>采用<strong>对象锁</strong>(synchronized修饰对象方法)来保证线程安全，也就是一个<code>Hashtable</code>对象只有一把锁，如果线程1拿了对象A的锁进行有<code>synchronized</code>修饰的<code>put</code>方法，其他线程是无法操作对象A中有<code>synchronized</code>修饰的方法的(如<code>get</code>方法、<code>remove</code>方法等)，竞争激烈所以效率低下。而<code>ConcurrentHashMap</code>采用<code>CAS</code> + <code>synchronized</code>来保证并发安全性，且<code>synchronized</code>关键字不是用在方法上而是用在了具体的对象上，实现了更小粒度的锁，等会源码分析的时候在细说这个SUN大师们的鬼斧神工</li><li>数据结构的实现：<code>Hashtable</code>采用的是<strong>数组 + 链表</strong>，当链表过长会影响查询效率，而<code>ConcurrentHashMap</code>采用<strong>数组 + 链表 + 红黑树</strong>，当链表长度超过某一个值，则将链表转成红黑树，提高查询效率。      </li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><code>ConcurrentHashMap</code>的构造函数有5个，从数量上看就和<code>HashMap</code>、<code>Hashtable</code>(4个)的不同，多出的那个构造函数是<code>public ConcurrentHashMap(int initialCapacity,float loadFactor, int concurrencyLevel)</code>，即除了传入容量大小、负载因子之外还多传入了一个整型的<code>concurrencyLevel</code>，这个整型是我们预先估计的并发量，比如我们估计并发是<code>30</code>，那么就可以传入<code>30</code>。<br>其他的4个构造函数的参数和<code>HashMap</code>的一样，而具体的初始化过程却又不相同，<code>HashMap</code>和<code>Hashtable</code>传入的容量大小和负载因子都是为了计算出<strong>初始阈值</strong>(threshold)，而<code>ConcurrentHashMap</code>传入的容量大小和负载因子是为了计算出<strong>sizeCtl</strong>用于初始化<code>table</code>，这个sizeCtl即table数组的大小，不同的构造函数计算sizeCtl方法都不一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//无参构造函数，什么也不做，table的初始化放在了第一次插入数据时，默认容量大小是16和HashMap的一样，默认sizeCtl为0</span><br><span class="line">public ConcurrentHashMap() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//传入容量大小的构造函数。</span><br><span class="line">public ConcurrentHashMap(int initialCapacity) &#123;</span><br><span class="line">    //如果传入的容量大小小于0 则抛出异常。</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    //如果传入的容量大小大于允许的最大容量值 则cap取允许的容量最大值 否则cap =</span><br><span class="line">    //((传入的容量大小 + 传入的容量大小无符号右移1位 + 1)的结果向上取最近的2幂次方)，</span><br><span class="line">    //即如果传入的容量大小是12 则 cap = 32(12 + (12 &gt;&gt;&gt; 1) + 1=19</span><br><span class="line">    //向上取2的幂次方即32)，这里为啥一定要是2的幂次方，原因和HashMap的threshold一样，都是为</span><br><span class="line">    //了让位运算和取模运算的结果一样。</span><br><span class="line">    //MAXIMUM_CAPACITY即允许的最大容量值 为2^30。</span><br><span class="line">    int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               //tableSizeFor这个函数即实现了将一个整数取2的幂次方。</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1));</span><br><span class="line">    //将上面计算出的cap 赋值给sizeCtl，注意此时sizeCtl为正数，代表进行扩容的容量大小。</span><br><span class="line">    this.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//包含指定Map的构造函数。</span><br><span class="line">//置sizeCtl为默认容量大小 即16。</span><br><span class="line">public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">    this.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//传入容量大小和负载因子的构造函数。</span><br><span class="line">//默认并发数大小是1。</span><br><span class="line">public ConcurrentHashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    this(initialCapacity, loadFactor, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//传入容量大小、负载因子和并发数大小的构造函数</span><br><span class="line">public ConcurrentHashMap(int initialCapacity,</span><br><span class="line">                         float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">    if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    //如果传入的容量大小 小于 传入的并发数大小，</span><br><span class="line">    //则容量大小取并发数大小，这样做的原因是确保每一个Node只会分配给一个线程，而一个线程则</span><br><span class="line">    //可以分配到多个Node，比如当容量大小为64，并发数大</span><br><span class="line">    //小为16时，则每个线程分配到4个Node。</span><br><span class="line">    if (initialCapacity &lt; concurrencyLevel)   // Use at least as many bins</span><br><span class="line">        initialCapacity = concurrencyLevel;   // as estimated threads</span><br><span class="line">    //size = 1.0 + (long)initialCapacity / loadFactor 这里计算方法和上面的构造函数不一样。</span><br><span class="line">    long size = (long)(1.0 + (long)initialCapacity / loadFactor);</span><br><span class="line">    //如果size大于允许的最大容量值则 sizeCtl = 允许的最大容量值 否则 sizeCtl =</span><br><span class="line">    //size取2的幂次方。</span><br><span class="line">    int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((int)size);</span><br><span class="line">    this.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><ol><li>判断键值是否为<code>null</code>，为<code>null</code>抛出异常。</li><li>调用<code>spread()</code>方法计算key的hashCode()获得哈希地址，这个HashMap相似。</li><li>如果当前table为空，则初始化table，需要注意的是这里并没有加<code>synchronized</code>，也就是允许多个线程去<strong>尝试</strong>初始化table，但是在初始化函数里面使用了<code>CAS</code>保证只有一个线程去执行初始化过程。</li><li>使用 <strong>容量大小-1 &amp; 哈希地址</strong> 计算出待插入键值的下标，如果该下标上的bucket为<code>null</code>，则直接调用实现<code>CAS</code>原子性操作的<code>casTabAt()</code>方法将节点插入到table中，如果插入成功则完成put操作，结束返回。插入失败(被别的线程抢先插入了)则继续往下执行。</li><li>如果该下标上的节点(头节点)的哈希地址为-1，代表需要扩容，该线程执行<code>helpTransfer()</code>方法协助扩容。</li><li>如果该下标上的bucket不为空，且又不需要扩容，则进入到bucket中，同时<strong>锁住这个bucket</strong>，注意只是锁住该下标上的bucket而已，其他的bucket并未加锁，其他线程仍然可以操作其他未上锁的bucket，这个就是ConcurrentHashMap为什么高效的原因之一。</li><li>进入到bucket里面，首先判断这个bucket存储的是红黑树(哈希地址小于0，原因后面分析)还是链表。</li><li>如果是<strong>链表</strong>，则遍历链表看看是否有哈希地址和键key相同的节点，有的话则根据传入的参数进行覆盖或者不覆盖，没有找到相同的节点的话则将新增的节点<strong>插入到链表尾部</strong>。如果是<strong>红黑树</strong>，则将节点插入。到这里<strong>结束加锁</strong>。</li><li>最后判断该bucket上的链表长度是否大于<strong>链表转红黑树的阈值(8)</strong>，大于则调用<code>treeifyBin()</code>方法将链表转成红黑树，以免链表过长影响效率。</li><li>调用<code>addCount()</code>方法，作用是将ConcurrentHashMap的键值对数量+1，还有另一个作用是检查ConcurrentHashMap是否需要扩容。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(key, value, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    //不允许键值为null，这点与线程安全的Hashtable保持一致，和HashMap不同。</span><br><span class="line">    if (key == null || value == null) throw new NullPointerException();</span><br><span class="line">    //取键key的hashCode()和HashMap、Hashtable都一样，然后再执行spread()方法计算得到哈希地</span><br><span class="line">    //址，这个spread()方法和HashMap的hash()方法一样，都是将hashCode()做无符号右移16位，只不</span><br><span class="line">    //过spread()加多了 &amp;0x7fffffff，让结果为正数。</span><br><span class="line">    int hash = spread(key.hashCode());</span><br><span class="line">    int binCount = 0;</span><br><span class="line">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">        //如果table数组为空或者长度为0(未初始化)，则调用initTable()初始化table，初始化函数</span><br><span class="line">        //下面介绍。</span><br><span class="line">        if (tab == null || (n = tab.length) == 0)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        //调用实现了CAS原子性操作的tabAt方法</span><br><span class="line">        //tabAt方法的第一个参数是Node数组的引用，第二个参数在Node数组的下标，实现的是在Nod</span><br><span class="line">        //e数组中查找指定下标的Node，如果找到则返回该Node节点(链表头节点)，否则返回null，</span><br><span class="line">        //这里的i = (n - 1)&amp;hash即是计算待插入的节点在table的下标，即table容量-1的结果和哈</span><br><span class="line">        //希地址做与运算，和HashMap的算法一样。</span><br><span class="line">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</span><br><span class="line">            //如果该下标上并没有节点(即链表为空)，则直接调用实现了CAS原子性操作的</span><br><span class="line">            //casTable()方法，</span><br><span class="line">            //casTable()方法的第一个参数是Node数组的引用，第二个参数是待操作的下标，第三</span><br><span class="line">            //个参数是期望值，第四个参数是待操作的Node节点，实现的是将Node数组下标为参数二</span><br><span class="line">            //的节点替换成参数四的节点，如果期望值和实际值不符返回false，否则参数四的节点成</span><br><span class="line">            //功替换上去，返回ture，即插入成功。注意这里：如果插入成功了则跳出for循环，插入</span><br><span class="line">            //失败的话(其他线程抢先插入了)，那么会执行到下面的代码。</span><br><span class="line">            if (casTabAt(tab, i, null,</span><br><span class="line">                         new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                break;                   // no lock when adding to empty bin</span><br><span class="line">        &#125;</span><br><span class="line">        //如果该下标上的节点的哈希地址为-1(即链表的头节点为ForwardingNode节点)，则表示</span><br><span class="line">        //table需要扩容，值得注意的是ConcurrentHashMap初始化和扩容不是用同一个方法，而</span><br><span class="line">        //HashMap和Hashtable都是用同一个方法，当前线程会去协助扩容，扩容过程后面介绍。</span><br><span class="line">        else if ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        //如果该下标上的节点既不是空也不是需要扩容，则表示这个链表可以插入值，将进入到链表</span><br><span class="line">        //中，将新节点插入或者覆盖旧值。</span><br><span class="line">        else &#123;</span><br><span class="line">            V oldVal = null;</span><br><span class="line">            //通过关键字synchroized对该下标上的节点加锁(相当于锁住锁住</span><br><span class="line">            //该下标上的链表)，其他下标上的节点并没有加锁，所以其他线程</span><br><span class="line">            //可以安全的获得其他下标上的链表进行操作，也正是因为这个所</span><br><span class="line">            //以提高了ConcurrentHashMap的效率，提高了并发度。</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    //如果该下标上的节点的哈希地址大于等于0，则表示这是</span><br><span class="line">                    //个链表。</span><br><span class="line">                    if (fh &gt;= 0) &#123;</span><br><span class="line">                        binCount = 1;</span><br><span class="line">                        //遍历链表。</span><br><span class="line">                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            //如果哈希地址、键key相同 或者 键key不为空</span><br><span class="line">                            //且键key相同，则表示存在键key和待插入的键</span><br><span class="line">                            //key相同，则执行更新值value的操作。</span><br><span class="line">                            if (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                if (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            //如果找到了链表的最后一个节点都没有找到相</span><br><span class="line">                            //同键Key的，则是插入操作，将插入的键值新建</span><br><span class="line">                            //个节点并且添加到链表尾部，这个和HashMap一</span><br><span class="line">                            //样都是插入到尾部。</span><br><span class="line">                            if ((e = e.next) == null) &#123;</span><br><span class="line">                                pred.next = new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, null);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //如果该下标上的节点的哈希地址小于0 且为树节点</span><br><span class="line">                    //则将带插入键值新增到红黑树</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = 2;</span><br><span class="line">                        //如果插入的结果不为null，则表示为替换</span><br><span class="line">                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash,</span><br><span class="line">                        key,value)) != null)&#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            if (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //判断链表的长度是否大于等于链表的阈值(8)，大于则将链表转成</span><br><span class="line">            //红黑树，提高效率。这点和HashMap一样。</span><br><span class="line">            if (binCount != 0) &#123;</span><br><span class="line">                if (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                if (oldVal != null)</span><br><span class="line">                    return oldVal;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(1L, binCount);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><ol><li>调用<code>spread()</code>方法计算key的hashCode()获得哈希地址。</li><li>计算出键key所在的下标，算法是(n - 1) &amp; h，如果table不为空，且下标上的bucket不为空，则到bucket中查找。</li><li>如果bucket的头节点的哈希地址小于0，则代表这个bucket存储的是红黑树，否则是链表。</li><li>到红黑树或者链表中查找，找到则返回该键key的值，找不到则返回null。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">    //运用键key的hashCode()计算出哈希地址</span><br><span class="line">    int h = spread(key.hashCode());</span><br><span class="line">    //如果table不为空 且 table长度大于0 且 计算出的下标上bucket不为空，</span><br><span class="line">    //则代表这个bucket存在，进入到bucket中查找，</span><br><span class="line">    //其中(n - 1) &amp; h为计算出键key相对应的数组下标的算法。</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;</span><br><span class="line">        //如果哈希地址、键key相同则表示查找到，返回value，这里查找到的是头节点。</span><br><span class="line">        if ((eh = e.hash) == h) &#123;</span><br><span class="line">            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果bucket头节点的哈希地址小于0，则代表bucket为红黑树，在红黑树中查找。</span><br><span class="line">        else if (eh &lt; 0)</span><br><span class="line">            return (p = e.find(h, key)) != null ? p.val : null;</span><br><span class="line">        //如果bucket头节点的哈希地址不小于0，则代表bucket为链表，遍历链表，在链表中查找。</span><br><span class="line">        while ((e = e.next) != null) &#123;</span><br><span class="line">            if (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><ol><li>调用<code>spread()</code>方法计算出键key的哈希地址。</li><li>计算出键key所在的数组下标，如果table为空或者bucket为空，则返回<code>null</code>。</li><li>判断当前table是否正在扩容，如果在扩容则调用helpTransfer方法协助扩容。</li><li>如果table和bucket都不为空，table也不处于在扩容状态，则<strong>锁住当前bucket</strong>，对bucket进行操作。</li><li>根据bucket的头结点判断bucket是链表还是红黑树。</li><li>在链表或者红黑树中移除哈希地址、键key相同的节点。</li><li>调用<code>addCount</code>方法，将当前table存储的键值对数量-1。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    return replaceNode(key, null, null);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">final V replaceNode(Object key, V value, Object cv) &#123;</span><br><span class="line">    //计算需要移除的键key的哈希地址。</span><br><span class="line">    int hash = spread(key.hashCode());</span><br><span class="line">    //遍历table。</span><br><span class="line">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">        //table为空，或者键key所在的bucket为空，则跳出循环返回。</span><br><span class="line">        if (tab == null || (n = tab.length) == 0 ||</span><br><span class="line">            (f = tabAt(tab, i = (n - 1) &amp; hash)) == null)</span><br><span class="line">            break;</span><br><span class="line">        //如果当前table正在扩容，则调用helpTransfer方法，去协助扩容。</span><br><span class="line">        else if ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        else &#123;</span><br><span class="line">            V oldVal = null;</span><br><span class="line">            boolean validated = false;</span><br><span class="line">            //将键key所在的bucket加锁。</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    //bucket头节点的哈希地址大于等于0，为链表。</span><br><span class="line">                    if (fh &gt;= 0) &#123;</span><br><span class="line">                        validated = true;</span><br><span class="line">                        //遍历链表。</span><br><span class="line">                        for (Node&lt;K,V&gt; e = f, pred = null;;) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            //找到哈希地址、键key相同的节点，进行移除。</span><br><span class="line">                            if (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                V ev = e.val;</span><br><span class="line">                                if (cv == null || cv == ev ||</span><br><span class="line">                                    (ev != null &amp;&amp; cv.equals(ev))) &#123;</span><br><span class="line">                                    oldVal = ev;</span><br><span class="line">                                    if (value != null)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    else if (pred != null)</span><br><span class="line">                                        pred.next = e.next;</span><br><span class="line">                                    else</span><br><span class="line">                                        setTabAt(tab, i, e.next);</span><br><span class="line">                                &#125;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            pred = e;</span><br><span class="line">                            if ((e = e.next) == null)</span><br><span class="line">                                break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //如果bucket的头节点小于0，即为红黑树。</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                        validated = true;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                        //找到节点，并且移除。</span><br><span class="line">                        if ((r = t.root) != null &amp;&amp;</span><br><span class="line">                            (p = r.findTreeNode(hash, key, null)) != null) &#123;</span><br><span class="line">                            V pv = p.val;</span><br><span class="line">                            if (cv == null || cv == pv ||</span><br><span class="line">                                (pv != null &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                                oldVal = pv;</span><br><span class="line">                                if (value != null)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                                else if (t.removeTreeNode(p))</span><br><span class="line">                                    setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //调用addCount方法，将当前ConcurrentHashMap存储的键值对数量-1。</span><br><span class="line">            if (validated) &#123;</span><br><span class="line">                if (oldVal != null) &#123;</span><br><span class="line">                    if (value == null)</span><br><span class="line">                        addCount(-1L, -1);</span><br><span class="line">                    return oldVal;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="initTable初始化方法"><a href="#initTable初始化方法" class="headerlink" title="initTable初始化方法"></a>initTable初始化方法</h3><p><code>table</code>的初始化主要由initTable()方法实现的，initTable()方法初始化一个合适大小的数组，然后设置sizeCtl。     我们知道<code>ConcurrentHashMap</code>是线程安全的，即支持多线程的，那么一开始很多个线程同时执行<code>put()</code>方法，而<code>table</code>又没初始化，那么就会很多个线程会去执行initTable()方法尝试初始化table，而<code>put</code>方法和<code>initTable</code>方法都是没有加锁的(synchronize)，那SUN的大师们是怎么保证线程安全的呢？    通过源码可以看得出，table的初始化只能由一个线程完成，但是每个线程都可以争抢去初始化table。       </p><ol><li>判断table是否为<code>null</code>，即需不需要首次初始化，如果某个线程进到这个方法后，其他线程已经将table初始化好了，那么该线程结束该方法返回。</li><li>如果table为<code>null</code>，进入到while循环，如果<code>sizeCtl</code>小于0(其他线程正在对table初始化)，那么该线程调用<code>Thread.yield()</code>挂起该线程，让出CPU时间，该线程也从运行态转成就绪态，等该线程从就绪态转成运行态的时候，别的线程已经table初始化好了，那么该线程结束while循环，结束初始化方法返回。如果从就绪态转成运行态后，table仍然为<code>null</code>，则继续while循环。</li><li>如果table为<code>null</code>且<code>sizeCtl</code>不小于0，则调用实现<code>CAS</code>原子性操作的<code>compareAndSwap()</code>方法将sizeCtl设置成-1，告诉别的线程我正在初始化table，这样别的线程无法对table进行初始化。如果设置成功，则再次判断table是否为空，不为空则初始化table，容量大小为默认的容量大小(16)，或者为sizeCtl。其中sizeCtl的初始化是在构造函数中进行的，sizeCtl = ((传入的容量大小 + 传入的容量大小无符号右移1位 + 1)的结果向上取最近的2幂次方)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; int sc;</span><br><span class="line">    //如果table为null或者长度为0， //则一直循环试图初始化table(如果某一时刻别的线程将table初始化好了，那table不为null，该//线程就结束while循环)。</span><br><span class="line">    while ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">        //如果sizeCtl小于0，</span><br><span class="line">        //即有其他线程正在初始化或者扩容，执行Thread.yield()将当前线程挂起，让出CPU时间，</span><br><span class="line">        //该线程从运行态转成就绪态。</span><br><span class="line">        //如果该线程从就绪态转成运行态了，此时table可能已被别的线程初始化完成，table不为</span><br><span class="line">        //null，该线程结束while循环。</span><br><span class="line">        if ((sc = sizeCtl) &lt; 0)</span><br><span class="line">            Thread.yield(); // lost initialization race; just spin</span><br><span class="line">        //如果此时sizeCtl不小于0，即没有别的线程在做table初始化和扩容操作，</span><br><span class="line">        //那么该线程就会调用Unsafe的CAS操作compareAndSwapInt尝试将sizeCtl的值修改成</span><br><span class="line">        //-1(sizeCtl=-1表示table正在初始化，别的线程如果也进入了initTable方法则会执行</span><br><span class="line">        //Thread.yield()将它的线程挂起 让出CPU时间)，</span><br><span class="line">        //如果compareAndSwapInt将sizeCtl=-1设置成功 则进入if里面，否则继续while循环。</span><br><span class="line">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //再次确认当前table为null即还未初始化，这个判断不能少。</span><br><span class="line">                if ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">                    //如果sc(sizeCtl)大于0，则n=sc，否则n=默认的容量大</span><br><span class="line">                    小16，</span><br><span class="line">                    //这里的sc=sizeCtl=0，即如果在构造函数没有指定容量</span><br><span class="line">                    大小，</span><br><span class="line">                    //否则使用了有参数的构造函数，sc=sizeCtl=指定的容量大小。</span><br><span class="line">                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                    //创建指定容量的Node数组(table)。</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    //计算阈值，n - (n &gt;&gt;&gt; 2) = 0.75n当ConcurrentHashMap储存的键值对数量</span><br><span class="line">                    //大于这个阈值，就会发生扩容。</span><br><span class="line">                    //这里的0.75相当于HashMap的默认负载因子，可以发现HashMap、Hashtable如果</span><br><span class="line">                    //使用传入了负载因子的构造函数初始化的话，那么每次扩容，新阈值都是=新容</span><br><span class="line">                    //量 * 负载因子，而ConcurrentHashMap不管使用的哪一种构造函数初始化，</span><br><span class="line">                    //新阈值都是=新容量 * 0.75。</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="transfer扩容方法"><a href="#transfer扩容方法" class="headerlink" title="transfer扩容方法"></a>transfer扩容方法</h3><p><code>transfer()</code>方法为<code>ConcurrentHashMap</code>扩容操作的核心方法。由于<code>ConcurrentHashMap</code>支持多线程扩容，而且也没有进行加锁，所以实现会变得有点儿复杂。整个扩容操作分为两步：</p><ol><li>构建一个nextTable，其大小为原来大小的<strong>两倍</strong>，这个步骤是在单线程环境下完成的</li><li>将原来table里面的内容复制到nextTable中，这个步骤是允许<strong>多线程</strong>操作的，所以性能得到提升，减少了扩容的时间消耗。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">//协助扩容方法</span><br><span class="line">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; int sc;</span><br><span class="line">    //如果当前table不为null 且 f为ForwardingNode节点 且 //新的table即nextTable存在的情况下才能协助扩容，该方法的作用是让线程参与扩容的复制。</span><br><span class="line">    if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123;</span><br><span class="line">        int rs = resizeStamp(tab.length);</span><br><span class="line">        while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; 0) &#123;</span><br><span class="line">            if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= 0)</span><br><span class="line">                break;</span><br><span class="line">            //更新sizeCtl的值，+1，代表新增一个线程参与扩容</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    return table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//扩容的方法</span><br><span class="line">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</span><br><span class="line">    int n = tab.length, stride;</span><br><span class="line">    //根据服务器CPU数量来决定每个线程负责的bucket数量，避免因为扩容的线程过多反而影响性能。</span><br><span class="line">    //如果CPU数量为1，则stride=1，否则将需要迁移的bucket数量(table大小)除以CPU数量，平分给</span><br><span class="line">    //各个线程，但是如果每个线程负责的bucket数量小于限制的最小是(16)的话，则强制给每个线程</span><br><span class="line">    //分配16个bucket数。</span><br><span class="line">    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; // subdivide range</span><br><span class="line">    //如果nextTable还未初始化，则初始化nextTable，这个初始化和iniTable初始化一样，只能由</span><br><span class="line">    //一个线程完成。</span><br><span class="line">    if (nextTab == null) &#123;            // initiating</span><br><span class="line">        try &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; catch (Throwable ex) &#123;      // try to cope with OOME</span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    int nextn = nextTab.length;</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    boolean advance = true;</span><br><span class="line">    boolean finishing = false; // to ensure sweep before committing nextTab</span><br><span class="line">    //分配任务和控制当前线程的任务进度，这部分是transfer()的核心逻辑，描述了如何与其他线</span><br><span class="line">    //程协同工作。</span><br><span class="line">    for (int i = 0, bound = 0;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int fh;</span><br><span class="line">        while (advance) &#123;</span><br><span class="line">            int nextIndex, nextBound;</span><br><span class="line">            if (--i &gt;= bound || finishing)</span><br><span class="line">                advance = false;</span><br><span class="line">            else if ((nextIndex = transferIndex) &lt;= 0) &#123;</span><br><span class="line">                i = -1;</span><br><span class="line">                advance = false;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (U.compareAndSwapInt</span><br><span class="line">                     (this, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : 0))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - 1;</span><br><span class="line">                advance = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            int sc;</span><br><span class="line">            if (finishing) &#123;</span><br><span class="line">                nextTable = null;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;</span><br><span class="line">                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    return;</span><br><span class="line">                finishing = advance = true;</span><br><span class="line">                i = n; // recheck before commit</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((f = tabAt(tab, i)) == null)</span><br><span class="line">            advance = casTabAt(tab, i, null, fwd);</span><br><span class="line">        else if ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = true; // already processed</span><br><span class="line">        //迁移过程（对当前指向的bucket），这部分的逻辑与HashMap类似，拿旧数组的容量当做一</span><br><span class="line">        //个掩码，然后与节点的hash进行与操作，可以得出该节点的新增有效位，如果新增有效位为</span><br><span class="line">        //0就放入一个链表A，如果为1就放入另一个链表B，链表A在新数组中的位置不变（跟在旧数</span><br><span class="line">        //组的索引一致），链表B在新数组中的位置为原索引加上旧数组容量。</span><br><span class="line">        else &#123;</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    if (fh &gt;= 0) &#123;</span><br><span class="line">                        int runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;</span><br><span class="line">                            int b = p.hash &amp; n;</span><br><span class="line">                            if (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (runBit == 0) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = null;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = null;</span><br><span class="line">                        &#125;</span><br><span class="line">                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            int ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            if ((ph &amp; n) == 0)</span><br><span class="line">                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            else</span><br><span class="line">                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = null, loTail = null;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;</span><br><span class="line">                        int lc = 0, hc = 0;</span><br><span class="line">                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123;</span><br><span class="line">                            int h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, null, null);</span><br><span class="line">                            if ((h &amp; n) == 0) &#123;</span><br><span class="line">                                if ((p.prev = loTail) == null)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if ((p.prev = hiTail) == null)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="addCount、sumCount方法"><a href="#addCount、sumCount方法" class="headerlink" title="addCount、sumCount方法"></a>addCount、sumCount方法</h3><p><code>addCount()</code>做的工作是更新table的size，也就是table存储的键值对数量，在使用<code>put()</code>和<code>remove()</code>方法的时候都会在执行成功之后调用<code>addCount()</code>来更新table的size。对于<code>ConcurrentHashMap</code>来说，它到底有储存有多少个键值对，谁也不知道，因为他是支持并发的，储存的数量无时无刻都在变化着，所以说<code>ConcurrentHashMap</code>也只是统计一个大概的值，为了统计出这个值也是大费周章才统计出来的。<br><img src="http://wx1.sinaimg.cn/large/e0e01e43ly1g0y4jjmzr3j21640kqwiy.jpg" alt="image"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">private final void addCount(long x, int check) &#123;</span><br><span class="line">    CounterCell[] as; long b, s;</span><br><span class="line">    //如果计算盒子不是空，或者修改baseCount的值+x失败,则放弃对baseCount的修改。</span><br><span class="line">    //这里的大概意思就是首先尝试直接修改baseCount，达到计数的目的，如果修改baseCount失败(</span><br><span class="line">    //多个线程同时修改，则失败)</span><br><span class="line">    //则使用CounterCell数组来达到计数的目的。</span><br><span class="line">    if ((as = counterCells) != null ||</span><br><span class="line">        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; long v; int m;</span><br><span class="line">        boolean uncontended = true;</span><br><span class="line">        //如果计数盒子是空的 或者随机取余一个数组为空 或者修改这个槽位的变量失败，</span><br><span class="line">        //即表示出现了并发，则执行fullAddCount()方法进行死循环插入，同时返回，</span><br><span class="line">        //否则代表修改这个槽位的变量成功了，继续往下执行，不进入if。</span><br><span class="line">        //每个线程都会通过ThreadLocalRandom.getProbe() &amp; m寻址找到属于它的CounterCell，</span><br><span class="line">        //然后进行计数。ThreadLocalRandom是一个线程私有的伪随机数生成器，</span><br><span class="line">        //每个线程的probe都是不同的。CounterCell数组的大小永远是一个2的n次方，初始容量</span><br><span class="line">        //为2，每次扩容的新容量都是之前容量乘以二，处于性能考虑，它的最大容量上限是机器</span><br><span class="line">        //的CPU数量，所以说CounterCell数组的碰撞冲突是很严重的。</span><br><span class="line">        if (as == null || (m = as.length - 1) &lt; 0 ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">             //并发过大，使用CAS修改CounterCell失败时候执行fullAddCount，</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果上面对盒子的赋值成功，且check&lt;=1，则直接返回，否则调用sumConut()方法计算</span><br><span class="line">        if (check &lt;= 1)</span><br><span class="line">            return;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    //如果check&gt;=0，则检查是否需要扩容。</span><br><span class="line">    if (check &gt;= 0) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; int n, sc;</span><br><span class="line">        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            int rs = resizeStamp(n);</span><br><span class="line">            if (sc &lt; 0) &#123;</span><br><span class="line">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||</span><br><span class="line">                    transferIndex &lt;= 0)</span><br><span class="line">                    break;</span><br><span class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (U.compareAndSwapInt(this, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br><span class="line">                transfer(tab, null);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@sun.misc.Contended static final class CounterCell &#123;</span><br><span class="line">    volatile long value;</span><br><span class="line">    CounterCell(long x) &#123; value = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final long sumCount() &#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    long sum = baseCount;</span><br><span class="line">    if (as != null) &#123;</span><br><span class="line">        for (int i = 0; i &lt; as.length; ++i) &#123;</span><br><span class="line">            if ((a = as[i]) != null)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="size、mappingCount方法"><a href="#size、mappingCount方法" class="headerlink" title="size、mappingCount方法"></a>size、mappingCount方法</h3><p><code>size</code>和<code>mappingCount</code>方法都是用来统计table的size的，这两者不同的地方在<code>size</code>返回的是一个<code>int</code>类型，即可以表示size的范围是[-2^31，2^31-1]，超过这个范围就返回int能表示的最大值，<code>mappingCount</code>返回的是一个<code>long</code>类型，即可以表示size的范围是[-2^63，2^63-1]。<br>这两个方法都是调用的sumCount()方法实现统计。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">    long n = sumCount();</span><br><span class="line">    return ((n &lt; 0L) ? 0 :</span><br><span class="line">            (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (int)n);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public long mappingCount() &#123;</span><br><span class="line">    long n = sumCount();</span><br><span class="line">    return (n &lt; 0L) ? 0L : n; // ignore transient negative values</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="HashMap、Hashtable、ConcurrentHashMap三者对比"><a href="#HashMap、Hashtable、ConcurrentHashMap三者对比" class="headerlink" title="HashMap、Hashtable、ConcurrentHashMap三者对比"></a>HashMap、Hashtable、ConcurrentHashMap三者对比</h2><table><thead><tr><th>\</th><th><strong>HashMap</strong></th><th><strong>Hashtable</strong></th><th><strong>ConcurrentHashMap</strong></th></tr></thead><tbody><tr><td>是否线程安全</td><td>否</td><td>是</td><td>是</td></tr><tr><td>线程安全采用的方式</td><td></td><td>采用<code>synchronized</code>类锁，效率低</td><td>采用<code>CAS</code> + <code>synchronized</code>，锁住的只有当前操作的<strong>bucket</strong>，不影响其他线程对其他bucket的操作，效率高</td></tr><tr><td>数据结构</td><td>数组+链表+红黑树(链表长度超过8则转红黑树)</td><td>数组+链表</td><td>数组+链表+红黑树(链表长度超过8则转红黑树)</td></tr><tr><td>是否允许<code>null</code>键值</td><td>是</td><td>否</td><td>否</td></tr><tr><td>哈希地址算法</td><td>(key的hashCode)^(key的hashCode无符号右移16位)</td><td>key的hashCode</td><td>( (key的hashCode)^(key的hashCode无符号右移16位) )&amp;0x7fffffff</td></tr><tr><td>定位算法</td><td>哈希地址&amp;(容量大小-1)</td><td>(哈希地址&amp;0x7fffffff)%容量大小</td><td>哈希地址&amp;(容量大小-1)</td></tr><tr><td>扩容算法</td><td>当键值对数量大于阈值，则容量扩容到原来的2倍</td><td>当键值对数量大于等于阈值，则容量扩容到原来的2倍+1</td><td>当键值对数量大于等于sizeCtl，<strong>单线程创建新哈希表，多线程复制bucket到新哈希表</strong>，容量扩容到原来的2倍</td></tr><tr><td>链表插入</td><td>将新节点插入到链表<strong>尾部</strong></td><td>将新节点插入到链表<strong>头部</strong></td><td>将新节点插入到链表<strong>尾部</strong></td></tr><tr><td>继承的类</td><td>继承<code>abstractMap</code>抽象类</td><td>继承<code>Dictionary</code>抽象类</td><td>继承<code>abstractMap</code>抽象类</td></tr><tr><td>实现的接口</td><td>实现<code>Map</code>接口</td><td>实现<code>Map</code>接口</td><td>实现<code>ConcurrentMap</code>接口</td></tr><tr><td>默认容量大小</td><td>16</td><td>11</td><td>16</td></tr><tr><td>默认负载因子</td><td>0.75</td><td>0.75</td><td>0.75</td></tr><tr><td>统计size方式</td><td>直接返回成员变量<code>size</code></td><td>直接返回成员变量<code>count</code></td><td>遍历<code>CounterCell</code>数组的值进行累加，最后加上<code>baseCount</code>的值即为<code>size</code></td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://cmsblogs.com/?p=2283" target="_blank" rel="noopener">【死磕Java并发】—–J.U.C之Java并发容器：ConcurrentHashMap</a><br><a href="http://www.importnew.com/29832.html" target="_blank" rel="noopener">Map 大家族的那点事儿 ( 7 ) ：ConcurrentHashMap</a><br><a href="http://www.importnew.com/28263.html?tdsourcetag=s_pcqq_aiomsg&amp;replytocom=667559#respond" target="_blank" rel="noopener">Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析</a><br><a href="https://juejin.im/entry/59fc786d518825297f3fa968" target="_blank" rel="noopener">Java 8 ConcurrentHashMap源码分析</a>      </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://wx3.sinaimg.cn/large/e0e01e43ly1g0y4kkt2k3j21y013bb2b.jpg&quot; alt=&quot;image&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;顾名思义就是同步的HashMap，也就是线程安全的HashMap，所以本篇介绍的ConcurrentHashMap和HashMap有着很重要的关系，所以建议之前没有了解过HashMap的可以先看看这篇关于HashMap的原理分析&lt;a href=&quot;https://ddnd.cn/2019/03/07/jdk1.8-hashmap/&quot;&gt;《HashMap从认识到源码分析》&lt;/a&gt;，本篇继续以&lt;code&gt;JDK1.8&lt;/code&gt;版本的源码进行分析，最后在介绍完ConcurrentHashMap之后会对ConcurrentHashMap、Hashtable和HashMap做一个比较和总结。&lt;/p&gt;
    
    </summary>
    
      <category term="Java编程基础" scheme="http://ddnd.cn/categories/Java-Programming/"/>
    
    
      <category term="Hashtable" scheme="http://ddnd.cn/tags/Hashtable/"/>
    
      <category term="HashMap" scheme="http://ddnd.cn/tags/HashMap/"/>
    
      <category term="ConcurrentHashMap" scheme="http://ddnd.cn/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>五分钟看懂Hashtable源码以及与HashMap的区别</title>
    <link href="http://ddnd.cn/2019/03/08/jdk1-8-hashtable/"/>
    <id>http://ddnd.cn/2019/03/08/jdk1-8-hashtable/</id>
    <published>2019-03-08T07:51:16.000Z</published>
    <updated>2019-03-12T10:14:15.266Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ws3.sinaimg.cn/large/e0e01e43ly1g0vnl8sswvj21y013e7wl.jpg" alt="image" width="100%" data-width="2520" data-height="1418"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇<a href="https://ddnd.cn/2019/03/07/jdk1.8-hashmap/">HashMap从认识到源码分析</a>我们认识了什么是<code>Map</code>、<code>Hash</code>，了解了<code>Hash</code>处理哈希冲突的几种常用方法(拉链法、开放定址法)，以及分析了JDK1.8版本的<code>HashMap</code>源码，对Java集合框架有了初步的认识，我们本篇继续分析JDK1.8版本的<code>Hashtable</code>源码，最后比较<code>HashMap</code>和<code>Hashtable</code>的区别。 </p><a id="more"></a><h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><p>注意是Hashtable不是HashTable(t为小写)，这不是违背了驼峰定理了嘛？这还得从Hashtable的出生说起，Hashtable是在<code>Java1.0</code>的时候创建的，而集合的统一规范命名是在后来的<code>Java2</code>开始约定的，而当时又发布了新的集合代替它，所以这个命名也一直使用到现在，所以Hashtable是一个<strong>过时</strong>的集合了，不推崇大家使用这个类，虽说Hashtable是过时的了，我们还是有必要分析一下它，以便对Java集合框架有一个整体的认知。<br>首先<code>Hashtable</code>采用<strong>拉链法</strong>处理哈希冲突，是<strong>线程安全</strong>的，键值不允许为<code>null</code>，不保证顺序，然后Hashtable继承自Dictionary，实现Map接口，Hashtable有几个重要的成员变量<code>table</code>、<code>count</code>、<code>threshold</code>、<code>loadFactor</code></p><ul><li>table：是一个<code>Entry[]</code>数据类型，而<code>Entry</code>实际是一个单链表</li><li>count：Hashtable的大小，即Hashtable中保存的键值对数量</li><li>threshold：Hashtable的阈值，用于判断是否需要调整Hashtable的容量，threshold = 容量<em>负载因子</em>，threshold=11*0.75 取整即8</li><li>loadFactor：用来实现快速失败机制的<br><img src="http://ws1.sinaimg.cn/large/e0e01e43ly1g0vnltvf4xj20ct07fwei.jpg" alt="image"></li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><code>Hashtable</code>有4个构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//无参构造函数 默认Hashtable容量是11，默认负载因子是0.75</span><br><span class="line">public Hashtable() &#123;</span><br><span class="line">    this(11, 0.75f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//指定Hashtable容量，默认负载因子是0.75</span><br><span class="line">public Hashtable(int initialCapacity) &#123;</span><br><span class="line">    this(initialCapacity, 0.75f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//指定Hashtable的容量和负载因子</span><br><span class="line">public Hashtable(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor);</span><br><span class="line"></span><br><span class="line">    if (initialCapacity==0)</span><br><span class="line">        initialCapacity = 1;</span><br><span class="line">    this.loadFactor = loadFactor;</span><br><span class="line">    //new一个指定容量的Hashtable</span><br><span class="line">    table = new Entry&lt;?,?&gt;[initialCapacity];</span><br><span class="line">    //阈值threshold=容量*负载因子</span><br><span class="line">    threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//包含指定Map的构造函数</span><br><span class="line">public Hashtable(Map&lt;? extends K, ? extends V&gt; t) &#123;</span><br><span class="line">    this(Math.max(2*t.size(), 11), 0.75f);</span><br><span class="line">    putAll(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的Hashtable容量和HashMap的容量就有区别，Hashtable并不要求容量是2的幂次方，而HashMap要求容量是2的幂次方。负载因子则默认都是0.75。</p><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><p><code>put</code>方法是<strong>同步</strong>的，即线程安全的，这点和<code>HashMap</code>不一样，还有具体的<code>put</code>操作和<code>HashMap</code>也存在很大的差别，Hashtable插入的时候是插入到<strong>链表头部</strong>，而HashMap是插入到<strong>链表尾部</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">//synchronized同步锁，所以Hashtable是线程安全的</span><br><span class="line">public synchronized V put(K key, V value) &#123;</span><br><span class="line">    // Make sure the value is not null</span><br><span class="line">    //如果值value为空，则抛出异常 至于为什么官方不允许为空，下面给出分析</span><br><span class="line">    if (value == null) &#123;</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Makes sure the key is not already in the hashtable.</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    //直接取key的hashCode()作为哈希地址，这与HashMap的取hashCode()之后再进行hash()的结果作为哈希地址 不一样</span><br><span class="line">    int hash = key.hashCode();</span><br><span class="line">    //数组下标=(哈希地址 &amp; 0x7FFFFFFF) % Hashtable容量，这与HashMap的数组下标=哈希地址 &amp; (HashMap容量-1)计算数组下标方式不一样，前者是取模运算，后者是位于运算，这也就是为什么HashMap的容量要是2的幂次方的原因，效率上后者的效率更高。</span><br><span class="line">    int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    //遍历Entry链表，如果链表中存在key、哈希地址相同的节点，则将值更新，返回旧值</span><br><span class="line">    for(; entry != null ; entry = entry.next) &#123;</span><br><span class="line">        if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            V old = entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            return old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果为新的节点，则调用addEntry()方法添加新的节点</span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    //插入成功返回null</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void addEntry(int hash, K key, V value, int index) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    //如果当前键值对数量&gt;=阈值，则执行rehash()方法扩容Hashtable的容量</span><br><span class="line">    if (count &gt;= threshold) &#123;</span><br><span class="line">        // Rehash the table if the threshold is exceeded</span><br><span class="line">        rehash();</span><br><span class="line"></span><br><span class="line">        tab = table;</span><br><span class="line">        //获取key的hashCode();</span><br><span class="line">        hash = key.hashCode();</span><br><span class="line">        //重新计算下标，因为Hashtable已经扩容了。</span><br><span class="line">        index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Creates the new entry.</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    //获取当前Entry链表的引用 复赋值给e</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">    //创建新的Entry链表的 将新的节点插入到Entry链表的头部，再指向之前的Entry，即在链表头部插入节点，这个和HashMap在尾部插入不一样。</span><br><span class="line">    tab[index] = new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>hashCode()为什么要&amp; 0x7FFFFFFF呢？因为某些对象的hashCode()可能是负值，&amp; 0x7FFFFFFF保证了进行%运算时候得到的下标是个正数</p></blockquote><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p><code>get</code>方法也是同步的，和<code>HashMap</code>不一样,即线程安全，具体的<code>get</code>操作和<code>HashMap</code>也有区别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//同步</span><br><span class="line">public synchronized V get(Object key) &#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    //和put方法一样 都是直接获取key的hashCode()作为哈希地址</span><br><span class="line">    int hash = key.hashCode();</span><br><span class="line">    //和put方法一样 通过(哈希地址 &amp; 0x7FFFFFFF)与Hashtable容量做%运算 计算出下标</span><br><span class="line">    int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    //遍历Entry链表，如果链表中存在key、哈希地址一样的节点，则找到 返回该节点的值，否者返回null</span><br><span class="line">    for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123;</span><br><span class="line">        if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            return (V)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//同步</span><br><span class="line">public synchronized V remove(Object key) &#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    int hash = key.hashCode();</span><br><span class="line">    int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    //遍历Entry链表，e为当前节点，prev为上一个节点</span><br><span class="line">    for(Entry&lt;K,V&gt; prev = null ; e != null ; prev = e, e = e.next) &#123;</span><br><span class="line">        //找到key、哈希地址一样的节点</span><br><span class="line">        if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            //如果上一个节点不为空(即不是当前节点头结点)，将上一个节点的next指向当前节点的next，即将当前节点移除链表</span><br><span class="line">            if (prev != null) &#123;</span><br><span class="line">                prev.next = e.next;</span><br><span class="line">            &#125; else &#123; //如果上一个节点为空，即当前节点为头结点，将table数组保存的链表头结点地址改成当前节点的下一个节点</span><br><span class="line">                tab[index] = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            //Hashtable的键值对数量-1</span><br><span class="line">            count--;</span><br><span class="line">            //获取被删除节点的值 并且返回</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = null;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rehash方法"><a href="#rehash方法" class="headerlink" title="rehash方法"></a>rehash方法</h3><p>Hashtable的<code>rehash</code>方法和HashMap的<code>resize</code>方法一样，是用来扩容哈希表的，但是扩容的实现又有区别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">protected void rehash() &#123;</span><br><span class="line">    //获取旧的Hashtable的容量</span><br><span class="line">    int oldCapacity = table.length;</span><br><span class="line">    //获取旧的Hashtable引用，为旧哈希表</span><br><span class="line">    Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    //新的Hashtable容量=旧的Hashtable容量 * 2 + 1，这里和HashMap的扩容不一样，HashMap是新的Hashtable容量=旧的Hashtable容量 * 2。</span><br><span class="line">    int newCapacity = (oldCapacity &lt;&lt; 1) + 1;</span><br><span class="line">    //如果新的Hashtable容量大于允许的最大容量值(Integer的最大值 - 8)</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123;</span><br><span class="line">        //如果旧的容量等于允许的最大容量值则返回</span><br><span class="line">        if (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">            // Keep running with MAX_ARRAY_SIZE buckets</span><br><span class="line">            return;</span><br><span class="line">        //新的容量等于允许的最大容量值</span><br><span class="line">        newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    //new一个新的Hashtable 容量为新的容量</span><br><span class="line">    Entry&lt;?,?&gt;[] newMap = new Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    //计算新的阈值</span><br><span class="line">    threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</span><br><span class="line">    table = newMap;</span><br><span class="line">    //扩容后迁移Hashtable的Entry链表到正确的下标上</span><br><span class="line">    for (int i = oldCapacity ; i-- &gt; 0 ;) &#123;</span><br><span class="line">        for (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != null ; ) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = old;</span><br><span class="line">            old = old.next;</span><br><span class="line"></span><br><span class="line">            int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity;</span><br><span class="line">            e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">            newMap[index] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来我们执行以下代码，验证以下数据迁移过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Hashtable hashtable = new Hashtable();</span><br><span class="line">for (int i = 1; i &lt;= 24; i ++) &#123;</span><br><span class="line">    hashtable.put(String.valueOf(i), i);</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 25; i &lt;= 80; i ++) &#123;</span><br><span class="line">    hashtable.put(String.valueOf(i), i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>new</code>一个Hashtable，默认容量是<code>11</code>，负载因子是<code>0.75</code><br>执行第一个<code>for</code>循环后，<code>20</code>保存在下标为<code>0</code>的<code>Entry</code>中，即<code>(hash &amp;0x7FFFFFFF) % 容量 -&gt; (1598 &amp;0x7FFFFFFF) % 11 = 0</code><br><img src="http://wx1.sinaimg.cn/large/e0e01e43ly1g0vnm42jo8j20xd0nx76s.jpg" alt="image"></p><p>执行第二个<code>for</code>循环后，变成了<code>20</code>保存在下标为<code>70</code>的<code>Entry</code>中，因为Hashtable扩容了4次，分别是从容量为默认的11-&gt;23-&gt;47-&gt;95-&gt;191，然后此时容量是191，所以<code>(hash &amp;0x7FFFFFFF) % 容量 -&gt; (1598 &amp;0x7FFFFFFF) % 191 = 70</code><br><img src="http://wx1.sinaimg.cn/large/e0e01e43ly1g0vnmd81wyj20u40of0va.jpg" alt="image"></p><h2 id="HashMap和Hashtable区别"><a href="#HashMap和Hashtable区别" class="headerlink" title="HashMap和Hashtable区别"></a>HashMap和Hashtable区别</h2><p>到这里我们分析了HashMap和Hashtable的原理，现在比较以下他们的区别。  </p><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ul><li><strong>继承的类不一样</strong>：HashMap继承的<code>AbstractMap</code>抽象类，Hashtable继承的<code>Dictionay</code>抽象类</li><li><strong>应对多线程处理方式不一样</strong>：HashMap是非线程安全的，Hashtable是线程安全的，所以Hashtable效率比较低</li><li><strong>定位算法不一样</strong>：HashMap通过<code>key</code>的hashCode()进行hash()得到哈希地址，数组下标=哈希地址 &amp; (容量 - 1)，采用的是与运算，所以<strong>容量需要是2的幂次方结果才和取模运算结果一样</strong>。而Hashtable则是：数组下标=(key的hashCode() &amp; 0x7FFFFFFF ) % 容量，采用的取模运算，所以容量没要求</li><li><strong>键值对规则不一样</strong>：HashMap允许键值为<code>null</code>，而Hashtable不允许键值为<code>null</code></li><li><strong>哈希表扩容算法不一样</strong>：HashMap的容量扩容按照原来的容量*2，而Hashtable的容量扩容按照原来的容量*2+1</li><li><strong>容量(capacity)默认值不一样</strong>：HashMap的容量默认值为16，而Hashtable的默认值是11</li><li><strong>put方法实现不一样</strong>：HashMap是将节点插入到链表的尾部，而Hashtable是将节点插入到链表的头部</li><li><strong>底层结构不一样</strong>：HashMap采用了<strong>数组+链表+红黑树</strong>，而Hashtable采用<strong>数组+链表</strong></li></ul><blockquote><p>为什么HashMap允许<code>null</code>键值呢，而Hashtable不允许<code>null</code>键值呢？这里还得先介绍一下什么是<code>null</code>，我们知道Java语言中有两种类型，一种是<strong>基本类型</strong>还有一种是<strong>引用类型</strong>，其实还有一种特殊的类型就是<code>null</code>类型，它不代表一个对象(Object)也不是一个对象(Object)，然后在HashMap和Hashtable对键的操作中使用到了<strong>Object</strong>类中的<code>equals</code>方法，所以如果在Hashtable中置键值为<code>null</code>的话就可想而知会报错了，但是为什么HashMap可以呢？因为HashMap采用了特殊的方式，将<code>null</code>转为了对象(Object)，具体怎么转的，这里就不深究了。</p></blockquote><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul><li><strong>实现相同的接口</strong>：HashMap和Hashtable均实现了<code>Map</code>接口</li><li><strong>负载因子(loadFactor)默认值一样</strong>：HashMap和Hashtable的负载因子默认都是0.75</li><li><strong>采用相同的方法处理哈希冲突</strong>：都是采用链地址法即拉链法处理哈希冲突</li><li><strong>相同哈希地址可能分配到不同的链表，同一个链表内节点的哈希地址不一定相同</strong>：因为HashMap和Hashtable都会扩容，扩容后容量变化了，相同的哈希地址取到的数组下标也就不一样。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.yuanrengu.com/index.php/2017-01-17.html" target="_blank" rel="noopener">HashMap、HashTable、ConcurrentHashMap的原理与区别</a><br><a href="https://juejin.im/post/5a03b258518825188e515d89" target="_blank" rel="noopener">Java集合之Hashtable源码解析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ws3.sinaimg.cn/large/e0e01e43ly1g0vnl8sswvj21y013e7wl.jpg&quot; alt=&quot;image&quot; width=&quot;100%&quot; data-width=&quot;2520&quot; data-height=&quot;1418&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇&lt;a href=&quot;https://ddnd.cn/2019/03/07/jdk1.8-hashmap/&quot;&gt;HashMap从认识到源码分析&lt;/a&gt;我们认识了什么是&lt;code&gt;Map&lt;/code&gt;、&lt;code&gt;Hash&lt;/code&gt;，了解了&lt;code&gt;Hash&lt;/code&gt;处理哈希冲突的几种常用方法(拉链法、开放定址法)，以及分析了JDK1.8版本的&lt;code&gt;HashMap&lt;/code&gt;源码，对Java集合框架有了初步的认识，我们本篇继续分析JDK1.8版本的&lt;code&gt;Hashtable&lt;/code&gt;源码，最后比较&lt;code&gt;HashMap&lt;/code&gt;和&lt;code&gt;Hashtable&lt;/code&gt;的区别。 &lt;/p&gt;
    
    </summary>
    
      <category term="Java编程基础" scheme="http://ddnd.cn/categories/Java-Programming/"/>
    
    
      <category term="Hashtable" scheme="http://ddnd.cn/tags/Hashtable/"/>
    
  </entry>
  
  <entry>
    <title>HashMap从认识到源码分析</title>
    <link href="http://ddnd.cn/2019/03/07/jdk1.8-hashmap/"/>
    <id>http://ddnd.cn/2019/03/07/jdk1.8-hashmap/</id>
    <published>2019-03-07T07:58:20.000Z</published>
    <updated>2019-03-12T10:14:08.150Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://wx3.sinaimg.cn/large/e0e01e43ly1g0vf2bq3xgj21g80ytkjm.jpg" alt="image" width="100%"></p><a id="more"></a><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map在开发过程中使用频率很高的数据结构，Map是<code>Key-value</code>键值对映射的抽象<strong>接口</strong>，该映射不包括重复的键，既一个键对应一个值。<code>HashMap</code>、<code>HashTable</code>、<code>ConcurrentHashMap</code>都是Java Collection Framework的重要成员。Map接口提供三种collection视图，允许以键集(keySet())、值集(values())或键-值映射关系集(entrySet())的形式查看某个映射的内容。<br><img src="https://user-gold-cdn.xitu.io/2019/3/7/169575a7d1acb827?w=1018&amp;h=636&amp;f=png&amp;s=48415" alt=""></p><h2 id="HasH表"><a href="#HasH表" class="headerlink" title="HasH表"></a>HasH表</h2><p>我们知道数组的储存方式是在内存上分配固定的连续的空间，寻址速度快（查询速度快），时间复杂度为<code>O(1)</code>，但是在插入、删除元素时候需要移动数组的元素，所以插入、删除时候速度慢，时间复杂度为<code>O(n)</code>。链表的存储方式在内存上是不连续的，每个元素都保存着下个元素的内存地址，通过这个地址找到下个元素，所以链表在查询的时候速度慢，时间复杂度为<code>O(n)</code>，在插入和删除的时候速度快，时间复杂度为<code>O(1)</code>。<br>如果我们想要一个数据结构既查询速度快，插入和删除速度也要快，那我们应该怎么做呢？这时<strong>哈希(Hash)表</strong>就应时而生了，通过<strong>哈希函数</strong>计算出<strong>键</strong>在哈希表中指定的储存位置(注意这里的储存位置是在表中的位置，并不是内存的地址)，称为哈希地址，然后将值储存在这个哈希地址上，然后通过<strong>键</strong>就可以直接操作到<strong>值</strong>，查询、插入、删除等操作时间复杂度都是<code>O(1)</code>。<br>既然是键通过哈希函数计算出储存位置，那么哈希函数的好坏直接影响到哈希表的操作效率，如会出现浪费储存空间、出现大量冲突(即不同的键计算出来的储存位置一样)。     </p><blockquote><p>哈希函数可以将任意长度的输入映射成固定长度的输出，也就是哈希地址<br>哈希冲突是不可避免的，常用的哈希冲突解决办法有以下2种方法。            </p></blockquote><ol><li><strong>链地址法(拉链法)</strong><br>采用数组和链表结合的方法，对哈希表中每个哈希地址建立一个线性表，将哈希地址相同的数据储存在线性表中，并将<strong>链表的头指针保存在数组中</strong>，哈希地址、键、值等信息一般保存在链表节点中。一般通过哈希地址计算出数组的下标，将哈希值相同的保存在下标相同的数组中的。拉链法适合经常进行插入、删除操作的情况。<br><img src="https://user-gold-cdn.xitu.io/2019/3/7/16957dc37460bcb7?w=541&amp;h=336&amp;f=png&amp;s=15864" alt=""></li><li><strong>开放定址法</strong><br>开放定址法也称线性探测法，基本思想是：将哈希表T[0…m-1]看成是个循环向量，若初始探测地址为d，则最长的探测路径为：d，d+i，d+2i，…，m-1。即探测时候从地址d开始，首先探测T[d]，如果T[d]发生哈希冲突则继续探测下一个T[d+1]…直到探测到T[m-1]为止，i为自定义的常数。开放定址法很容易产生<strong>堆聚现象</strong>，所谓堆聚现象就是哈希表中的数据连成一片，在加入新元素的时候就容易产生哈希冲突。</li><li><strong>拉链法和开放定址比较</strong><br>拉链法：处理冲突简单，无堆聚现象，同时链表插入、删除操作简单，所以拉链法适合经常进行插入、删除操作的情况。<br>开放定址法：为了减少冲突，要求<strong>负载因子(装填因子)</strong>较小，当节点规模较大时候会浪费很多空间。且开放定址法在删除节点的时候，不能简单的将节点所在的空间置为空，否则将截断在它之后的节点的查找路径，这是因为各种开放定址法中，<strong>空地址单元都是查找失败的条件</strong>。因此在进行删除节点操作的时候，需要使用逻辑删除，即在被删除的节点上做删除标记。                   </li></ol><blockquote><p>负载因子 = 填入哈希表中的元素个数 / 哈希表的数组长度   </p></blockquote><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><code>HashMap</code>采用上述的<strong>拉链法</strong>解决哈希冲突.HashMap是非线程安全的，允许键、值为<code>null</code>，不保证有序(比如插入的顺序)，也不保证顺序不随时间变化(哈希表加倍扩容后，数据会有迁移)。<br>我们创建个HashMap运行看看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; map = new HashMap();</span><br><span class="line">map.put(&quot;语文&quot;, 1);</span><br><span class="line">map.put(&quot;数学&quot;, 2);</span><br><span class="line">map.put(&quot;英语&quot;, 3);</span><br><span class="line">map.put(&quot;历史&quot;, 4);</span><br><span class="line">map.put(&quot;政治&quot;, 5);</span><br><span class="line">map.put(&quot;地理&quot;, 6);</span><br><span class="line">map.put(&quot;生物&quot;, 7);</span><br><span class="line">map.put(&quot;化学&quot;, 8);</span><br></pre></td></tr></table></figure></p><p><img src="http://ws4.sinaimg.cn/large/e0e01e43ly1g0vezgvmdvj211l0jnq8d.jpg" alt="image"><br>通过图可以看到HashMap并不是按照插入顺序存储的(无序的)。<br>接下来我们看看HashMap的<strong>数据结构</strong><br><img src="http://ws2.sinaimg.cn/large/e0e01e43ly1g0vezylsa5j20he0dhwg2.jpg" alt="image"><br>HashMap有几个重要的成员变量，<code>table</code>，<code>size</code>，<code>threshold</code>，<code>loadFactor</code>，<code>modCount</code>。</p><ul><li>table：是一个<code>Entry[]</code>数组类型，而<code>Entry</code>实际上是一个<strong>单向链表</strong>，哈希表的键值对都是储存在<code>Entry</code>数组中，每个<code>Entry</code>对应一个哈希地址，这里的<code>Entry</code>即常说的桶</li><li>size：是HashMap的大小，为保存的键值对的数量</li><li>DEFAULT_INITIAL_CAPACITY：HashMap默认容量(数组的大小) 默认为16</li><li>MAXIMUM_CAPACITY：HashMap的最大容量(2的30)，如果传入的容量大于这个值，则被最大容量替换</li><li>threshold：是HashMap的阈值，用于判断是否需要调整HashMap的容量。threshold=容量*负载因子，当HashMap中储存的键值对数量到达threshold时，HashMap就会将容量<strong>加倍</strong>的扩容</li><li>loadFactor：即负载因子</li><li>modCount：用来实现<strong>快速失败(fail-fast)机制</strong>的<blockquote><p>快速失败机制：对于<strong>线程不安全</strong>(注意是线程不安全的集合才有这个机制)的集合对象的迭代器，如果在使用迭代器的过程中有其他的线程修改了集合对象的结构或者元素数量，那么迭代立刻结束，迭代器将抛出<code>ConcurrentModificationException</code>。</p></blockquote><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3>HashMap有4个构造函数，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//无参构造函数，负载因子为默认的0.75，HashMap的容量(数组大小)默认容量为16</span><br><span class="line">public HashMap() &#123;</span><br><span class="line">    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//指定HashMap容量大小的构造函数 负载因子为默认的0.75</span><br><span class="line">public HashMap(int initialCapacity) &#123;</span><br><span class="line">    this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//指定HashMap容量大小和负载因子的构造函数</span><br><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    this.loadFactor = loadFactor;</span><br><span class="line">    this.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//包含子Map的构造函数，负载因子为默认的0.75</span><br><span class="line">public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">    this.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>为什么负载因子默认是0.75？按照官方给出的解释是，当负载因子为0.75时候，<code>Entry</code>单链表的长度几乎不可能超过<code>8</code>(到达8的概率是0.00000006)，作用就是让<code>Entry</code>单链表的长度尽量小，让HashMap的查询效率尽可能高。</p></blockquote><p>由于当HashMap的大小(即size)大于初始容量(capacity)时候，HashMap就会扩大一倍，由于很多时候并不需要扩大这么多，所以当我们知道我们的数据的大小的时候，就可以在HashMap初始化的时候指定容量(数组大小)。<br>需要注意的是，我们指定的容量必须是<strong>2的幂次方</strong>，即使我们传入的容量不是2的幂次方，源码中也会将容量转成2的幂次方，比如我们传入的是5，最终的容量是8。</p><blockquote><p>为什么容量一定要是2的幂次方？因为HashMap是数组+单链表的结构，我们希望元素的存放的更均匀，最理想的状态是每个<code>Entry</code>中只存放一个元素，这样在查询的时候效率最高。那怎么才能均匀的存放呢？我们首先想到的是取模运算 哈希地址%容量大小，SUN的大师们的想法和我们的也一样，只不过他们使用位运算来实现这个运算(位运算效率高)，为了使位运算和取模运算结果一样，即<code>hash &amp; (capacity - 1) == hash % capacity</code>，容量(Capacity)的大小就必须为2的幂次方。</p></blockquote><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><p>在JDK1.8之前hashMap的插入是在链表的头部插入的，本文分析的是JDK1.8源码，是在链表的尾部插入的。     </p><ol><li>根据键(key)的<code>hashCode()</code>计算出当前键值对的<strong>哈希地址</strong>，用于定位键值对在HashMap数组中存储的下标</li><li>判断<code>table</code>是否初始化，没有初始化则调用<code>resize()</code>为<code>table</code>初始化容量，以及threshold的值</li><li>根据<strong>table数组长度和哈希地址做&amp;运算(i = (n - 1) &amp; hash)</strong>计算出该key对应的<code>table</code>数组索引，如果对应的数组索引位置没有值，则调用<code>newNode(hash, key, value, null)</code>方法，为该键值对创建节点。<blockquote><p>这里思考个问题，当table数组长度变化后，是不是取到的值就不正确了？后面给出分析。这里简单分析下为什么不是直接按照哈希地址做数组下标，而是用<strong>table数组长度和哈希地址做&amp;运算(i = (n - 1) &amp; hash)</strong>(因为数组的大小是2的幂次方，所以这个运算等效于mod 数组大小的运算)计算数组下标，因为哈希地址可能超过数组大小，还有就是为了让键值对更均匀的分布的在各个桶(链表)中，也因为容量会变所以各个桶(链表)中的节点的哈希地址并不是相同的，相同的哈希地址也可能分到不同的下标。</p></blockquote></li><li>如果根据哈希地址计算出该key对应的<code>table</code>数组索引有节点，且节点的键<code>key</code>和传入的键<code>key</code>相等，哈希地址和传入的哈希地址也相等，<strong>则将对应的节点引用赋值给e</strong>。</li><li>如果根据哈希地址计算出该key对应的<code>table</code>数组索引有节点，且节点的哈希地址和传入的哈希地址一样，但是节点的键<code>key</code>和传入的键<code>key</code>不相等，则遍历链表，如果遍历过程中找到节点的键<code>key</code>和传入的键<code>key</code>相等，哈希地址和传入的哈希地址也相等，则将对应的<code>value</code>值更新。否则调用<code>newNode(hash, key, value, null)</code>方法，为该键值对创建节点添加到链表<strong>尾部</strong>，如果追加节点后的链表长度 &gt;= 8，则转为红黑树</li><li>如果e不为空，且<code>onlyIfAbsent</code>为<code>true</code>则不会覆盖相同<code>key</code>和相同哈希地址的<code>value</code>。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果参数onlyIfAbsent是true，那么不会覆盖相同key的值value。如果evict是false。那么表示是在初始化时调用的</span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    //tab存放 当前的哈希桶， p用作临时链表节点  </span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    //如果当前哈希表是空的，代表是初始化</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        //那么直接去扩容哈希表，并且将扩容后的哈希桶长度赋值给n</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    //如果当前index的节点是空的，表示没有发生哈希碰撞。 直接构建一个新节点Node，挂载在index处即可。</span><br><span class="line">    //这里再啰嗦一下，数组下标index 是利用 哈希地址 &amp; 哈希桶的长度-1，替代模运算</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123;//否则 发生了哈希冲突。</span><br><span class="line">        //e</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        //如果哈希值相等，key也相等，则是覆盖value操作</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;//将当前节点引用赋值给e</span><br><span class="line">        else if (p instanceof TreeNode)//红黑树暂且不谈</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123;//不是覆盖操作，则插入一个普通链表节点</span><br><span class="line">            //遍历链表</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                if ((e = p.next) == null) &#123;//遍历到尾部，追加新节点到尾部</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    //如果追加节点后，链表数量》=8，则转化为红黑树</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //如果找到了要覆盖的节点</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果e不是null，说明有需要覆盖的节点，</span><br><span class="line">        if (e != null) &#123; // existing mapping for key</span><br><span class="line">            //则覆盖节点值，并返回原oldValue</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            //这是一个空实现的函数，用作LinkedHashMap重写使用。</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果执行到了这里，说明插入了一个新的节点，所以会修改modCount，以及返回null。</span><br><span class="line"></span><br><span class="line">    //修改modCount</span><br><span class="line">    ++modCount;</span><br><span class="line">    //更新size，并判断是否需要扩容。</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    //这是一个空实现的函数，用作LinkedHashMap重写使用。</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>hashCode()是Object类的一个方法，hashCode()方法返回对象的hash code，这个方法是为了更好的支持hash表，比如Set、HashTable、HashMap等。hashCode()的作用：如果用equals去比较的话，如果存在1000个元素，你new一个新的元素出来，需要去调用1000次equals去逐个和它们比较是否是同一个对象，这样会大大降低效率。ashcode实际上是返回对象的存储地址，如果这个位置上没有元素，就把元素直接存储在上面，如果这个位置上已经存在元素，这个时候才去调用equal方法与新元素进行比较，相同的话就不存了，散列到其他地址上。</p></blockquote><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><ol><li><code>table</code>不为空，且<code>table</code>的长度大于0，且根据键<code>key</code>的<code>hashCode()</code>计算出<strong>哈希地址</strong>，再<strong>根据桶的数量-1和哈希地址做&amp;运算</strong>计算出数组的下标，该下标下不为空(即存有链表头指针)则继续往下进行，否则返回<code>null</code>。</li><li>如果和第一个节点的哈希地址、键<code>key</code>都相同，则返回第一个节点。</li><li>如果第一个节点的下个节点不为空，则继续，如果第一个节点为树的节点，则执行<code>getTreeNode(hash, key)</code>，在树中寻找节点，并且返回。否则遍历链表，找到键<code>key</code>、哈希地址一样的则返回此节点。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        if (first.hash == hash &amp;&amp; // 如果索引到的第一个Node，key 和 hash值都和传递进来的参数相等，则返回该Node</span><br><span class="line">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        if ((e = first.next) != null) &#123; //如果索引到的第一个Node 不符合要求，循环变量它的下一个节点。</span><br><span class="line">            if (first instanceof TreeNode) // 在树中get</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            do &#123;// 在链表中get</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><ol><li><code>table</code>不为空，且<code>table</code>的长度大于0，且根据键<code>key</code>的<code>hashCode()</code>计算出<strong>哈希地址</strong>，再根据哈希地址计算出数组的下标，该下标下不为空(即存有链表头指针)则继续往下进行，否则执行6`。</li><li>如果哈希地址、键<code>key</code>一样，<strong>则将对应的节点引用赋值给node</strong>，然后执行4。否则执行3。</li><li>如果为树，则执行<code>getTreeNode(hash, key)</code>在树中寻找节点并且返回，否则遍历链表，找到键<code>key</code>、哈希地址一样的节点然后<strong>将对应的节点引用赋值给node</strong>，然后执行4，否则执行6。</li><li>如果节点<code>node</code>不为空(即查询到键<code>key</code>对应的节点)，且当<code>matchValue</code>为<code>false</code>的时候或者<code>value</code>也相等的时候，则执行5，否则执行6。</li><li>如果节点为树，则调用<code>removeTreeNode(this, tab, movable)</code>移除相应的节点。否则在链表中移除相应的节点，</li><li>返回<code>null</code>。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = removeNode(hash(key), key, null, false, true)) == null ?</span><br><span class="line">        null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,</span><br><span class="line">                           boolean matchValue, boolean movable) &#123;</span><br><span class="line">    // p 是待删除节点的前置节点</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;</span><br><span class="line">    //如果哈希表不为空，则根据hash值算出的index下 有节点的话。</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        //node是待删除节点</span><br><span class="line">        Node&lt;K,V&gt; node = null, e; K k; V v;</span><br><span class="line">        //如果链表头的就是需要删除的节点</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;//将待删除节点引用赋给node</span><br><span class="line">        else if ((e = p.next) != null) &#123;//否则循环遍历 找到待删除节点，赋值给node</span><br><span class="line">            if (p instanceof TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            else &#123;</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; while ((e = e.next) != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果有待删除节点node，  且 matchValue为false，或者值也相等</span><br><span class="line">        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != null &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            if (node instanceof TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);</span><br><span class="line">            else if (node == p)//如果node ==  p，说明是链表头是待删除节点</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            else//否则待删除节点在表中间</span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;//修改modCount</span><br><span class="line">            --size;//修改size</span><br><span class="line">            afterNodeRemoval(node);//LinkedHashMap回调函数</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="containsKey方法"><a href="#containsKey方法" class="headerlink" title="containsKey方法"></a>containsKey方法</h3><p>如果存在指定的键<code>key</code>，返回true，否则返回false。<br>containsKey方法调用的get调用的方法一样的方法，参考get方法的解析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean containsKey(Object key) &#123;</span><br><span class="line">    return getNode(hash(key), key) != null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="哈希表的初始化和加倍扩容resize方法"><a href="#哈希表的初始化和加倍扩容resize方法" class="headerlink" title="哈希表的初始化和加倍扩容resize方法"></a>哈希表的初始化和加倍扩容resize方法</h3><p>分析resize方法，我们就可以知道为什么哈希表的容量变化后，仍然能取到正确的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    //如果哈希表是空的 则将旧容量置为0，否则置为旧哈希表的容量</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    //旧的哈希表的阈值</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    //新的哈希表的容量和阈值 都置为0</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    //如果旧的容量大于0 即不是第一次初始化 是扩容操作</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        //旧的容量是否大于2的30次幂方(容量的最大值)</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            //阈值设置为Integer的最大值</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            //返回旧的哈希表(旧的哈希表已经到最大的容量了，不能继续扩容 所以返回)</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        //新的哈希表容量的=旧的容量&lt;&lt;1，即新的容量=旧的2倍，如果新的容量小于2的30次幂方(容量的最大值) 且 旧的容量大于等于默认的容量(16)</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            //新的哈希表的阈值=旧的哈希表的阈值&lt;&lt;1，既即新的阈值=旧的2倍 扩容table</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    //第一次初始化，如果旧的阈值&gt;0 即HashMap是以传入容量大小或者传入容量大小、负载因子的构造函数进行初始化的，阈值threshlod已经在构造函数初始化过了，所以阈值在这里大于0</span><br><span class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">        //新的容量=旧的阈值</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    //如果是以无参构造函数进行初始化的，则 新的容量大小=默认的容量大小，新的阈值=默认的负载因子*默认的容量大小</span><br><span class="line">    else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    //新的阈值=0，即执行的是上面的else if (oldThr &gt; 0)(使用带参数的构造函数初始化)，是使用带参数的构造函数进行的初始化，并且计算出新的阈值</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">    //创建新的哈希表，容量为新的容量</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    //重点看这部分，如果旧的哈希表不为空</span><br><span class="line">    if (oldTab != null) &#123;</span><br><span class="line">        //遍历旧的哈希表，</span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            //如果旧的哈希表的节点不为空</span><br><span class="line">            if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                oldTab[j] = null;</span><br><span class="line">                //如果节点没有下个节点了(即只有一个节点)，则直接放到新的哈希表中</span><br><span class="line">                if (e.next == null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                else &#123; // preserve order</span><br><span class="line">                    //将旧的哈希表的节点全部重新定位，比如旧的哈希表容量是16，有一个值a放在数组下标为0上，现在新的哈希表容量是32，重新定位后值a就被重新定位到下标为32上，即新的哈希表的下标为32储存值a，简单来说就是 新的下标=旧的哈希表的下标+新的哈希表的容量，正是因为这个节点的迁移，所以我们在hashMap put get操作的时候，在哈希表容量变化后仍让取到正确的值，但是也因为这个迁移操作，</span><br><span class="line">                    会消耗很多资源，所以尽量在创建HashMap的时候就估计哈希表的容量，尽量不要让他加倍扩容。这里的迁移也都是运用的位运算，所以在初始化的时候，桶的数量必须是2</span><br><span class="line">                    幂次方，才能保证位运算和取模运算结果一样。</span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                            if (loTail == null)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail == null)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e = next) != null);</span><br><span class="line">                    if (loTail != null) &#123;</span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (hiTail != null) &#123;</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以运行个例子，调试看看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; map = new HashMap();</span><br><span class="line">for (int i = 1; i &lt;= 24; i ++) &#123;</span><br><span class="line">    map.put(String.valueOf(i), i);</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 25; i &lt;= 80; i ++) &#123;</span><br><span class="line">    map.put(String.valueOf(i), i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们以无参构造函数(即哈希表容量默认是16，负载因子默认是0.75)<code>new</code>一个HashMap，然后调试看看</p><p><img src="http://ws4.sinaimg.cn/large/e0e01e43ly1g0vf07q9plj20vt0ldacm.jpg" alt="image"><br>运行第一个<code>for</code>循环，看到<code>11</code>保存的下标为0，<code>12</code>保存的下标是1<br>在继续运行第二个<code>for</code>，发现下标为0的变成了44，下标为1的变成了45<br><img src="http://wx4.sinaimg.cn/large/e0e01e43ly1g0vf0g8sq8j20q10netbf.jpg" alt="image"><br>那我们的11和12保存在哪了？可以发现11和12到了下标为32、33上，即当执行第二个<code>for</code>的时候哈希表发生了扩容，然后节点都迁移了，新的下标=旧的下标+新的哈希表的容量<br><img src="http://ws2.sinaimg.cn/large/e0e01e43ly1g0vf0lbaphj20fo0b0ab8.jpg" alt="image"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://user-gold-cdn.xitu.io/2019/3/8/1695c2ad3c842d8a" target="_blank" rel="noopener">Java HashMap工作原理及实现</a><br><a href="https://blog.csdn.net/justloveyou_/article/details/62893086" target="_blank" rel="noopener">Map 综述（一）：彻头彻尾理解 HashMap</a>      </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://wx3.sinaimg.cn/large/e0e01e43ly1g0vf2bq3xgj21g80ytkjm.jpg&quot; alt=&quot;image&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java编程基础" scheme="http://ddnd.cn/categories/Java-Programming/"/>
    
    
      <category term="HashMap" scheme="http://ddnd.cn/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>计算机如何储存数字和字符</title>
    <link href="http://ddnd.cn/2019/02/16/byte-hex-ascii/"/>
    <id>http://ddnd.cn/2019/02/16/byte-hex-ascii/</id>
    <published>2019-02-16T03:46:40.000Z</published>
    <updated>2019-03-12T10:13:49.996Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ws3.sinaimg.cn/large/e0e01e43gy1g08660xgavj20sg0lc43a.jpg" alt="image" width="100%"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在学习中涉及到计算机储存、传输数字和字符等操作，由于对字节、<code>2</code>进制、<code>10</code>进制、<code>16</code>进制、ASCII码的概念以及它们之间的关系和转换理解的不够透彻，导致在通讯、<code>MD5</code>消息摘要算法等时候出现问题，是因为<strong>数据</strong>转成<strong>计算机认识的01</strong>的这个环节出现问题。由于这个问题并不是那么容易发现，所以我也算是花了挺多时间才解决了这个问题，记录下解决过程，顺便也当复习一下计算机组成原理。</p><a id="more"></a><h2 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h2><p>在计算机中，所有的数据在存储和运算时都要使用<strong>二进制数</strong>表示（因为计算机用高电平和低电平分别表示1和0），例如，像a、b、c、d这样的52个字母（包括大写）以及0、1等数字还有一些常用的符号（例如*、#、@等）在计算机中存储时也要使用二进制数来表示，而具体用哪些二进制数字表示哪个符号，当然每个人都可以约定自己的一套（这就叫编码），而大家如果要想互相通信而不造成混乱，那么大家就必须使用相同的编码规则，于是美国有关的标准化组织就出台了ASCII编码，统一规定了上述常用符号用哪些二进制数来表示。<br>ASCII 码一共规定了<code>128</code>个字符（<code>0000 0000</code>-<code>0111 1111</code>）的编码，比如空格<code>SPACE</code>是32（二进制<code>0010 0000</code>），大写的字母<code>A</code>是65（二进制<code>0100 0001</code> ）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位（低7位），最前面的一位（高1位）统一规定为<code>0</code>(不要和数字的符号位搞混)。<br>当然除了ASCII码，还有UTF-8、GBK等。</p><h2 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h2><p>字节(Byte)普通计算机系统能读取和定位到最小信息单位，即我们通过计算机储存和传输数据的时候都是先把数据转成字节。<br>字节即<code>Byte</code>，一个字节代表<code>8</code>个比特（Bit），字节通常缩写为B，比特通常缩写为b。字节的大小是<code>8</code>Bit，即字节的范围是<code>0000 0000</code> - <code>1111 1111</code>，对于<strong>无符号型</strong>，它表示的十进制范围是[0,255]，对于<strong>有符号型</strong>，高一位表示符号位，它表示的十进制范围是[-128,127]。</p><h2 id="计算机若何储存数据"><a href="#计算机若何储存数据" class="headerlink" title="计算机若何储存数据"></a>计算机若何储存数据</h2><p>计算机只认识<code>0</code>和<code>1</code>（因为计算机只有高低电平两个状态），数据要想通过计算机储存或者传输，首先是要把数据转成计算机能认识的格式即01数据。<br>我们举个例子，以储存十进制数字<code>28</code>和<code>-28</code>为例，首先将十进制数转成二进制。    </p><blockquote><p><strong>需要注意的是：</strong> 数字在计算机中储存的是补码，而字符是在计算机中储存的是字符对应的编码（不要和数字的补码搞混）。</p></blockquote><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>储存十进制数字<code>28</code>和<code>-28</code>为例，首先将十进制数转成二进制，高<code>1</code>位为<code>0</code>代表正数，为<code>1</code>代表负数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">28(10) = 0001 1100(2)(原码)            </span><br><span class="line">-28(10) = 1001 1100(2)(原码)</span><br></pre></td></tr></table></figure></p><p>然后计算机将二进制数字进行补码运算，运算结果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">28(10) = 0001 1100(2)(原码) =  0001 1100(2)(补码)       </span><br><span class="line">-28(10) = 1001 1100(2)(原码) = 1110 0100(2)(补码)</span><br></pre></td></tr></table></figure></p><p>然后计算机保存的就是<strong>补码</strong>，当要取出数据的时候，就将补码逆运算一下，即可求出原码，再将原码转换一下就可以得到真实的数据了。<br>下面以Java语言演示这个过程，首先我们要清楚Java的byte、short、int、long都是有符号的(signed)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) throws NoSuchAlgorithmException &#123;</span><br><span class="line">        int a1 = 28;</span><br><span class="line">        int a2 = -28;</span><br><span class="line"></span><br><span class="line">//        转成二进制表示</span><br><span class="line">        String b1 = Integer.toBinaryString(a1);</span><br><span class="line">        String b2 = Integer.toBinaryString(a2);</span><br><span class="line">//        转成无无符号表示</span><br><span class="line">        String b3 = Integer.toUnsignedString(a1);</span><br><span class="line">        String b4 = Integer.toUnsignedString(a2);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;28储存到计算机后为：&quot; + b1);</span><br><span class="line">        System.out.println(&quot;-28储存到计算机后为：&quot; + b2);</span><br><span class="line">        System.out.println(&quot;取出储存的28 以无符号表示：&quot; + b3);</span><br><span class="line">        System.out.println(&quot;取出储存的-28 以无符号表示：&quot; + b4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">28储存到计算机后为：11100</span><br><span class="line">-28储存到计算机后为：11111111111111111111111111100100</span><br><span class="line">取出储存的28 以无符号表示：28</span><br><span class="line">取出储存的-28 以无符号表示：4294967268</span><br></pre></td></tr></table></figure></p><p>我们验证一下结果，验证了计算机确实是以补码的方式储存数字。这里有个小问题，就是我们知道<code>int</code>型有<code>4</code>个字节即<code>32</code>个比特，但是28却输出了<code>11100</code>5个比特而已，是因为<code>toBinaryString()</code>方法把<code>11100</code>前面的<code>0</code>给忽略了。<br>取出的时候，我们以无符号的标准去处理，导致取出存入的<code>-28</code>结果是<code>4294967268</code>和我们存入的不一样，这是因为<code>-28</code>是负数，负数的补码和原码不一样，而用无符号处理的话就是直接将<code>11111111111111111111111111100100</code>转成结果了。而为什么<code>28</code>用有无符号处理结果都一样是因为正数的原码和补码一样，这样验证了Java的数据类型都是有符号的。   </p><p><strong>至于计算机为什么用补码来储存数字，而不是原码，原因是：</strong><br>拿单字节整数来说，无符号型，其表示范围是[0,255]，总共表示了<code>256</code>个数据。有符号型，其表示范围是[-128,127]。<br>先看无符号，原码和补码都一样，<code>0</code>表示为<code>0000 0000</code>，<code>255</code>表示为<code>1111 1111</code>，刚好满足了要求，可以表示<code>256</code>个数据。<br>再看有符号的，若是用<strong>原码</strong>表示，<code>0</code>表示为<code>0000 000</code>。因为咱们有符号，所以应该也有个<strong>负0</strong>（虽然它还是0）<code>1000 0000</code>。这样的话那就有2个0，也就是只能表示<code>255</code>个数据，不能够满足我们的要求。而用补码则很好的解决了这个问题。    </p><h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><p>在计算机中，对<strong>非数值</strong>的字符进行处理时，要对字符进行数字化，即用二进制编码来表示字符。其中西文字符最常用到的编码方案有ASCII编码和EBCDIC编码。对于汉字，我国也制定的相应的编码方案，比如 GBK，GB2312等。<br>比如字符<code>a</code>的<code>ASCII</code>码十进制值为<code>97</code>，在计算机中用二进制表示就是 01100001。下面同样用Java来演示计算机是如何储存字符的。  </p><ol><li>采用UTF-8和GBK两种编码储存汉字</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) throws NoSuchAlgorithmException &#123;</span><br><span class="line">        String a1 = &quot;中&quot;;</span><br><span class="line">//        采用两种不同的编码储存&quot;中&quot;这个汉字 比较两种编码</span><br><span class="line">        byte[] b1 = a1.getBytes(&quot;GBK&quot;);</span><br><span class="line">        byte[] b2 = a1.getBytes(&quot;UTF-8&quot;);</span><br><span class="line">        String c1 = binary(b1,2);</span><br><span class="line">        String c2= binary(b2,2);</span><br><span class="line">        System.out.println(&quot;GBK储存对应的二进制：&quot; + c1);</span><br><span class="line">        System.out.println(&quot;UTF-8储存对应的二进制：&quot; +c2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 将byte[]转为各种进制的字符串</span><br><span class="line">     * @param bytes byte[]</span><br><span class="line">     * @param radix 基数可以转换进制的范围，从Character.MIN_RADIX到Character.MAX_RADIX，超出范围后变为10进制</span><br><span class="line">     * @return 转换后的字符串</span><br><span class="line">     */</span><br><span class="line">    public static String binary(byte[] bytes, int radix)&#123;</span><br><span class="line">        return new BigInteger(1, bytes).toString(radix);// 这里的1代表正数</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ws4.sinaimg.cn/large/e0e01e43gy1g08enhtsx1j213s0jjtby.jpg" alt="image"><br>我们调试看看，发现GBK编码采用<code>2</code>个字节储存，储存的数据分别是<code>10</code>进制的<code>-42</code>和<code>-48</code>对应的二进制分别是<code>11010110</code>和<code>11010000</code>(补码)，即汉字<code>中</code>对应的二进制为<code>1101011011010000</code>，即16进制的<code>D6D0</code>，查看GBK对照表，发现16进制编码<code>D6D0</code>对应的汉字确实是<code>中</code><br><img src="http://wx4.sinaimg.cn/large/e0e01e43gy1g08f28qjz1j214b0gbgni.jpg" alt="image"></p><p>而UTF-8编码采用<code>3</code>个字节储存，同理将对应的二进制<code>111001001011100010101101</code>转成16进制，为E4B8AD，通过UTF-8编码查询，发现汉字<code>中</code>对应的16进制编码确实是<code>E4B8AD</code><br><img src="http://wx2.sinaimg.cn/large/e0e01e43gy1g08f7puifrj21910af3z7.jpg" alt="image"></p><ol start="2"><li>储存字符</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) throws NoSuchAlgorithmException &#123;</span><br><span class="line">        String a1 = &quot;EF&quot;;</span><br><span class="line">//        将字符串转成字节数组</span><br><span class="line">        byte[] b1 = a1.getBytes();</span><br><span class="line">        String c1 = binary(b1,2);</span><br><span class="line">        System.out.println(&quot;对应的二进制：&quot; + c1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 将byte[]转为各种进制的字符串</span><br><span class="line">     * @param bytes byte[]</span><br><span class="line">     * @param radix 基数可以转换进制的范围，从Character.MIN_RADIX到Character.MAX_RADIX，超出范围后变为10进制</span><br><span class="line">     * @return 转换后的字符串</span><br><span class="line">     */</span><br><span class="line">    public static String binary(byte[] bytes, int radix)&#123;</span><br><span class="line">        return new BigInteger(1, bytes).toString(radix);// 这里的1代表正数</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ws2.sinaimg.cn/large/e0e01e43gy1g08fxhd6efj214r0i3tau.jpg" alt="image"><br>调试看看，字符串<code>EF</code>有<code>E</code>和<code>F</code>两个字符，它们对应的十进制ASCII码分别是<code>69</code>和<code>70</code><br><img src="http://ws2.sinaimg.cn/large/e0e01e43gy1g08g0ta24uj20fq0c10tg.jpg" alt="image"></p><p>我们发现Java的<code>getBytes()</code>方法是将字符串的每一个字符都储存到一个字节的，如果我们想把<code>EF</code>储存在一个字节里面，即<code>EF</code>是一个整体的，一个字节，不能拆分，那我们可以把<code>EF</code>放在一个字节里面<code>(byte)(0xEF)</code>，声明它是一个字节，不是字符，不用再将它转成字符对应的编码。<br>下面说说我在进行<code>MD5</code>消息摘要算法时候遇到的坑，我要对QQ号对应的Hex进行<code>MD5</code>算法散列，这里我举例QQ号的<code>10</code>进制为<code>12345678</code>，对应的<code>16</code>进制为<code>00BC614E</code>(因为QQ号固定长度4个字节，所以前面补了2个0)，一开始我是以下面的方式进行<code>MD5</code>算法的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) throws NoSuchAlgorithmException &#123;</span><br><span class="line">        String qq = &quot;00BC614E&quot;;</span><br><span class="line">//        将字符串转成字节数组</span><br><span class="line">        byte[] b1 = qq.getBytes();</span><br><span class="line"></span><br><span class="line">        MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);</span><br><span class="line">        md.update(b1);</span><br><span class="line">//        得到MD5后的哈希值</span><br><span class="line">        byte[] hash = md.digest();</span><br><span class="line">//        将结构转成16进制</span><br><span class="line">        String c1 = binary(hash,16);</span><br><span class="line">        System.out.println(&quot;对应的16进制：&quot; + c1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 将byte[]转为各种进制的字符串</span><br><span class="line">     * @param bytes byte[]</span><br><span class="line">     * @param radix 基数可以转换进制的范围，从Character.MIN_RADIX到Character.MAX_RADIX，超出范围后变为10进制</span><br><span class="line">     * @return 转换后的字符串</span><br><span class="line">     */</span><br><span class="line">    public static String binary(byte[] bytes, int radix)&#123;</span><br><span class="line">        return new BigInteger(1, bytes).toString(radix);// 这里的1代表正数</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://ws4.sinaimg.cn/large/e0e01e43gy1g08izqbof9j213w0npjva.jpg" alt="image"><br>调试可以看到上面的代码其实是将字符串<code>00BC614E</code>转成了<code>8</code>个字节，然后再对这8个字节进行散列，这也是基于<strong>字符串</strong>进行的<code>MD5</code>散列，和通过网上一些网站散列得到的值是一样的<br><img src="http://wx3.sinaimg.cn/large/e0e01e43gy1g08j73hvayj21g40jgn3x.jpg" alt="image"></p><p>但是这个哈希值和预想的结果不一致，后来才知道预想的结果是基于<strong>字节</strong>进行的<code>MD5</code>散列，也就是<code>00BC614E</code>应该分成<code>4</code>个字节（00、BC、61、4E）而不是<code>8</code>个字节（0、0、B、C、6、1、4、E），然后通过修改代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) throws NoSuchAlgorithmException &#123;</span><br><span class="line">//        String qq = &quot;00BC614E&quot;;</span><br><span class="line">//        将字符串转成字节数组</span><br><span class="line">//        byte[] b1 = qq.getBytes();</span><br><span class="line">        byte[] b1 = &#123;(byte)(0x00),(byte)(0xBC),(byte)(0x61),(byte)(0x4E)&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);</span><br><span class="line">        md.update(b1);</span><br><span class="line">//        得到MD5后的哈希值</span><br><span class="line">        byte[] hash = md.digest();</span><br><span class="line">//        将结构转成16进制</span><br><span class="line">        String c1 = binary(hash,16);</span><br><span class="line">        System.out.println(&quot;对应的16进制：&quot; + c1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 将byte[]转为各种进制的字符串</span><br><span class="line">     * @param bytes byte[]</span><br><span class="line">     * @param radix 基数可以转换进制的范围，从Character.MIN_RADIX到Character.MAX_RADIX，超出范围后变为10进制</span><br><span class="line">     * @return 转换后的字符串</span><br><span class="line">     */</span><br><span class="line">    public static String binary(byte[] bytes, int radix)&#123;</span><br><span class="line">        return new BigInteger(1, bytes).toString(radix);// 这里的1代表正数</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://ws1.sinaimg.cn/large/e0e01e43gy1g08jiea66vj213d0njadu.jpg" alt="image"><br>使用<code>(byte)</code>声明是一个字节，不是字符，不用再将它转成字符对应的编码。00、BC、61、4E分别是一个字节，当然因为字节为<code>8</code>个比特，能表示256个数字，因为Java的数据类型是有符号的，所以<code>8</code>个比特能表示的<code>10</code>进制范围是[-128,127]，所以(byte)(x) x不能小于<code>-128</code>和不能大于<code>127</code>，否则会溢出，溢出的部分数据会丢失。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ws3.sinaimg.cn/large/e0e01e43gy1g08660xgavj20sg0lc43a.jpg&quot; alt=&quot;image&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在学习中涉及到计算机储存、传输数字和字符等操作，由于对字节、&lt;code&gt;2&lt;/code&gt;进制、&lt;code&gt;10&lt;/code&gt;进制、&lt;code&gt;16&lt;/code&gt;进制、ASCII码的概念以及它们之间的关系和转换理解的不够透彻，导致在通讯、&lt;code&gt;MD5&lt;/code&gt;消息摘要算法等时候出现问题，是因为&lt;strong&gt;数据&lt;/strong&gt;转成&lt;strong&gt;计算机认识的01&lt;/strong&gt;的这个环节出现问题。由于这个问题并不是那么容易发现，所以我也算是花了挺多时间才解决了这个问题，记录下解决过程，顺便也当复习一下计算机组成原理。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="http://ddnd.cn/categories/Computer-Foundation/"/>
    
    
  </entry>
  
  <entry>
    <title>第三章 Redis 客户端的使用 Java版【Redis入门教程】</title>
    <link href="http://ddnd.cn/2019/02/15/redis-chapter-3/"/>
    <id>http://ddnd.cn/2019/02/15/redis-chapter-3/</id>
    <published>2019-02-15T04:35:11.000Z</published>
    <updated>2019-03-12T10:14:44.545Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ws1.sinaimg.cn/large/e0e01e43gy1fzz559f0n2j21d80gf3zh.jpg" alt="image" width="100%"></p><p><strong>Redis入门教程目录</strong>：<a href="https://ddnd.cn/categories/Redis/">【Redis入门教程目录】</a><br><a id="more"></a></p><h2 id="Redis客户端"><a href="#Redis客户端" class="headerlink" title="Redis客户端"></a>Redis客户端</h2><p>我们知道Redis是<code>C</code>语言开发的，如果想用别的语言操作Redis，那就需要用到别的语言的客户端。我们前面介绍过Redis的其中一个特性就是客户端多，几乎所有语言都有Redis的客户端，比如<code>Java</code>语言的<code>Jedis</code>；<code>Python</code>语言的<code>redis-py</code>；<code>PHP</code>语言的<code>Predis</code>；<code>Go</code>语言的<code>Redigo</code>等等。这些客户端也都是遵循了Redis给的协议，然后按照协议去开发出对应语言的客户端。如Redis官方提供的<code>redis-cli</code>客户端其实就是一个Shell客户端<br><img src="http://ws2.sinaimg.cn/large/e0e01e43gy1g070fepeo1j20vm0ccgqg.jpg" alt="image">  </p><h2 id="Jedis的使用"><a href="#Jedis的使用" class="headerlink" title="Jedis的使用"></a>Jedis的使用</h2><p>本篇我就讲<code>Java</code>语言的客户端<code>Jedis</code>，使用其他语言的读者可以阅读相关客户端的文档。要使用Jedis，首先确保我们已经添加了Jedis的依赖，这里我使用Maven配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.0.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><h3 id="Jedis的直连"><a href="#Jedis的直连" class="headerlink" title="Jedis的直连"></a>Jedis的直连</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line"> </span><br><span class="line">public class RedisJava &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //连接本地的 Redis 服务</span><br><span class="line">        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;,6379);</span><br><span class="line">        jedis.set(&quot;name&quot;, &quot;redis&quot;);</span><br><span class="line">        System.out.println(&quot;redis 存储的字符串为: &quot;+ jedis.get(&quot;name&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上Java程序，输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 存储的字符串为: redis</span><br></pre></td></tr></table></figure></p><h3 id="Jedis的连接池"><a href="#Jedis的连接池" class="headerlink" title="Jedis的连接池"></a>Jedis的连接池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line"> </span><br><span class="line">public class RedisPool &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //初始化连接池</span><br><span class="line">        JedisPoolConfig config=new JedisPoolConfig();</span><br><span class="line">        JedisPool jedisPool=new JedisPool(config,&quot;127.0.0.1&quot;,6379);</span><br><span class="line">        </span><br><span class="line">        Jedis jedis=null;</span><br><span class="line">        try&#123;</span><br><span class="line">            jedis=jedisPool.getResource(); // 获取连接</span><br><span class="line">            jedis.set(&quot;name&quot;, &quot;redis&quot;); // 设置值</span><br><span class="line">            String value=jedis.get(&quot;name&quot;); // 获取值</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            if(jedis!=null)&#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">            if(jedisPool!=null)&#123;</span><br><span class="line">                jedisPool.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上Java程序，输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis</span><br></pre></td></tr></table></figure></p><h2 id="Spring-data-redis的使用"><a href="#Spring-data-redis的使用" class="headerlink" title="Spring-data-redis的使用"></a>Spring-data-redis的使用</h2><p>前面我们使用了<code>Jedis</code>实现对Redis的操作，这里再介绍使用基于Spring的<code>Spring-data-redis</code>操作Redis，<code>Spring</code>就不用我过多介绍了，相信学Java的都认识它。<br><strong>Jedis与Spring-data-redis的区别和关系：</strong>  </p><ul><li>Jedis：Jedis是Redis的Java客户端，通过它可以对Redis进行操作，与之功能相似的还包括Lettuce等。</li><li>Spring-data-redis：Spring-data-redis对Redis的操作依赖Jedis或Lettuce，实际上是对Jedis、Lettuce这些客户端的封装，提供一套与客户端无关的api供应用使用，从而你在从一个redis客户端切换为另一个客户端，不需要修改业务代码。  </li></ul><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>在使用<code>Spring-data-redis</code>前首先确保我们已经添加了相关依赖，这里我使用Maven配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-web --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context-support --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--MySQL连接驱动--&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;8.0.13&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.0.1&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Redis客户端jedis依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- spring-data-redis依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.5.0.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><h3 id="Spring和Spring-data-redis整合"><a href="#Spring和Spring-data-redis整合" class="headerlink" title="Spring和Spring-data-redis整合"></a>Spring和Spring-data-redis整合</h3><p>通过<code>XML</code>配置文件将<code>Spring-data-redis</code>的<strong>连接池</strong>、<strong>Redis模板</strong>注入到Spring容器中。Redis模板有<code>2</code>个，分别是<code>RedisTemplate</code>、<code>StringRedisTemplate</code>，这两个模板的区别是采用的序列化策略不一样，前者采用的是Java<strong>原生的序列化</strong>后者采用的是<strong>String序列化</strong>。模板的好处是为Redis的交互提供了高级抽象，用户无需关注Redis的连接管理、序列化等问题，把更多注意力放在业务上。<br><strong>redis.properties：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#ip地址</span><br><span class="line">redis.host.ip=192.168.174.129</span><br><span class="line">#端口号</span><br><span class="line">redis.port=6379</span><br><span class="line">#如果有密码</span><br><span class="line">redis.password=</span><br><span class="line">#客户端超时时间单位是毫秒 默认是2000</span><br><span class="line">redis.timeout=3000</span><br><span class="line"></span><br><span class="line">#最大空闲数</span><br><span class="line">redis.maxIdle=6</span><br><span class="line">#连接池的最大数据库连接数。设为0表示无限制,如果是jedis 2.4以后用redis.maxTotal</span><br><span class="line">#redis.maxActive=600maxIdle</span><br><span class="line">#控制一个pool可分配多少个jedis实例,用来替换上面的redis.maxActive,如果是jedis 2.4以后用该属性</span><br><span class="line">redis.maxTotal=20</span><br><span class="line">#最大建立连接等待时间。如果超过此时间将接到异常。设为-1表示无限制。</span><br><span class="line">redis.maxWaitMillis=3000</span><br><span class="line">#连接的最小空闲时间 默认1800000毫秒(30分钟)</span><br><span class="line">redis.minEvictableIdleTimeMillis=300000</span><br><span class="line">#每次释放连接的最大数目,默认3</span><br><span class="line">redis.numTestsPerEvictionRun=4</span><br><span class="line">#逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1</span><br><span class="line">redis.timeBetweenEvictionRunsMillis=30000</span><br></pre></td></tr></table></figure></p><p><strong>spring-redis.xml：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--加载配置文件--&gt;</span><br><span class="line">&lt;bean:property-placeholder location=&quot;classpath:redis.properties&quot; ignore-unresolvable=&quot;true&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--redis连接池配置--&gt;</span><br><span class="line">&lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;</span><br><span class="line">    &lt;!--最大空闲数 --&gt;</span><br><span class="line">    &lt;property name=&quot;maxIdle&quot; value=&quot;$&#123;redis.maxIdle&#125;&quot; /&gt;</span><br><span class="line">    &lt;!--连接池的最大数据库连接数 --&gt;</span><br><span class="line">    &lt;property name=&quot;maxTotal&quot; value=&quot;$&#123;redis.maxTotal&#125;&quot; /&gt;</span><br><span class="line">    &lt;!--最大建立连接等待时间 --&gt;</span><br><span class="line">    &lt;property name=&quot;maxWaitMillis&quot; value=&quot;$&#123;redis.maxWaitMillis&#125;&quot; /&gt;</span><br><span class="line">    &lt;!--逐出连接的最小空闲时间 默认1800000毫秒(30分钟) --&gt;</span><br><span class="line">    &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;$&#123;redis.minEvictableIdleTimeMillis&#125;&quot; /&gt;</span><br><span class="line">    &lt;!--每次逐出检查时 逐出的最大数目 如果为负数就是 : 1/abs(n), 默认3 --&gt;</span><br><span class="line">    &lt;property name=&quot;numTestsPerEvictionRun&quot; value=&quot;$&#123;redis.numTestsPerEvictionRun&#125;&quot; /&gt;</span><br><span class="line">    &lt;!--逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1 --&gt;</span><br><span class="line">    &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;$&#123;redis.timeBetweenEvictionRunsMillis&#125;&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--redis连接工厂--&gt;</span><br><span class="line">&lt;bean id=&quot;connectionFactory&quot; class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;&gt;</span><br><span class="line">    &lt;!--连接池配置--&gt;</span><br><span class="line">    &lt;property name=&quot;poolConfig&quot; ref=&quot;jedisPoolConfig&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--redis地址--&gt;</span><br><span class="line">    &lt;property name=&quot;hostName&quot; value=&quot;$&#123;redis.host.ip&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--redis密码--&gt;</span><br><span class="line">    &lt;!--&lt;property name=&quot;password&quot; value=&quot;$&#123;redis.password&#125;&quot;&gt;&lt;/property&gt;--&gt;</span><br><span class="line">    &lt;!--redis端口--&gt;</span><br><span class="line">    &lt;property name=&quot;port&quot; value=&quot;$&#123;redis.port&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--超时时间 毫秒--&gt;</span><br><span class="line">    &lt;property name=&quot;timeout&quot; value=&quot;$&#123;redis.timeout&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 注入redis操作模板为Bean  自动装配--&gt;</span><br><span class="line">&lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.RedisTemplate&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot; /&gt;</span><br><span class="line">    &lt;!-- 指定redis中key-value的序列化方式（此处省略） --&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 注入redis操作模板为Bean  自动装配--&gt;</span><br><span class="line">&lt;bean id=&quot;stringRedisTemplate&quot; class=&quot;org.springframework.data.redis.core.StringRedisTemplate&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>将<code>Spring</code>和<code>Spring-data-redis</code>整合完成之后，一般为了方便使用模板，我们会将模板进一步封装成自己的Dao工具类，这里我仅封装几个操作，如下<br><strong>RedisDaoImpl.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public class RedisDaoImpl implements RedisDao &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    public void setString(Object redisKey, Object redisValue) &#123;</span><br><span class="line">        ValueOperations valueOperations = stringRedisTemplate.opsForValue();</span><br><span class="line">        valueOperations.set(redisKey, redisValue);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getString(Object redisKey) &#123;</span><br><span class="line">        ValueOperations valueOperations = stringRedisTemplate.opsForValue();</span><br><span class="line">        return valueOperations.get(redisKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @description: 通过redisKey 批量(map)设置redisValue(hash)</span><br><span class="line">     * @param: [redisKey, redisValue]</span><br><span class="line">     * @return: void</span><br><span class="line">     * @author: Xue 8</span><br><span class="line">     * @date: 2019/2/14</span><br><span class="line">     */</span><br><span class="line">    public void setHashAll(Object redisKey, Map&lt;String,Object&gt; redisValue)&#123;</span><br><span class="line">        HashOperations hashOperations = stringRedisTemplate.opsForHash();</span><br><span class="line">        hashOperations.putAll(redisKey, redisValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @description: 通过redisKey、hashKey、hashValue设置单个redisValue(hash)</span><br><span class="line">     * @param: [redisKey, hashKey, hashValue]</span><br><span class="line">     * @return: void</span><br><span class="line">     * @author: Xue 8</span><br><span class="line">     * @date: 2019/2/14</span><br><span class="line">     */</span><br><span class="line">    public void setHash(Object redisKey, Object hashKey, Object hashValue)&#123;</span><br><span class="line">        HashOperations hashOperations = stringRedisTemplate.opsForHash();</span><br><span class="line">        hashOperations.put(redisKey, hashKey, hashValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @description: 通过redisValue、hashKey获取hashValue</span><br><span class="line">     * @param: [redisKey, hashKey]</span><br><span class="line">     * @return: java.lang.Object</span><br><span class="line">     * @author: Xue 8</span><br><span class="line">     * @date: 2019/2/14</span><br><span class="line">     */</span><br><span class="line">    public Object getHashValue(Object redisKey, Object hashKey)&#123;</span><br><span class="line">        HashOperations hashOperations = stringRedisTemplate.opsForHash();</span><br><span class="line">        return hashOperations.get(redisKey, hashKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @description: 通过redisKey获取hash</span><br><span class="line">     * @param: [redisKey]</span><br><span class="line">     * @return: java.util.Map&lt;java.lang.String,java.lang.Object&gt;</span><br><span class="line">     * @author: Xue 8</span><br><span class="line">     * @date: 2019/2/14</span><br><span class="line">     */</span><br><span class="line">    public Map&lt;String,Object&gt; getHash(Object redisKey)&#123;</span><br><span class="line">        HashOperations hashOperations = stringRedisTemplate.opsForHash();</span><br><span class="line">        return hashOperations.entries(redisKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @description: 通过redisKey设置redisValue(List)</span><br><span class="line">     * @param: [redisKey, redisValue]</span><br><span class="line">     * @return: void</span><br><span class="line">     * @author: Xue 8</span><br><span class="line">     * @date: 2019/2/14</span><br><span class="line">     */</span><br><span class="line">    public void setList(Object redisKey, List&lt;Object&gt; redisValue)&#123;</span><br><span class="line">        ListOperations listOperations = stringRedisTemplate.opsForList();</span><br><span class="line">        listOperations.leftPushAll(redisKey, redisValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之后在需要操作到Redis的地方，直接调用RedisDaoImpl即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ws1.sinaimg.cn/large/e0e01e43gy1fzz559f0n2j21d80gf3zh.jpg&quot; alt=&quot;image&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Redis入门教程目录&lt;/strong&gt;：&lt;a href=&quot;https://ddnd.cn/categories/Redis/&quot;&gt;【Redis入门教程目录】&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://ddnd.cn/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>第二章 Redis API的使用 单线程介绍【Redis入门教程】</title>
    <link href="http://ddnd.cn/2019/02/13/redis-chapter-2/"/>
    <id>http://ddnd.cn/2019/02/13/redis-chapter-2/</id>
    <published>2019-02-13T10:12:33.000Z</published>
    <updated>2019-03-12T10:14:40.485Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ws1.sinaimg.cn/large/e0e01e43gy1fzz559f0n2j21d80gf3zh.jpg" alt="image" width="100%"></p><p><strong>Redis入门教程目录</strong>：<a href="https://ddnd.cn/categories/Redis/">【Redis入门教程目录】</a><br><a id="more"></a></p><h2 id="数据结构和内部编码"><a href="#数据结构和内部编码" class="headerlink" title="数据结构和内部编码"></a>数据结构和内部编码</h2><p>通过这部分让大家对Redis的五种数据结构有初步的认识，对于Redis来说，每一种数据结构都有着自己的内部编码，而且是多种实现的，这样Redis会在合适的场景选择合适的内部编码，通过<code>OBJECT ENCODING [key]</code>可以参看指定<code>key</code>的内部编码。<br><strong>这样做的好处：</strong><br>a. 改进内部编码，对外的数据结构和命令没有影响，对用户提供黑箱模型。<br>b. 多种内部编码可在不同场景下发挥各自的优势。如：<code>ziplist</code>比较节约内存，但是元素比较多的时候，性能会有所下降，此时Redis会将编码自动转换为<code>linkedlist</code>，性能会有所改善。<br><img src="http://wx3.sinaimg.cn/large/e0e01e43gy1g040kix74jj20q00lqwmc.jpg" alt="image"></p><h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p>了解Redis的单线程架构，有助于大家对Redis的进一步学习和排解问题。<br><img src="http://ws2.sinaimg.cn/large/e0e01e43gy1g0431ewwgbj216g0k479d.jpg" alt="image"><br>Redis处理网络请时候的求单线程可以抽象成这样，通向Redis的路只有一条，且这条路是个单车道，只容的下一辆车同时使用，而我们使用的Redis命令即为这些车辆，当我们执行多个命令的时候，只有等第一个命令执行完成了后面的命令才会执行，否则会一直处于等待状态。<br><img src="http://ws3.sinaimg.cn/large/e0e01e43gy1g00j4nk245j21b40ecq6e.jpg" alt="image"><br>Redis单线程的架构需要我们注意几点<br>a. 一次只运行一条命令<br>b. 拒绝长（慢）命令（keys、flushall、flushdb、slow lua script、mutil/exec、operate、big value）<br>至于为什么单线程还这么快，这里有个原因，Redis客户端的到Redis服务器的网络请求采用了<strong>多路I/O复用模型（非阻塞I/O）</strong>，利用<code>select</code>、<code>poll</code>、<code>epoll</code>可以<strong>同时监听多个流的I/O(客户端到服务器的网络请求)事件的能力</strong>，在空闲的时候，会把当前线程阻塞掉，当有一个或者多个流有<code>I/O</code>事件时，就从阻塞态中唤醒，<strong>轮训一遍所有的流</strong>并且依次处理就绪的流。这样就算出现有的流的<code>I/O</code>因为网络原因很慢，也不会影响别的流的<code>I/O</code>（非阻塞），因为是轮训所有的流的<code>I/O</code>。这里的“多路”指的是多个网络连接，“复用”指的是复用同一个线程。<br><img src="https://upload-images.jianshu.io/upload_images/8753960-fb5c8f0a4f37d3f7.gif?imageMogr2/auto-orient/"></p><h2 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h2><p>Redis一些通用命令，比如删除一个键、计算数据库的大小、设置键的过期时间等，这些命令有很多，这里主要介绍<code>7</code>个，完整的命令大家可以参考官方文档。<br>1.KEYS [pattern]<br>时间复杂度为<strong>O(N)</strong>，<code>N</code>为数据库中<code>Key</code>的数量。 这个命令由于时间复杂度为O(N)所以一般生产环境不使用，如果需要遍历全部数据，可以使用Scan命令，时间复杂度为O(1)。<br>查找所有符合给定模式<code>pattern</code>的<code>key</code>，比如说：    </p><ul><li><code>KEYS *</code>匹配数据库中所有的<code>key</code>。  </li><li><code>KEYS h?llo</code>匹配<code>hello</code>、<code>hallo</code>等<code>key</code>。  </li><li><code>KEYS h*llo</code>匹配<code>hllo</code>和<code>haaaaaallo</code>等<code>key</code>。  </li><li><code>KEYS h[abe]llo</code>匹配<code>hallo</code>、<code>hbllo</code>和<code>hello</code>。<br><strong>返回值：</strong> 符合给定模式的<code>key</code>列表。     </li></ul><p>2.DBSIZE<br>时间复杂度为<strong>O(1)</strong>，计算的时候不是扫描整个表，因为Redis有个计数器，实时更新Key总数。<br>查找返回当前数据库的<code>key</code>的数量。<br><strong>返回值：</strong> 返回当前数据库的<code>key</code>的数量。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DBSIZE</span><br><span class="line">(integer) 5</span><br><span class="line"></span><br><span class="line">redis&gt; SET new_key &quot;hello_moto&quot;     #增加一个 key 试试</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DBSIZE</span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure></p><p>3.EXISTS key<br>时间复杂度为<strong>O(1)</strong>。<br>检查给定<code>key</code>是否存在。<br><strong>返回值：</strong> 若<code>key</code>存在，返回<code>1</code>，不存在返回<code>0</code>。  </p><p>4.DEL key [key …]<br>时间复杂度为<strong>O(N)</strong>，<code>N</code>为被删除的<code>key</code>的数量，其中删除单个字符串类型的<code>key</code>，时间复杂度为<code>O(1)</code>；删除单个列表、集合、有序集合或哈希表类型的<code>key</code>，时间复杂度为<code>O(M)</code>，<code>M</code>为以上数据结构内的元素数量。<br>删除指定的一个或者多个<code>key</code>，不存在的<code>key</code>会被忽略。<br><strong>返回值：</strong> 被删除的<code>key</code>的数量。   </p><p>5.EXPIRE key seconds<br>时间复杂度为<strong>O(1)</strong>。<br>为给定的<code>key</code>设置生存时间，当<code>key</code>过期时，它会被自动<strong>删除</strong>。<br><strong>返回值：</strong> 设置成功返回<code>1</code>，当<code>key</code>不存在或者设置失败的时候返回<code>0</code>。    </p><p>6.PERSIST key<br>时间复杂度为<strong>O(1)</strong>。<br>移除给定<code>key</code>的生存时间，将这个<code>key</code>转换成持久的。<br><strong>返回值：</strong> 当生存时间移除成功时，返回<code>1</code>，如果<code>key</code>不存在或者没有设置生存时间，返回<code>0</code>。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey &quot;Hello&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; EXPIRE mykey 10  #为 key 设置生存时间</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL mykey</span><br><span class="line">(integer) 10</span><br><span class="line"></span><br><span class="line">redis&gt; PERSIST mykey    #移除 key 的生存时间</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL mykey</span><br><span class="line">(integer) -1</span><br></pre></td></tr></table></figure></p><p>7.TTL key<br>时间复杂度<strong>O(1)</strong>。<br>以秒为单位，返回给定<code>key</code>的剩余生存时间（TTL，time to live）。<br><strong>返回值：</strong> 当<code>key</code>不存在时，返回<code>-2</code>，当<code>key</code>存在但是没有设置生存时间时，返回<code>-1</code>，否则返回<code>key</code>的剩余生存时间。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 不存在的 key</span><br><span class="line"></span><br><span class="line">redis&gt; FLUSHDB</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; TTL key</span><br><span class="line">(integer) -2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#key 存在，但没有设置剩余生存时间</span><br><span class="line"></span><br><span class="line">redis&gt; SET key value</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; TTL key</span><br><span class="line">(integer) -1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#有剩余生存时间的 key</span><br><span class="line"></span><br><span class="line">redis&gt; EXPIRE key 10086</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL key</span><br><span class="line">(integer) 10084</span><br></pre></td></tr></table></figure></p><h2 id="五种数据结构"><a href="#五种数据结构" class="headerlink" title="五种数据结构"></a>五种数据结构</h2><p>这里介绍Redis的五种数据结构String（字符串）、Hash（哈希）、List（列表）、Set（集合）、Zset（即Sorted Set有序集合）的结构和一些命令。  </p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串是Redis中最基础的数据结构。</p><h4 id="键值结构"><a href="#键值结构" class="headerlink" title="键值结构"></a>键值结构</h4><p>字符串的值虽然是字符串但是可以保存很多种类型的数据，如：简单的字符串、JSON、XML、数字、二进制等。需要注意一点的是，Redis中字符串类型的值最大能保存512MB。<br><img src="http://ws1.sinaimg.cn/large/e0e01e43gy1g043ib11xqj20fa096mxd.jpg" alt="image"></p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>1.SET key value [EX seconds] [PX milliseconds] [NX|XX]<br>时间复杂度<strong>O(1)</strong>。<br>将字符串值<code>value</code>关联到<code>key</code>，如果<code>key</code>已经持有其他值，<code>SET</code>就覆写旧值，无视类型，当<code>SET</code>命令对一个带有生存时间（TTL）的键进行设置之后，该键原有的TTL将被清除。<br><strong>可选参数：</strong></p><ul><li><code>EX seconds</code>：将键的过期时间设置为<code>seconds</code>秒。 执行<code>SET key value EX seconds</code>的效果等同于执行<code>SETEX key seconds value</code>。       </li><li><code>PX milliseconds</code>：将键的过期时间设置为<code>milliseconds</code>毫秒。执行<code>SET key value PX milliseconds</code>的效果等同于执行<code>PSETEX key milliseconds value</code>。     </li><li><code>NX</code>：只在键不存在时，才对键进行设置操作。执行<code>SET key value NX</code>的效果等同于执行<code>SETNX key value</code>。   </li><li><code>XX</code>：只在键已经存在时，才对键进行设置操作。   <blockquote><p>因为<code>SET</code>命令可以通过参数来实现<code>SETNX</code>、<code>SETEX</code>以及<code>PSETEX</code>命令的效果，所以<code>Redis</code>将来的版本可能会移除并废弃<code>SETNX</code>、<code>SETEX</code>和<code>PSETEX</code>这三个命令。</p></blockquote></li></ul><p><strong>返回值：</strong><br>在Redis 2.6.12版本以前，<code>SET</code>命令总是返回<code>OK</code>。<br>从Redis 2.6.12版本开始，<code>SET</code>命令只在设置操作成功完成时才返回<code>OK</code>；如果命令使用了<code>NX</code>或者<code>XX</code>选项， 但是因为条件没达到而造成设置操作未执行， 那么命令将返回空批量回复（NULL Bulk Reply）。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#使用 EX 选项</span><br><span class="line">redis&gt; SET key-with-expire-time &quot;hello&quot; EX 10086</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET key-with-expire-time</span><br><span class="line">&quot;hello&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; TTL key-with-expire-time</span><br><span class="line">(integer) 10069</span><br></pre></td></tr></table></figure></p><p>2.GET key<br>时间复杂度<strong>O(1)</strong>。<br>获取与键<code>key</code>相关联的字符串值。<br><strong>返回值：</strong><br>如果键<code>key</code>不存在，那么返回特殊值<code>nil</code>；否则，返回键<code>key</code>的值。<br>如果键<code>key</code>的值并非字符串类型，那么返回一个错误，因为<code>GET</code>命令只能用于字符串值。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GET db</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">redis&gt; SET db redis</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET db</span><br><span class="line">&quot;redis&quot;</span><br></pre></td></tr></table></figure></p><p>3.DEL key [key …]<br>时间复杂度为<strong>O(N)</strong>，<code>N</code>为被删除的<code>key</code>的数量，其中删除单个字符串类型的<code>key</code>，时间复杂度为<code>O(1)</code>；删除单个列表、集合、有序集合或哈希表类型的<code>key</code>，时间复杂度为<code>O(M)</code>，<code>M</code>为以上数据结构内的元素数量。<br>删除指定的一个或者多个<code>key</code>，不存在的<code>key</code>会被忽略。<br><strong>返回值：</strong> 被删除的<code>key</code>的数量。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#同时删除多个 key</span><br><span class="line"></span><br><span class="line">redis&gt; SET name &quot;redis&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET type &quot;key-value store&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET website &quot;redis.com&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DEL name type website</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></p><p>4.MSET key value [key value …]<br>时间复杂度<strong>O(N)</strong>，其中<code>N</code>为被设置的键数量。<br>同时为多个键设置值。如果某个给定键已经存在，那么<code>MSET</code>将使用新值去覆盖旧值，如果这不是你所希望的效果，请考虑使用<code>MSETNX</code>命令，这个命令只会在所有给定键都不存在的情况下进行设置。<code>MSET</code>是一个<strong>原子性(atomic)</strong> 操作，所有给定键都会在同一时间内被设置，不会出现某些键被设置了但是另一些键没有被设置的情况。<br><strong>返回值：</strong> <code>MSET</code>命令总是返回<code>OK</code>。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MSET date &quot;2012.3.30&quot; time &quot;11:00 a.m.&quot; weather &quot;sunny&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MGET date time weather</span><br><span class="line">1) &quot;2012.3.30&quot;</span><br><span class="line">2) &quot;11:00 a.m.&quot;</span><br><span class="line">3) &quot;sunny&quot;</span><br></pre></td></tr></table></figure></p><p>5.MSETNX key value [key value …]<br>时间复杂度<strong>O(N)</strong>，其中<code>N</code>为被设置的键数量。<br>当且仅当所有给定键都<strong><em>不存在</em></strong>时,为所有给定键设置值。即使只有一个给定键已经存在，<code>MSETNX</code>命令也会拒绝执行对所有键的设置操作。<code>MSETNX</code>是一个<strong>原子性(atomic)</strong> 操作，所有给定键要么就全部都被设置，要么就全部都不设置，不可能出现第三种状态。<br><strong>返回值：</strong> 当所有给定键都设置成功时，命令返回<code>1</code>；如果因为某个给定键已经存在而导致设置未能成功执行，那么命令返回<code>0</code>。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MSETNX rmdbs &quot;MySQL&quot; nosql &quot;MongoDB&quot; key-value-store &quot;redis&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; MGET rmdbs nosql key-value-store</span><br><span class="line">1) &quot;MySQL&quot;</span><br><span class="line">2) &quot;MongoDB&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br></pre></td></tr></table></figure></p><p>6.MGET key [key …]<br>时间复杂度<strong>O(N)</strong>，其中<code>N</code>为给定键的数量。<br>返回给定的一个或多个字符串键的值。如果给定的字符串键里面，有某个键不存在，那么这个键的值将以特殊值<code>nil</code>表示。<br><strong>返回值：</strong> <code>MGET</code>命令将返回一个列表，列表中包含了所有给定键的值。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET redis redis.com</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET mongodb mongodb.org</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MGET redis mongodb</span><br><span class="line">1) &quot;redis.com&quot;</span><br><span class="line">2) &quot;mongodb.org&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; MGET redis mongodb mysql     #不存在的 mysql 返回 nil</span><br><span class="line">1) &quot;redis.com&quot;</span><br><span class="line">2) &quot;mongodb.org&quot;</span><br><span class="line">3) (nil)</span><br></pre></td></tr></table></figure></p><p>7.N次GET和一次MGET对比<br>总所周知，Redis采用的是客户端-服务器方式，即在一次round trip中，客户端发送一条命令，服务器解析命令并执行，然后向客户端返回结果，如果执行<code>N</code>条命令，就是<code>N</code>个请求<code>N</code>次执行<code>N</code>个返回<br><img src="http://wx4.sinaimg.cn/large/e0e01e43gy1g04rgjoxjwj211t0nmqcm.jpg" alt="image"><br>如果我们把<code>N</code>条命令都放在一个请求中，一次请求多个执行一个返回，那么就可以大大的降低网络时间的开销，这个也就是Redis的pipline<br><img src="http://ws3.sinaimg.cn/large/e0e01e43gy1g04rk1afstj214t0pstgn.jpg" alt="image"></p><p>8.N次SET和一次MSET对比<br>同7</p><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><p>Redis的哈希是键值对的集合，是字符串字段和字符串值之间的映射。</p><h4 id="键值结构-1"><a href="#键值结构-1" class="headerlink" title="键值结构"></a>键值结构</h4><p><code>Hash</code>数据结构即数据存储为<code>field</code>、<code>value</code>的格式存储<br><img src="http://wx2.sinaimg.cn/large/e0e01e43gy1g04saqqy8ij20x00bj41k.jpg" alt="image"><br>可以将<code>field</code>、<code>value</code>看成一对键值对结构<br><img src="http://wx1.sinaimg.cn/large/e0e01e43gy1g04s578nymj20um09uwer.jpg" alt="image"></p><h4 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h4><p>1.HSET key field value<br>时间复杂度<strong>O(1)</strong>。<br>将哈希表<code>key</code>中域<code>field</code>的值设置为<code>value</code>，如果给定的哈希表不存在，那么一个新的哈希表将被创建并执行<code>HSET</code>操作，如果域<code>field</code>已存在于哈希表中，那么它的旧值将被新值<code>value</code>覆盖。<br><strong>返回值：</strong> 当<code>HSET</code>命令在哈希表中新创建<code>field</code>域并成功为它设置值时,命令返回<code>1</code>；如果域<code>field</code>已经存在于哈希表，并且<code>HSET</code>命令成功使用新值覆盖了它的旧值，那么命令返回<code>0</code>。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET website google &quot;www.g.cn&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HGET website google</span><br><span class="line">&quot;www.g.cn&quot;</span><br></pre></td></tr></table></figure></p><p>2.HGET key field<br>时间复杂度<strong>O(1)</strong>。<br>返回哈希表中给定域的值。<br><strong>返回值：</strong> <code>HGET</code>命令在默认情况下返回给定域的值，如果给定域不存在于哈希表中，又或者给定的哈希表并不存在，那么命令返回<code>nil</code>。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET homepage redis redis.com</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HGET homepage redis</span><br><span class="line">&quot;redis.com&quot;</span><br></pre></td></tr></table></figure></p><p>3.HGETALL key<br>时间复杂度<strong>O(N)</strong>，<code>N</code>为哈希表的大小，谨慎用。<br>返回哈希表的所有的域和值，在返回值里，紧跟每个域(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。<br><strong>返回值：</strong> 以列表形式返回哈希表的域和域的值，若<code>key</code>不存在，返回空列表。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET people jack &quot;Jack Sparrow&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HSET people gump &quot;Forrest Gump&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HGETALL people</span><br><span class="line">1) &quot;jack&quot;          #域</span><br><span class="line">2) &quot;Jack Sparrow&quot;  #值</span><br><span class="line">3) &quot;gump&quot;</span><br><span class="line">4) &quot;Forrest Gump&quot;</span><br></pre></td></tr></table></figure></p><p>4.HDEL key field [field …]<br>时间复杂度<strong>O(N)</strong>，<code>N</code>为要删除的域的数量。<br>删除哈希表<code>key</code>中的一个或多个指定域，不存在的域将被忽略。<br><strong>返回值：</strong> 被成功移除的域的数量，不包括被忽略的域。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#测试数据</span><br><span class="line"></span><br><span class="line">redis&gt; HGETALL abbr</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;banana&quot;</span><br><span class="line">5) &quot;c&quot;</span><br><span class="line">6) &quot;cat&quot;</span><br><span class="line">7) &quot;d&quot;</span><br><span class="line">8) &quot;dog&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#删除单个域</span><br><span class="line"></span><br><span class="line">redis&gt; HDEL abbr a</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#删除不存在的域</span><br><span class="line"></span><br><span class="line">redis&gt; HDEL abbr not-exists-field</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#删除多个域</span><br><span class="line"></span><br><span class="line">redis&gt; HDEL abbr b c</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; HGETALL abbr</span><br><span class="line">1) &quot;d&quot;</span><br><span class="line">2) &quot;dog&quot;</span><br></pre></td></tr></table></figure></p><p>5.HMSET key field value [field value …]<br>时间复杂度<strong>O(N)</strong>，<code>N</code>为<code>field-value</code>对的数量。<br>同时将多个<code>field-value</code>(域-值)对设置到哈希表<code>key</code>中，此命令会覆盖哈希表中已存在的域，如果<code>key</code>不存在，一个空哈希表被创建并执行<code>HMSET</code>操作。<br><strong>返回值：</strong> 如果命令执行成功，返回<code>OK</code>，当<code>key</code>不是哈希表(hash)类型时，返回一个错误。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HMSET website google www.google.com yahoo www.yahoo.com</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; HGET website google</span><br><span class="line">&quot;www.google.com&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; HGET website yahoo</span><br><span class="line">&quot;www.yahoo.com&quot;</span><br></pre></td></tr></table></figure></p><p>6.HMGET key field [field …]<br>时间复杂度<strong>O(N)</strong>，<code>N</code>为给定域的数量。<br>返回哈希表<code>key</code>中，一个或多个给定域的值，如果给定的域不存在于哈希表，那么返回一个<code>nil</code>值，因为不存在的<code>key</code>被当作一个空哈希表来处理，所以对一个不存在的<code>key</code>进行<code>HMGET</code>操作将返回一个只带有<code>nil</code>值的表。<br><strong>返回值：</strong> 一个包含多个给定域的关联值的表，表值的排列顺序和给定域参数的请求顺序一样。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HMSET pet dog &quot;doudou&quot; cat &quot;nounou&quot;    #一次设置多个域</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; HMGET pet dog cat fake_pet             #返回值的顺序和传入参数的顺序一样</span><br><span class="line">1) &quot;doudou&quot;</span><br><span class="line">2) &quot;nounou&quot;</span><br><span class="line">3) (nil)                                      #不存在的域返回nil值</span><br></pre></td></tr></table></figure></p><p>7.N次HGET和一次HMGET对比<br>参考字符串的<code>N</code>次<code>GET</code>和一次<code>MGET</code>对比，大概相同</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表用于储存多个有序的字符串，列表是一种比较灵活的数据结构，可以充当<strong>栈</strong>和<strong>队列</strong>的角色。</p><h4 id="键值结构-2"><a href="#键值结构-2" class="headerlink" title="键值结构"></a>键值结构</h4><p>列表的<code>value</code>其实是一个双向链表，可以在链表的两头插入或者删除元素<br><img src="http://wx3.sinaimg.cn/large/e0e01e43gy1g04u9xkllmj21bs0ijq7t.jpg" alt="image"></p><h4 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h4><p>1.LPUSH key value [value …]<br>时间复杂度<strong>O(1)</strong>。<br>将一个或多个值<code>value</code>插入到列表<code>key</code>的表头，如果有多个<code>value</code>值，那么各个<code>value</code>值按从左到右的顺序依次插入到表头：比如说，对空列表<code>mylist</code>执行命令<code>LPUSH mylist a b c</code>，列表的值将是<code>c b a</code>，这等同于原子性地执行<code>LPUSH mylist a</code>、<code>LPUSH mylist b</code>和<code>LPUSH mylist c</code>三个命令，如果<code>key</code>不存在，一个空列表会被创建并执行<code>LPUSH</code>操作，当<code>key</code>存在但不是列表类型时，返回一个错误。<br><strong>返回值：</strong> 执行<code>LPUSH</code>命令后，列表的长度。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#加入单个元素</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH languages python</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#加入重复元素</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH languages python</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE languages 0 -1     #列表允许重复元素</span><br><span class="line">1) &quot;python&quot;</span><br><span class="line">2) &quot;python&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#加入多个元素</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH mylist a b c</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;a&quot;</span><br></pre></td></tr></table></figure></p><p>2.RPUSH key value [value …]<br>时间复杂度<strong>O(1)</strong>。<br>将一个或多个值<code>value</code>插入到列表<code>key</code>的表尾（最右边），如果有多个<code>value</code>值，那么各个<code>value</code>值按从左到右的顺序依次插入到表尾：比如说，对空列表<code>mylist</code>执行命令<code>RPUSH mylist a b c</code>，列表的值将是<code>c b a</code>，这等同于原子性地执行<code>RPUSH mylist a</code>、<code>RPUSH mylist b</code>和<code>RPUSH mylist c</code>三个命令，如果<code>key</code>不存在，一个空列表会被创建并执行<code>RPUSH</code>操作，当<code>key</code>存在但不是列表类型时，返回一个错误。<br><strong>返回值：</strong> 执行<code>RPUSH</code>命令后，列表的长度。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#添加单个元素</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH languages c</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#添加重复元素</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH languages c</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE languages 0 -1 #列表允许重复元素</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#添加多个元素</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH mylist a b c</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;c&quot;</span><br></pre></td></tr></table></figure></p><p>3.LPOP key<br>时间复杂度<strong>O(1)</strong>。<br>移除头元素并返回列表<code>key</code>新的头元素。<br><strong>返回值：</strong> 列表的头元素。当<code>key</code>不存在时，返回<code>nil</code>。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#加入单个元素</span><br><span class="line">redis&gt; LLEN course</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH course algorithm001</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH course c++101</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LPOP course  #移除头元素</span><br><span class="line">&quot;algorithm001&quot;</span><br></pre></td></tr></table></figure></p><p>4.RPOP key<br>时间复杂度<strong>O(1)</strong>。<br>移除尾元素并返回列表<code>key</code>新的尾元素。<br><strong>返回值：</strong> 列表的尾元素。当<code>key</code>不存在时，返回<code>nil</code>。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH mylist &quot;one&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH mylist &quot;two&quot;</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH mylist &quot;three&quot;</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; RPOP mylist           #返回被弹出的元素</span><br><span class="line">&quot;three&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE mylist 0 -1    #列表剩下的元素</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;two&quot;</span><br></pre></td></tr></table></figure></p><p>5.LINDEX key index<br>时间复杂度<strong>O(N)</strong>，<code>N</code>为到达下标<code>index</code>过程中经过的元素数量。因此，对列表的头元素和尾元素执行<code>LINDEX</code>命令，复杂度为O(1)。<br>返回列表<code>key</code>中，下标为<code>index</code>的元素，下标(index)参数<code>start</code>和<code>stop</code>都以<code>0</code>为底，也就是说，以<code>0</code>表示列表的第一个元素，以<code>1</code>表示列表的第二个元素，以此类推，你也可以使用负数下标，以<code>-1</code>表示列表的最后一个元素，<code>-2</code>表示列表的倒数第二个元素，以此类推，如果<code>key</code>不是列表类型，返回一个错误。<br><strong>返回值：</strong> 列表中下标为<code>index</code>的元素。如果<code>index</code>参数的值不在列表的区间范围内(out of range)，返回<code>nil</code>。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LPUSH mylist &quot;World&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH mylist &quot;Hello&quot;</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LINDEX mylist 0</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; LINDEX mylist -1</span><br><span class="line">&quot;World&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; LINDEX mylist 3        #index不在 mylist 的区间范围内</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></p><p>6.LINSERT key BEFORE|AFTER pivot value<br>时间复杂度<strong>O(N)</strong>，<code>N</code>为寻找<code>pivot</code>过程中经过的元素数量。<br>将值<code>value</code>插入到列表<code>key</code>当中，位于值<code>pivot</code>之前或之后，当<code>pivot</code>不存在于列表<code>key</code>时，不执行任何操作，当<code>key</code>不存在时，<code>key</code>被视为空列表，不执行任何操作，如果<code>key</code>不是列表类型，返回一个错误。<br><strong>返回值：</strong> 如果命令执行成功，返回插入操作完成之后，列表的长度。如果没有找到<code>pivot</code>，返回<code>-1</code>。如果<code>key</code>不存在或为空列表，返回<code>0</code>。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH mylist &quot;Hello&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH mylist &quot;World&quot;</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LINSERT mylist BEFORE &quot;World&quot; &quot;There&quot;</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) &quot;Hello&quot;</span><br><span class="line">2) &quot;There&quot;</span><br><span class="line">3) &quot;World&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#对一个非空列表插入，查找一个不存在的 pivot</span><br><span class="line"></span><br><span class="line">redis&gt; LINSERT mylist BEFORE &quot;go&quot; &quot;let&apos;s&quot;</span><br><span class="line">(integer) -1                                    #失败</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#对一个空列表执行 LINSERT 命令</span><br><span class="line"></span><br><span class="line">redis&gt; EXISTS fake_list</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">redis&gt; LINSERT fake_list BEFORE &quot;nono&quot; &quot;gogogog&quot;</span><br><span class="line">(integer) 0                                      #失败</span><br></pre></td></tr></table></figure></p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>Redis的<code>Set</code>是<code>String</code>类型的无序集合，这里的集合也就是我们小学都接触到的集合，可以求交集、并集、差集等。集合成员是唯一的，这就意味着集合中不能出现重复的数据。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。   </p><h4 id="键值结构-3"><a href="#键值结构-3" class="headerlink" title="键值结构"></a>键值结构</h4><p>左边为<code>key</code>,是字符串类型。右边为<code>value</code>,可以将一些字符串进行一些组合，是集合类型。Redis中的集合类型还支持集合之间的操作，这与Redis中的其他数据结构是不同的，Redis可以对两个集合进行操作，取两个集合的交集，并集，差集以及对称差集等。<br><img src="http://ws1.sinaimg.cn/large/e0e01e43gy1g04woe8h2dj20je093myh.jpg" alt="image"></p><h4 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h4><p>1.SADD key member [member …]<br>时间复杂度<strong>O(N)</strong>，<code>N</code>为被添加的元素的数量。<br>将一个或多个<code>member</code>元素加入到集合<code>key</code>当中，已经存在于集合的<code>member</code>元素将被忽略，假如<code>key</code>不存在，则创建一个只包含<code>member</code>元素作成员的集合，当<code>key</code>不是集合类型时，返回一个错误。<br><strong>返回值：</strong> 被添加到集合中的新元素的数量，不包括被忽略的元素。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#添加单个元素</span><br><span class="line"></span><br><span class="line">redis&gt; SADD bbs &quot;discuz.net&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#添加重复元素</span><br><span class="line"></span><br><span class="line">redis&gt; SADD bbs &quot;discuz.net&quot;</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#添加多个元素</span><br><span class="line"></span><br><span class="line">redis&gt; SADD bbs &quot;tianya.cn&quot; &quot;groups.google.com&quot;</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS bbs</span><br><span class="line">1) &quot;discuz.net&quot;</span><br><span class="line">2) &quot;groups.google.com&quot;</span><br><span class="line">3) &quot;tianya.cn&quot;</span><br></pre></td></tr></table></figure></p><p>2.SPOP key [count]<br>时间复杂度<strong>O(1)</strong>。<br>随机移除<code>count</code>个元素并返回被移除的元素。<br><strong>返回值：</strong> 被移除的随机元素。当<code>key</code>不存在或<code>key</code>是空集时，返回<code>nil</code>。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS db</span><br><span class="line">1) &quot;MySQL&quot;</span><br><span class="line">2) &quot;MongoDB&quot;</span><br><span class="line">3) &quot;Redis&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; SPOP db</span><br><span class="line">&quot;Redis&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS db</span><br><span class="line">1) &quot;MySQL&quot;</span><br><span class="line">2) &quot;MongoDB&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; SPOP db</span><br><span class="line">&quot;MySQL&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS db</span><br><span class="line">1) &quot;MongoDB&quot;</span><br></pre></td></tr></table></figure></p><p>3.SREM key member [member …]<br>时间复杂度<strong>O(N)</strong>，<code>N</code>为给定<code>member</code>元素的个数。<br>移除集合<code>key</code>中的一个或多个<code>member</code>元素，不存在的<code>member</code>元素会被忽略，当<code>key</code>不是集合类型，返回一个错误。<br><strong>返回值：</strong> 被成功移除的元素的个数，不包括被忽略的元素。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#测试数据</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS languages</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;lisp&quot;</span><br><span class="line">3) &quot;python&quot;</span><br><span class="line">4) &quot;ruby&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#移除单个元素</span><br><span class="line"></span><br><span class="line">redis&gt; SREM languages ruby</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#移除不存在元素</span><br><span class="line"></span><br><span class="line">redis&gt; SREM languages non-exists-language</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#移除多个元素</span><br><span class="line"></span><br><span class="line">redis&gt; SREM languages lisp python c</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS languages</span><br><span class="line">(empty list or set)</span><br></pre></td></tr></table></figure></p><p>4.SMEMBERS key<br>时间复杂度<strong>O(N)</strong>，<code>N</code>为集合的基数。<br>返回集合<code>key</code>中的所有成员，不存在的<code>key</code>被视为空集合。<br><strong>返回值：</strong> 集合中的所有成员。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#key 不存在或集合为空</span><br><span class="line"></span><br><span class="line">redis&gt; EXISTS not_exists_key</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS not_exists_key</span><br><span class="line">(empty list or set)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#非空集合</span><br><span class="line"></span><br><span class="line">redis&gt; SADD language Ruby Python Clojure</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS language</span><br><span class="line">1) &quot;Python&quot;</span><br><span class="line">2) &quot;Ruby&quot;</span><br><span class="line">3) &quot;Clojure&quot;</span><br></pre></td></tr></table></figure></p><h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><p>Redis有序集合和集合一样也是<code>String</code>类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个<code>double</code>类型的分数。Redis正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p><h4 id="键值结构-4"><a href="#键值结构-4" class="headerlink" title="键值结构"></a>键值结构</h4><p>有序集合的<code>value</code>包括<code>score</code>和<code>value</code>两部分，其中<code>score</code>表示分值用来排序的<br><img src="http://wx3.sinaimg.cn/large/e0e01e43gy1g04y9o37y7j21810j644t.jpg" alt="image"></p><h4 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h4><p>1.ZADD key [NX|XX] [CH] [INCR] score member [score member …]<br>时间复杂度<strong>O(M*log(N))</strong>，<code>N</code>是有序集的基数，<code>M</code>为成功添加的新成员的数量。<br>将一个或多个<code>member</code>元素及其<code>score</code>值加入到有序集<code>key</code>当中。如果某个<code>member</code>已经是有序集的成员，那么更新这个<code>member</code>的<code>score</code>值，并通过重新插入这个<code>member</code>元素，来保证该<code>member</code>在正确的位置上。<code>score</code>值可以是整数值或双精度浮点数。如果<code>key</code>不存在，则创建一个空的有序集并执行<code>ZADD</code>操作。当<code>key</code>存在但不是有序集类型时，返回一个错误。<br>Redis 3.0.2 为<code>ZADD</code>命令添加了<code>NX</code>、<code>XX</code>、<code>CH</code>、<code>INCR</code> 四个选项：</p><ul><li><code>NX</code>：<code>member</code>必须不存在，才可以设置成功，用于添加。   </li><li><code>XX</code>：<code>member</code>必须存在，才可以设置成功，用于更新。  </li><li><code>CH</code>：返回此次操作后，有序集合元素和分数发生变化的个数。    </li><li><code>INCR</code>：对<code>score</code>做增加，相当于<code>ZINCRBY</code>。<br><strong>返回值：</strong> 被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。<br><strong>代码演示：</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> redis&gt; ZADD ztest 100 java 99 python 80 go 120 kotlin</span><br><span class="line">(integer) 4</span><br><span class="line">#查看有序集合内所有元素并且按分数排序</span><br><span class="line"> coderknock&gt; ZRANGE ztest 0 -1 WITHSCORES</span><br><span class="line">1) &quot;go&quot;</span><br><span class="line">2) &quot;80&quot;</span><br><span class="line">3) &quot;python&quot;</span><br><span class="line">4) &quot;99&quot;</span><br><span class="line">5) &quot;java&quot;</span><br><span class="line">6) &quot;100&quot;</span><br><span class="line">7) &quot;kotlin&quot;</span><br><span class="line">8) &quot;120&quot;</span><br><span class="line">#选项填写在 key 后面，位置不能错误</span><br><span class="line"> redis&gt; ZADD ztest 100 java 99 python 80 go 120 kotlin CH</span><br><span class="line">(error) ERR syntax error</span><br><span class="line"> redis&gt; ZADD CH ztest 100 java 99 python 80 go 120 kotlin</span><br><span class="line">(error) ERR syntax error</span><br><span class="line">#下面两个语句进行了对比，如果不加 CH 显示的数量不包括更新和已经存在的。</span><br><span class="line"> redis&gt;  ZADD ztest CH 100 java 99 python 80 go 121 kotlin</span><br><span class="line">(integer) 1</span><br><span class="line"> redis&gt;  ZADD ztest 100 java 99 python 80 go 120 kotlin</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></li></ul><p>2.ZREM key member [member …]<br>时间复杂度<strong>O(M*log(N))</strong>，<code>N</code>是有序集的基数，<code>M</code>为成功移除的成员的数量。<br>移除有序集<code>key</code>中的一个或多个成员，不存在的成员将被忽略，当<code>key</code>存在但不是有序集类型时，返回一个错误。<br><strong>返回值：</strong> 被成功移除的成员的数量，不包括被忽略的成员。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#测试数据</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</span><br><span class="line">1) &quot;bing.com&quot;</span><br><span class="line">2) &quot;8&quot;</span><br><span class="line">3) &quot;baidu.com&quot;</span><br><span class="line">4) &quot;9&quot;</span><br><span class="line">5) &quot;google.com&quot;</span><br><span class="line">6) &quot;10&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#移除单个元素</span><br><span class="line"></span><br><span class="line">redis&gt; ZREM page_rank google.com</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</span><br><span class="line">1) &quot;bing.com&quot;</span><br><span class="line">2) &quot;8&quot;</span><br><span class="line">3) &quot;baidu.com&quot;</span><br><span class="line">4) &quot;9&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#移除多个元素</span><br><span class="line"></span><br><span class="line">redis&gt; ZREM page_rank baidu.com bing.com</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</span><br><span class="line">(empty list or set)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#移除不存在元素</span><br><span class="line"></span><br><span class="line">redis&gt; ZREM page_rank non-exists-element</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ws1.sinaimg.cn/large/e0e01e43gy1fzz559f0n2j21d80gf3zh.jpg&quot; alt=&quot;image&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Redis入门教程目录&lt;/strong&gt;：&lt;a href=&quot;https://ddnd.cn/categories/Redis/&quot;&gt;【Redis入门教程目录】&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://ddnd.cn/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>第一章 认识Redis 【Redis入门教程】</title>
    <link href="http://ddnd.cn/2019/02/08/redis-chapter-1/"/>
    <id>http://ddnd.cn/2019/02/08/redis-chapter-1/</id>
    <published>2019-02-08T09:19:29.000Z</published>
    <updated>2019-03-12T10:14:35.033Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ws1.sinaimg.cn/large/e0e01e43gy1fzz559f0n2j21d80gf3zh.jpg" alt="image" width="100%"></p><p><strong>Redis入门教程目录</strong>：<a href="https://ddnd.cn/categories/Redis/">【Redis入门教程目录】</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>Redis</strong>是由C语言编写的开源、基于内存、支持多种数据结构、高性能的<strong>Key-Value</strong>数据库。<br><a id="more"></a></p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="速度快"><a href="#速度快" class="headerlink" title="速度快"></a>速度快</h3><p><strong>首先</strong>Redis是将数据储存在内存中的，通常情况下每秒读写次数达到<strong>千万级别</strong>。<strong>其次</strong>Redis使用<code>ANSI C</code>编写，因为C语言接近操作系统，所以Redis的执行效率很高。<strong>最后</strong>Redis的处理网络请求部分采用的是<strong>单线程</strong>，如果想充分利用CPU资源的话，可以多开几个Redis实例来达到目的，为什么单线程还是速度快的原因呢？我们知道Redis的读写都是基于内存的，读写速度都是非常快的，不会出现需要等待很长时间，所以瓶颈并不会出现在请求读写上，所以没必要使用多线程来利用CPU，如果使用多线程的话（<strong>线程数&gt;CPU数情况下</strong>），多线程的创建、销毁、线程切换、线程竞争等开销所需要的时间会比执行读写所损耗的时间还多，那就南辕北辙了，当然这是在数据量小的时候才会这样，如果数据量到达一定量级了，那肯定是多线程比单线程快（<strong>线程数&lt;=CPU数情况下</strong>）。<br><img src="http://wx4.sinaimg.cn/large/e0e01e43gy1fzzbt51xfuj20w30cvag3.jpg" alt="image"></p><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>Redis可以通过<code>RDB</code>和<code>AOF</code>两种方式将数据持久化到磁盘上，其中这两种方式的区别如下：</p><ul><li><strong>RDB</strong>：是在指定的时间间隔内将内存中的数据通过<strong>异步</strong>生成数据快照并且保存到磁盘中。</li><li><strong>AOF</strong>：相对于<code>RDB</code>方式，<code>AOF</code>方式的持久化更细粒度，把每次数据变化（写、删除操作）都记录<strong>AOF文件</strong>中，其中AOF又可以配置为<code>always</code>即实时将记录写到AOF文件中，<code>everysec</code>每隔一秒将记录写到AOF文件中，<code>no</code>由系统决定何时将记录写到AOF文件中。<h3 id="多种数据结构"><a href="#多种数据结构" class="headerlink" title="多种数据结构"></a>多种数据结构</h3>Redis支持五种基本的数据结构，分别是String（字符串），Hash（哈希），List（列表），Set（集合），Zset（即Sorted Set有序集合）,这些数据结构类型和我们使用的开发语言的数据结构类型其实是相对应的。<br><img src="http://wx2.sinaimg.cn/large/e0e01e43gy1fzzfhx264oj20oc0awq52.jpg" alt="image"><h3 id="多语言客户端"><a href="#多语言客户端" class="headerlink" title="多语言客户端"></a>多语言客户端</h3>Redis支持多种语言，诸如Ruby,Python, Twisted Python, PHP, Erlang, Tcl, Perl, Lua, Java, Scala, Clojure等。<h3 id="功能丰富"><a href="#功能丰富" class="headerlink" title="功能丰富"></a>功能丰富</h3>Redis支持发布订阅、Lua脚本、事务、Pipeline等功能。<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3>在Redis中，用户可以通过执行SLAVEOF命令或者SLAVEOF选项，让从服务器去复制主服务器，为<strong>高可用</strong>和<strong>分布式</strong>提供了基础。<br><img src="http://wx2.sinaimg.cn/large/e0e01e43gy1fzzgkys41kj20pc0hrq7u.jpg" alt="image"><h3 id="高可用和集群"><a href="#高可用和集群" class="headerlink" title="高可用和集群"></a>高可用和集群</h3></li></ul><ol><li>高可用<br>有了主从复制之后的实现之后，如果想对服务器进行监控，那么在<code>Redis2.6</code>以后提供了一个<code>Sentinel</code>（哨兵机制）。顾名思义，哨兵的含义就是监控Redis系统的运行状态，可以启动多个哨兵，去监控Redis数据库的运行状态。其功能有以下两点：<br>a.监控所有节点数据库是否正常运行<br>b.<strong>主数据库</strong>出现故障时，可以通过自动投票机制，在<strong>从数据库</strong>选举出新的主数据库，实现将从数据库转为主数据库的自动切换。</li><li>集群<br>Redis在3.0版本正式引入了<code>Redis-Cluster</code>集群这个特征。Redis-Cluster采用无中心架构，每个节点保存完整的数据和整个集群的状态，每个节点都和其他所有节点连接。<br><img src="http://ws1.sinaimg.cn/large/e0e01e43gy1fzzymliocdj20dr0fun32.jpg" alt="image"></li></ol><h2 id="安装和启动"><a href="#安装和启动" class="headerlink" title="安装和启动"></a>安装和启动</h2><p>使用<code>wget</code>命令下载Redis<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-5.0.3.tar.gz</span><br></pre></td></tr></table></figure></p><p>解压Redis压缩包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xzf redis-5.0.3.tar.gz</span><br></pre></td></tr></table></figure></p><p>进入到Redis的文件夹<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd redis-5.0.3</span><br></pre></td></tr></table></figure></p><p>编译Redis<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></p><p>这样我们的Redis就编译好了，为了能全局使用Redis的命令，我们还需要执行安装命令，将可执行文件安装到环境变量中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure></p><p>这样Redis的安装就完成了，我们来启动Redis，其中Redis的启动有三种方式</p><ol><li>直接启动<br>直接执行<code>redis-server</code>即可启动Redis，这个方式启动实际上就是读取Redis的默认配置启动。</li><li>动态参数启动<br>执行<code>redis-server --port 6380</code>即可指定端口号启动Redis，更多参数可以参考官方的文档。</li><li>配置文件启动<br>执行<code>redis-server config.conf</code>即可指定名为<code>config.conf</code>的配置文件进行启动Redis。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ws1.sinaimg.cn/large/e0e01e43gy1fzz559f0n2j21d80gf3zh.jpg&quot; alt=&quot;image&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Redis入门教程目录&lt;/strong&gt;：&lt;a href=&quot;https://ddnd.cn/categories/Redis/&quot;&gt;【Redis入门教程目录】&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Redis&lt;/strong&gt;是由C语言编写的开源、基于内存、支持多种数据结构、高性能的&lt;strong&gt;Key-Value&lt;/strong&gt;数据库。&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://ddnd.cn/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>QQ TEA加密算法 JAVA实现</title>
    <link href="http://ddnd.cn/2019/02/07/qq-tea-algorithm/"/>
    <id>http://ddnd.cn/2019/02/07/qq-tea-algorithm/</id>
    <published>2019-02-07T07:04:45.000Z</published>
    <updated>2019-03-12T10:14:31.747Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://wx1.sinaimg.cn/large/e0e01e43gy1fzxvlxiq8nj20zf0kzqv5.jpg" alt="image" width="100%"></p><a id="more"></a><p><strong>TeaUtil.java：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 加密解密QQ消息的工具类. QQ消息的加密算法是一个16次的迭代过程，并且是反馈的，每一个加密单元是8字节，输出也是8字节，密钥是16字节</span><br><span class="line"> * 我们以prePlain表示前一个明文块，plain表示当前明文块，crypt表示当前明文块加密得到的密文块，preCrypt表示前一个密文块</span><br><span class="line"> * f表示加密算法，d表示解密算法 那么从plain得到crypt的过程是: crypt = f(plain &amp;circ; preCrypt) &amp;circ;</span><br><span class="line"> * prePlain 所以，从crypt得到plain的过程自然是 plain = d(crypt &amp;circ; prePlain) &amp;circ;</span><br><span class="line"> * preCrypt 此外，算法有它的填充机制，其会在明文前和明文后分别填充一定的字节数，以保证明文长度是8字节的倍数</span><br><span class="line"> * 填充的字节数与原始明文长度有关，填充的方法是:</span><br><span class="line"> *</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> * &lt;code&gt;</span><br><span class="line"> *</span><br><span class="line"> *      ------- 消息填充算法 -----------</span><br><span class="line"> *      a = (明文长度 + 10) mod 8</span><br><span class="line"> *      if(a 不等于 0) a = 8 - a;</span><br><span class="line"> *      b = 随机数 &amp;amp; 0xF8 | a;              这个的作用是把a的值保存了下来</span><br><span class="line"> *      plain[0] = b;                   然后把b做为明文的第0个字节，这样第0个字节就保存了a的信息，这个信息在解密时就要用来找到真正明文的起始位置</span><br><span class="line"> *      plain[1 至 a+2] = 随机数 &amp;amp; 0xFF;    这里用随机数填充明文的第1到第a+2个字节</span><br><span class="line"> *      plain[a+3 至 a+3+明文长度-1] = 明文; 从a+3字节开始才是真正的明文</span><br><span class="line"> *      plain[a+3+明文长度, 最后] = 0;       在最后，填充0，填充到总长度为8的整数为止。到此为止，结束了，这就是最后得到的要加密的明文内容</span><br><span class="line"> *      ------- 消息填充算法 ------------</span><br><span class="line"> *</span><br><span class="line"> * &lt;/code&gt;</span><br><span class="line"> * &lt;/pre&gt;</span><br><span class="line"> *</span><br><span class="line"> * @author luma</span><br><span class="line"> * @author notXX</span><br><span class="line"> */</span><br><span class="line">public class TeaUtil &#123;</span><br><span class="line">    // 指向当前的明文块</span><br><span class="line">    private byte[] plain;</span><br><span class="line">    // 这指向前面一个明文块</span><br><span class="line">    private byte[] prePlain;</span><br><span class="line">    // 输出的密文或者明文</span><br><span class="line">    private byte[] out;</span><br><span class="line">    // 当前加密的密文位置和上一次加密的密文块位置，他们相差8</span><br><span class="line">    private int crypt, preCrypt;</span><br><span class="line">    // 当前处理的加密解密块的位置</span><br><span class="line">    private int pos;</span><br><span class="line">    // 填充数</span><br><span class="line">    private int padding;</span><br><span class="line">    // 密钥</span><br><span class="line">    private byte[] key;</span><br><span class="line">    // 用于加密时，表示当前是否是第一个8字节块，因为加密算法是反馈的</span><br><span class="line">    // 但是最开始的8个字节没有反馈可用，所有需要标明这种情况</span><br><span class="line">    private boolean header = true;</span><br><span class="line">    // 这个表示当前解密开始的位置，之所以要这么一个变量是为了避免当解密到最后时</span><br><span class="line">    // 后面已经没有数据，这时候就会出错，这个变量就是用来判断这种情况免得出错</span><br><span class="line">    private int contextStart;</span><br><span class="line">    // 随机数对象</span><br><span class="line">    private static Random random = new Random();</span><br><span class="line">    // 字节输出流</span><br><span class="line">    private ByteArrayOutputStream baos;</span><br><span class="line">    /**</span><br><span class="line">     * 构造函数</span><br><span class="line">     */</span><br><span class="line">    public TeaUtil() &#123;</span><br><span class="line">        baos = new ByteArrayOutputStream(8);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 把字节数组从offset开始的len个字节转换成一个unsigned int， 因为java里面没有unsigned，所以unsigned</span><br><span class="line">     * int使用long表示的， 如果len大于8，则认为len等于8。如果len小于8，则高位填0 &lt;br&gt;</span><br><span class="line">     * (edited by notxx) 改变了算法, 性能稍微好一点. 在我的机器上测试10000次, 原始算法花费18s, 这个算法花费12s.</span><br><span class="line">     *</span><br><span class="line">     * @param in</span><br><span class="line">     *                   字节数组.</span><br><span class="line">     * @param offset</span><br><span class="line">     *                   从哪里开始转换.</span><br><span class="line">     * @param len</span><br><span class="line">     *                   转换长度, 如果len超过8则忽略后面的</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static long getUnsignedInt(byte[] in, int offset, int len) &#123;</span><br><span class="line">        long ret = 0;</span><br><span class="line">        int end = 0;</span><br><span class="line">        if (len &gt; 8)</span><br><span class="line">            end = offset + 8;</span><br><span class="line">        else</span><br><span class="line">            end = offset + len;</span><br><span class="line">        for (int i = offset; i &lt; end; i++) &#123;</span><br><span class="line">            ret &lt;&lt;= 8;</span><br><span class="line">            ret |= in[i] &amp; 0xff;</span><br><span class="line">        &#125;</span><br><span class="line">        return (ret &amp; 0xffffffffl) | (ret &gt;&gt;&gt; 32);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解密</span><br><span class="line">     * @param in 密文</span><br><span class="line">     * @param offset 密文开始的位置</span><br><span class="line">     * @param len 密文长度</span><br><span class="line">     * @param k 密钥</span><br><span class="line">     * @return 明文</span><br><span class="line">     */</span><br><span class="line">    public byte[] decrypt(byte[] in, int offset, int len, byte[] k) &#123;</span><br><span class="line">        // 检查密钥</span><br><span class="line">        if(k == null)</span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">        crypt = preCrypt = 0;</span><br><span class="line">        this.key = k;</span><br><span class="line">        int count;</span><br><span class="line">        byte[] m = new byte[offset + 8];</span><br><span class="line"></span><br><span class="line">        // 因为QQ消息加密之后至少是16字节，并且肯定是8的倍数，这里检查这种情况</span><br><span class="line">        if((len % 8 != 0) || (len &lt; 16)) return null;</span><br><span class="line">        // 得到消息的头部，关键是得到真正明文开始的位置，这个信息存在第一个字节里面，所以其用解密得到的第一个字节与7做与</span><br><span class="line">        prePlain = decipher(in, offset);</span><br><span class="line">        pos = prePlain[0] &amp; 0x7;</span><br><span class="line">        // 得到真正明文的长度</span><br><span class="line">        count = len - pos - 10;</span><br><span class="line">        // 如果明文长度小于0，那肯定是出错了，比如传输错误之类的，返回</span><br><span class="line">        if(count &lt; 0) return null;</span><br><span class="line"></span><br><span class="line">        // 这个是临时的preCrypt，和加密时第一个8字节块没有prePlain一样，解密时</span><br><span class="line">        // 第一个8字节块也没有preCrypt，所有这里建一个全0的</span><br><span class="line">        for(int i = offset; i &lt; m.length; i++)</span><br><span class="line">            m[i] = 0;</span><br><span class="line">        // 通过了上面的代码，密文应该是没有问题了，我们分配输出缓冲区</span><br><span class="line">        out = new byte[count];</span><br><span class="line">        // 设置preCrypt的位置等于0，注意目前的preCrypt位置是指向m的，因为java没有指针，所以我们在后面要控制当前密文buf的引用</span><br><span class="line">        preCrypt = 0;</span><br><span class="line">        // 当前的密文位置，为什么是8不是0呢？注意前面我们已经解密了头部信息了，现在当然该8了</span><br><span class="line">        crypt = 8;</span><br><span class="line">        // 自然这个也是8</span><br><span class="line">        contextStart = 8;</span><br><span class="line">        // 加1，和加密算法是对应的</span><br><span class="line">        pos++;</span><br><span class="line"></span><br><span class="line">        // 开始跳过头部，如果在这个过程中满了8字节，则解密下一块</span><br><span class="line">        // 因为是解密下一块，所以我们有一个语句 m = in，下一块当然有preCrypt了，我们不再用m了</span><br><span class="line">        // 但是如果不满8，这说明了什么？说明了头8个字节的密文是包含了明文信息的，当然还是要用m把明文弄出来</span><br><span class="line">        // 所以，很显然，满了8的话，说明了头8个字节的密文除了一个长度信息有用之外，其他都是无用的填充</span><br><span class="line">        padding = 1;</span><br><span class="line">        while(padding &lt;= 2) &#123;</span><br><span class="line">            if(pos &lt; 8) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">                padding++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(pos == 8) &#123;</span><br><span class="line">                m = in;</span><br><span class="line">                if(!decrypt8Bytes(in, offset, len)) return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 这里是解密的重要阶段，这个时候头部的填充都已经跳过了，开始解密</span><br><span class="line">        // 注意如果上面一个while没有满8，这里第一个if里面用的就是原始的m，否则这个m就是in了</span><br><span class="line">        int i = 0;</span><br><span class="line">        while(count != 0) &#123;</span><br><span class="line">            if(pos &lt; 8) &#123;</span><br><span class="line">                out[i] = (byte)(m[offset + preCrypt + pos] ^ prePlain[pos]);</span><br><span class="line">                i++;</span><br><span class="line">                count--;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(pos == 8) &#123;</span><br><span class="line">                m = in;</span><br><span class="line">                preCrypt = crypt - 8;</span><br><span class="line">                if(!decrypt8Bytes(in, offset, len))</span><br><span class="line">                    return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 最后的解密部分，上面一个while已经把明文都解出来了，就剩下尾部的填充了，应该全是0</span><br><span class="line">        // 所以这里有检查是否解密了之后是不是0，如果不是的话那肯定出错了，返回null</span><br><span class="line">        for(padding = 1; padding &lt; 8; padding++) &#123;</span><br><span class="line">            if(pos &lt; 8) &#123;</span><br><span class="line">                if((m[offset + preCrypt + pos] ^ prePlain[pos]) != 0)</span><br><span class="line">                    return null;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(pos == 8) &#123;</span><br><span class="line">                m = in;</span><br><span class="line">                preCrypt = crypt;</span><br><span class="line">                if(!decrypt8Bytes(in, offset, len))</span><br><span class="line">                    return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param in</span><br><span class="line">     *            需要被解密的密文</span><br><span class="line">     * @paraminLen</span><br><span class="line">     *            密文长度</span><br><span class="line">     * @param k</span><br><span class="line">     *            密钥</span><br><span class="line">     * @return Message 已解密的消息</span><br><span class="line">     */</span><br><span class="line">    public byte[] decrypt(byte[] in, byte[] k) &#123;</span><br><span class="line">        return decrypt(in, 0, in.length, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 加密</span><br><span class="line">     * @param in 明文字节数组</span><br><span class="line">     * @param offset 开始加密的偏移</span><br><span class="line">     * @param len 加密长度</span><br><span class="line">     * @param k 密钥</span><br><span class="line">     * @return 密文字节数组</span><br><span class="line">     */</span><br><span class="line">    public byte[] encrypt(byte[] in, int offset, int len, byte[] k) &#123;</span><br><span class="line">        // 检查密钥</span><br><span class="line">        if(k == null)</span><br><span class="line">            return in;</span><br><span class="line"></span><br><span class="line">        plain = new byte[8];</span><br><span class="line">        prePlain = new byte[8];</span><br><span class="line">        pos = 1;</span><br><span class="line">        padding = 0;</span><br><span class="line">        crypt = preCrypt = 0;</span><br><span class="line">        this.key = k;</span><br><span class="line">        header = true;</span><br><span class="line"></span><br><span class="line">        // 计算头部填充字节数</span><br><span class="line">        pos = (len + 0x0A) % 8;</span><br><span class="line">        if(pos != 0)</span><br><span class="line">            pos = 8 - pos;</span><br><span class="line">        // 计算输出的密文长度</span><br><span class="line">        out = new byte[len + pos + 10];</span><br><span class="line">        // 这里的操作把pos存到了plain的第一个字节里面</span><br><span class="line">        // 0xF8后面三位是空的，正好留给pos，因为pos是0到7的值，表示文本开始的字节位置</span><br><span class="line">        plain[0] = (byte)((rand() &amp; 0xF8) | pos);</span><br><span class="line"></span><br><span class="line">        // 这里用随机产生的数填充plain[1]到plain[pos]之间的内容</span><br><span class="line">        for(int i = 1; i &lt;= pos; i++)</span><br><span class="line">            plain[i] = (byte)(rand() &amp; 0xFF);</span><br><span class="line">        pos++;</span><br><span class="line">        // 这个就是prePlain，第一个8字节块当然没有prePlain，所以我们做一个全0的给第一个8字节块</span><br><span class="line">        for(int i = 0; i &lt; 8; i++)</span><br><span class="line">            prePlain[i] = 0x0;</span><br><span class="line"></span><br><span class="line">        // 继续填充2个字节的随机数，这个过程中如果满了8字节就加密之</span><br><span class="line">        padding = 1;</span><br><span class="line">        while(padding &lt;= 2) &#123;</span><br><span class="line">            if(pos &lt; 8) &#123;</span><br><span class="line">                plain[pos++] = (byte)(rand() &amp; 0xFF);</span><br><span class="line">                padding++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(pos == 8)</span><br><span class="line">                encrypt8Bytes();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 头部填充完了，这里开始填真正的明文了，也是满了8字节就加密，一直到明文读完</span><br><span class="line">        int i = offset;</span><br><span class="line">        while(len &gt; 0) &#123;</span><br><span class="line">            if(pos &lt; 8) &#123;</span><br><span class="line">                plain[pos++] = in[i++];</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            if(pos == 8)</span><br><span class="line">                encrypt8Bytes();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 最后填上0，以保证是8字节的倍数</span><br><span class="line">        padding = 1;</span><br><span class="line">        while(padding &lt;= 7) &#123;</span><br><span class="line">            if(pos &lt; 8) &#123;</span><br><span class="line">                plain[pos++] = 0x0;</span><br><span class="line">                padding++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(pos == 8)</span><br><span class="line">                encrypt8Bytes();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param in</span><br><span class="line">     *            需要加密的明文</span><br><span class="line">     * @paraminLen</span><br><span class="line">     *            明文长度</span><br><span class="line">     * @param k</span><br><span class="line">     *            密钥</span><br><span class="line">     * @return Message 密文</span><br><span class="line">     */</span><br><span class="line">    public byte[] encrypt(byte[] in, byte[] k) &#123;</span><br><span class="line">        return encrypt(in, 0, in.length, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 加密一个8字节块</span><br><span class="line">     *</span><br><span class="line">     * @param in</span><br><span class="line">     * 明文字节数组</span><br><span class="line">     * @return</span><br><span class="line">     * 密文字节数组</span><br><span class="line">     */</span><br><span class="line">    private byte[] encipher(byte[] in) &#123;</span><br><span class="line">        // 迭代次数，16次</span><br><span class="line">        int loop = 0x10;</span><br><span class="line">        // 得到明文和密钥的各个部分，注意java没有无符号类型，所以为了表示一个无符号的整数</span><br><span class="line">        // 我们用了long，这个long的前32位是全0的，我们通过这种方式模拟无符号整数，后面用到的long也都是一样的</span><br><span class="line">        // 而且为了保证前32位为0，需要和0xFFFFFFFF做一下位与</span><br><span class="line">        long y = getUnsignedInt(in, 0, 4);</span><br><span class="line">        long z = getUnsignedInt(in, 4, 4);</span><br><span class="line">        long a = getUnsignedInt(key, 0, 4);</span><br><span class="line">        long b = getUnsignedInt(key, 4, 4);</span><br><span class="line">        long c = getUnsignedInt(key, 8, 4);</span><br><span class="line">        long d = getUnsignedInt(key, 12, 4);</span><br><span class="line">        // 这是算法的一些控制变量，为什么delta是0x9E3779B9呢？</span><br><span class="line">        // 这个数是TEA算法的delta，实际是就是(sqr(5) - 1) * 2^31 (根号5，减1，再乘2的31次方)</span><br><span class="line">        long sum = 0;</span><br><span class="line">        long delta = 0x9E3779B9;</span><br><span class="line">        delta &amp;= 0xFFFFFFFFL;</span><br><span class="line"></span><br><span class="line">        // 开始迭代了，乱七八糟的，我也看不懂，反正和DES之类的差不多，都是这样倒来倒去</span><br><span class="line">        while (loop-- &gt; 0) &#123;</span><br><span class="line">            sum += delta;</span><br><span class="line">            sum &amp;= 0xFFFFFFFFL;</span><br><span class="line">            y += ((z &lt;&lt; 4) + a) ^ (z + sum) ^ ((z &gt;&gt;&gt; 5) + b);</span><br><span class="line">            y &amp;= 0xFFFFFFFFL;</span><br><span class="line">            z += ((y &lt;&lt; 4) + c) ^ (y + sum) ^ ((y &gt;&gt;&gt; 5) + d);</span><br><span class="line">            z &amp;= 0xFFFFFFFFL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 最后，我们输出密文，因为我用的long，所以需要强制转换一下变成int</span><br><span class="line">        baos.reset();</span><br><span class="line">        writeInt((int)y);</span><br><span class="line">        writeInt((int)z);</span><br><span class="line">        return baos.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解密从offset开始的8字节密文</span><br><span class="line">     *</span><br><span class="line">     * @param in</span><br><span class="line">     * 密文字节数组</span><br><span class="line">     * @param offset</span><br><span class="line">     * 密文开始位置</span><br><span class="line">     * @return</span><br><span class="line">     * 明文</span><br><span class="line">     */</span><br><span class="line">    private byte[] decipher(byte[] in, int offset) &#123;</span><br><span class="line">        // 迭代次数，16次</span><br><span class="line">        int loop = 0x10;</span><br><span class="line">        // 得到密文和密钥的各个部分，注意java没有无符号类型，所以为了表示一个无符号的整数</span><br><span class="line">        // 我们用了long，这个long的前32位是全0的，我们通过这种方式模拟无符号整数，后面用到的long也都是一样的</span><br><span class="line">        // 而且为了保证前32位为0，需要和0xFFFFFFFF做一下位与</span><br><span class="line">        long y = getUnsignedInt(in, offset, 4);</span><br><span class="line">        long z = getUnsignedInt(in, offset + 4, 4);</span><br><span class="line">        long a = getUnsignedInt(key, 0, 4);</span><br><span class="line">        long b = getUnsignedInt(key, 4, 4);</span><br><span class="line">        long c = getUnsignedInt(key, 8, 4);</span><br><span class="line">        long d = getUnsignedInt(key, 12, 4);</span><br><span class="line">        // 算法的一些控制变量，sum在这里也有数了，这个sum和迭代次数有关系</span><br><span class="line">        // 因为delta是这么多，所以sum如果是这么多的话，迭代的时候减减减，减16次，最后</span><br><span class="line">        // 得到0。反正这就是为了得到和加密时相反顺序的控制变量，这样才能解密呀～～</span><br><span class="line">        long sum = 0xE3779B90;</span><br><span class="line">        sum &amp;= 0xFFFFFFFFL;</span><br><span class="line">        long delta = 0x9E3779B9;</span><br><span class="line">        delta &amp;= 0xFFFFFFFFL;</span><br><span class="line"></span><br><span class="line">        // 迭代开始了， @_@</span><br><span class="line">        while(loop-- &gt; 0) &#123;</span><br><span class="line">            z -= ((y &lt;&lt; 4) + c) ^ (y + sum) ^ ((y &gt;&gt;&gt; 5) + d);</span><br><span class="line">            z &amp;= 0xFFFFFFFFL;</span><br><span class="line">            y -= ((z &lt;&lt; 4) + a) ^ (z + sum) ^ ((z &gt;&gt;&gt; 5) + b);</span><br><span class="line">            y &amp;= 0xFFFFFFFFL;</span><br><span class="line">            sum -= delta;</span><br><span class="line">            sum &amp;= 0xFFFFFFFFL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        baos.reset();</span><br><span class="line">        writeInt((int)y);</span><br><span class="line">        writeInt((int)z);</span><br><span class="line">        return baos.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 写入一个整型到输出流，高字节优先</span><br><span class="line">     *</span><br><span class="line">     * @param t</span><br><span class="line">     */</span><br><span class="line">    private void writeInt(int t) &#123;</span><br><span class="line">        baos.write(t &gt;&gt;&gt; 24);</span><br><span class="line">        baos.write(t &gt;&gt;&gt; 16);</span><br><span class="line">        baos.write(t &gt;&gt;&gt; 8);</span><br><span class="line">        baos.write(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解密</span><br><span class="line">     *</span><br><span class="line">     * @param in</span><br><span class="line">     * 密文</span><br><span class="line">     * @return</span><br><span class="line">     * 明文</span><br><span class="line">     */</span><br><span class="line">    private byte[] decipher(byte[] in) &#123;</span><br><span class="line">        return decipher(in, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 加密8字节</span><br><span class="line">     */</span><br><span class="line">    private void encrypt8Bytes() &#123;</span><br><span class="line">        // 这部分完成我上面所说的 plain ^ preCrypt，注意这里判断了是不是第一个8字节块，如果是的话，那个prePlain就当作preCrypt用</span><br><span class="line">        for(pos = 0; pos &lt; 8; pos++) &#123;</span><br><span class="line">            if(header)</span><br><span class="line">                plain[pos] ^= prePlain[pos];</span><br><span class="line">            else</span><br><span class="line">                plain[pos] ^= out[preCrypt + pos];</span><br><span class="line">        &#125;</span><br><span class="line">        // 这个完成我上面说的 f(plain ^ preCrypt)</span><br><span class="line">        byte[] crypted = encipher(plain);</span><br><span class="line">        // 这个没什么，就是拷贝一下，java不像c，所以我只好这么干，c就不用这一步了</span><br><span class="line">        System.arraycopy(crypted, 0, out, crypt, 8);</span><br><span class="line"></span><br><span class="line">        // 这个完成了 f(plain ^ preCrypt) ^ prePlain，ok，下面拷贝一下就行了</span><br><span class="line">        for(pos = 0; pos &lt; 8; pos++)</span><br><span class="line">            out[crypt + pos] ^= prePlain[pos];</span><br><span class="line">        System.arraycopy(plain, 0, prePlain, 0, 8);</span><br><span class="line"></span><br><span class="line">        // 完成了加密，现在是调整crypt，preCrypt等等东西的时候了</span><br><span class="line">        preCrypt = crypt;</span><br><span class="line">        crypt += 8;</span><br><span class="line">        pos = 0;</span><br><span class="line">        header = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解密8个字节</span><br><span class="line">     *</span><br><span class="line">     * @param in</span><br><span class="line">     * 密文字节数组</span><br><span class="line">     * @param offset</span><br><span class="line">     * 从何处开始解密</span><br><span class="line">     * @param len</span><br><span class="line">     * 密文的长度</span><br><span class="line">     * @return</span><br><span class="line">     * true表示解密成功</span><br><span class="line">     */</span><br><span class="line">    private boolean decrypt8Bytes(byte[] in , int offset, int len) &#123;</span><br><span class="line">        // 这里第一步就是判断后面还有没有数据，没有就返回，如果有，就执行 crypt ^ prePlain</span><br><span class="line">        for(pos = 0; pos &lt; 8; pos++) &#123;</span><br><span class="line">            if(contextStart + pos &gt;= len)</span><br><span class="line">                return true;</span><br><span class="line">            prePlain[pos] ^= in[offset + crypt + pos];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 好，这里执行到了 d(crypt ^ prePlain)</span><br><span class="line">        prePlain = decipher(prePlain);</span><br><span class="line">        if(prePlain == null)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        // 解密完成，最后一步好像没做？</span><br><span class="line">        // 这里最后一步放到decrypt里面去做了，因为解密的步骤有点不太一样</span><br><span class="line">        // 调整这些变量的值先</span><br><span class="line">        contextStart += 8;</span><br><span class="line">        crypt += 8;</span><br><span class="line">        pos = 0;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这是个随机因子产生器，用来填充头部的，如果为了调试，可以用一个固定值</span><br><span class="line">     * 随机因子可以使相同的明文每次加密出来的密文都不一样</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     * 随机因子</span><br><span class="line">     */</span><br><span class="line">    private int rand() &#123;</span><br><span class="line">        return random.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用算法加解密：<br><strong>Test.java:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        byte[] KEY = new byte[]&#123;//KEY</span><br><span class="line">                0x00000000, 0x00000000,</span><br><span class="line">                0x00000000, 0x00000000,</span><br><span class="line">                0x00000000, 0x00000000,</span><br><span class="line">                0x00000000, 0x00000000,</span><br><span class="line">                0x00000000, 0x00000000,</span><br><span class="line">                0x00000000, 0x00000000,</span><br><span class="line">                0x00000000, 0x00000000,</span><br><span class="line">                0x00000000, 0x00000000,</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        byte[] content = new byte[]&#123;//加密内容</span><br><span class="line">                0x00000000, 0x00000000,</span><br><span class="line">                0x00000000, 0x00000000,</span><br><span class="line">        &#125;;        </span><br><span class="line">        </span><br><span class="line">        TeaUtil teaUtil = new TeaUtil();</span><br><span class="line">        byte[] enByte = teaUtil.encrypt(content,KEY); //加密后的字节</span><br><span class="line">        byte[] deByte = teaUtil.decrypt(enByte,KEY); //解密后的字节</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://wx1.sinaimg.cn/large/e0e01e43gy1fzxvlxiq8nj20zf0kzqv5.jpg&quot; alt=&quot;image&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术杂谈" scheme="http://ddnd.cn/categories/Technique/"/>
    
    
      <category term="TEA算法" scheme="http://ddnd.cn/tags/TEA%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Shiro和Spring MVC、Mybatis整合教程</title>
    <link href="http://ddnd.cn/2019/02/02/springmvc-mybatis-shiro/"/>
    <id>http://ddnd.cn/2019/02/02/springmvc-mybatis-shiro/</id>
    <published>2019-02-02T13:00:54.000Z</published>
    <updated>2019-03-12T10:15:16.032Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fzsdwjowogj21rf0p0tc4.jpg" style="width: 100%"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Apache Shiro 是Java的<strong>安全框架</strong>，提供了认证（Authentication）、授权（Authorization）、会话（Session）管理、加密（Cryptography）等功能，且Shiro与Spring Security等安全框架相比具有简单性、灵活性、支持细粒度鉴权、支持一级缓存等，<strong>还有Shiro不跟任何容器（Tomcat等）和框架（Sping等）捆绑，可以独立运行，这也造就了Shiro不仅仅是可以用在Java EE上还可以用在Java SE上</strong>。</p><a id="more"></a><h2 id="Shiro四大功能"><a href="#Shiro四大功能" class="headerlink" title="Shiro四大功能"></a>Shiro四大功能</h2><p>在开始之前，首先了解一下Shiro的四大功能，俗话说“知己知彼百战不殆”。<br><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fzses93aygj20dn071q3n.jpg" alt="image"></p><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><p><strong>认证</strong>就是用户访问系统的时候，系统要验证用户身份的合法性，比如我们通常所说的“登录”就是认证的一种方式，只有登录成功了之后我们才能访问相应的资源。在Shiro中，我们可以将用户理解为<strong>Subject</strong>主体，在用户身份认证的时候，用户需要提供能证明他身份的信息，如用户名、密码等，用户所提供的这些用户名、密码则对应Shiro中的Principal、 Credentials，即在Subject进行身份认证的时候，需要提供相应的Principal、 Credentials，对应的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UsernamePasswordToken token = new UsernamePasswordToken(username, password);</span><br><span class="line">Subject subject = SecurityUtils.getSubject();</span><br><span class="line">subject.login(token); //提交认证</span><br></pre></td></tr></table></figure></p><p>我们知道Http协议是<strong>无状态</strong>的，所以用户认证成功后怎么才能保持认证成功的状态呢？如果是我们开发的话一般都是登录成功后将Session储存在服务器，然后再将Session返回给用户，之后的请求用户都将这个Session带上，然后服务器根据用户请求携带的Session和服务器储存的Session进行比较来判断用户是否已认证。但是使用Shiro后，<strong>Shiro已经帮我们做好这个了（下面介绍的会话管理），是不是feel爽~</strong></p><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p><strong>授权</strong>可以理解为访问控制，在用户认证（登录）成功之后，系统对用户访问资源的权限进行控制，即确定什么用户能访问什么资源，如普通用户不能访问后台，但是管理员可以。在这里我们还需要认识几个概念，资源（Resource）、角色（Role）、权限（Permission），上面提到的Subject主体可以有多个角色，每个角色又对应多个资源的多个权限，这种<strong>基于资源的访问控制</strong>可以实现细粒度的权限。对主体设置角色、权限的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();</span><br><span class="line">//  添加用户的角色</span><br><span class="line">authorizationInfo.addRoles(roleIdList);</span><br><span class="line">//  添加用户的权限</span><br><span class="line">authorizationInfo.addStringPermissions(resourceIdList);</span><br></pre></td></tr></table></figure></p><p>如果要实现这样的授权功能，我们必定需要设计一个用户组、权限，给每个方法或者URL加上判断，是否当前登录的用户满足条件。但是使用Shiro后，<strong>Shiro也帮我们帮这些都做好了</strong>。</p><h3 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h3><p><strong>会话管理</strong>的会话即Session，所谓会话，即用户访问应用时保持的连接关系，在多次交互中应用能够识别出当前访问的用户是谁，且可以在多次交互中保存一些数据。如访问一些网站时登录成功后，网站可以记住用户，且在退出之前都可以识别当前用户是谁。在Shiro中，与用户有关的一切信息都可以通过Shiro的接口获得，和用户的会话Session也都由Shiro管理。如实现“记住我”或者“下次自动登录”的功能，如果要自己去开发的话，估计又得话不少时间。但是使用Shiro后，<strong>Shiro也帮我们帮这些都做好了</strong>。</p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>用户密码明文保存是不是安全，应不应该MD5加密，是不是应该加盐，又要写密码加密的代码。 <strong>这些Shiro已经帮你做好了</strong>。</p><h2 id="Shiro三大核心概念"><a href="#Shiro三大核心概念" class="headerlink" title="Shiro三大核心概念"></a>Shiro三大核心概念</h2><p>从整体概念上理解，Shiro的体系架构有三个主要的概念，Subject（主体），Security Manager （安全管理器）和 Realms （域）。<br><img src="https://wx2.sinaimg.cn/large/e0e01e43gy1fzshhy6iu1j20bi0680tg.jpg" alt="image"></p><h3 id="Subject主体"><a href="#Subject主体" class="headerlink" title="Subject主体"></a>Subject主体</h3><p>主体是当前正在操作的用户的特定数据集合。主体可以是一个人，也可以代表第三方服务，守护进程，定时任务或类似的东西，也就是几乎所有与该应用进行交互的事物。所有Subject都绑定到<code>SecurityManager</code>，与Subject的所有交互都会委托给 SecurityManager，可以把 Subject 认为是一个门面，SecurityManager 才是实际的执行者。</p><h3 id="Security-Manager安全管理器"><a href="#Security-Manager安全管理器" class="headerlink" title="Security Manager安全管理器"></a>Security Manager安全管理器</h3><p>安全管理器，即所有与安全有关的操作都会与<code>SecurityManager</code>交互，且它<strong>管理着所有Subject</strong>可以看出它是Shiro的核心，它负责与后边介绍的其他组件进行交互，如果学习过 SpringMVC，你可以把它看成DispatcherServlet前端控制器，<strong>一般来说，一个应用只会存在一个SecurityManager实例</strong>。</p><h3 id="Realms域"><a href="#Realms域" class="headerlink" title="Realms域"></a>Realms域</h3><p>域，Shiro从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法，也需要从Realm得到用户相应的角色 / 权限进行验证用户是否能进行操作，即Realms作为Shiro与应用程序安全数据之间的“桥梁”。从这个意义上讲，Realm实质上是一个安全相关的<strong>DAO</strong>，它封装了数据源的连接细节，并在需要时将相关数据提供给Shiro。其中Realm有2个方法，<code>doGetAuthenticationInfo</code>用来认证，<code>doGetAuthorizationInfo</code>用来授权。</p><h2 id="Spring、Spring-MVC、Mybatis、Shiro集成"><a href="#Spring、Spring-MVC、Mybatis、Shiro集成" class="headerlink" title="Spring、Spring MVC、Mybatis、Shiro集成"></a>Spring、Spring MVC、Mybatis、Shiro集成</h2><h3 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h3><p><img src="https://ws4.sinaimg.cn/large/e0e01e43gy1fzsi0tujz0j20a50pgq4d.jpg" alt="image"></p><h3 id="添加依赖包"><a href="#添加依赖包" class="headerlink" title="添加依赖包"></a>添加依赖包</h3><p><strong>pox.xml：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">  &lt;groupId&gt;shiro&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;shiro&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">  &lt;name&gt;shiro Maven Webapp&lt;/name&gt;</span><br><span class="line">  &lt;!-- FIXME change it to the project&apos;s website --&gt;</span><br><span class="line">  &lt;url&gt;http://www.example.com&lt;/url&gt;</span><br><span class="line"></span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">    &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;</span><br><span class="line">    &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--Sping核心依赖--&gt;</span><br><span class="line">    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-web --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-web&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context-support --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--Mybatis依赖--&gt;</span><br><span class="line">    &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.4.6&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--MySQL连接驱动--&gt;</span><br><span class="line">    &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;8.0.13&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-core --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.4.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-web --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;shiro-web&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.4.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-spring --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.4.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.0.1&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    &lt;finalName&gt;shiro&lt;/finalName&gt;</span><br><span class="line">    &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span><br><span class="line">      &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">          &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">          &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;3.0.2&lt;/version&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;3.8.0&lt;/version&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">          &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;2.22.1&lt;/version&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">          &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;3.2.2&lt;/version&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">          &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;2.5.2&lt;/version&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">          &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;2.8.2&lt;/version&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">      &lt;/plugins&gt;</span><br><span class="line">    &lt;/pluginManagement&gt;</span><br><span class="line">  &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p><h3 id="创建数据库和实体类"><a href="#创建数据库和实体类" class="headerlink" title="创建数据库和实体类"></a>创建数据库和实体类</h3><p>为了减少篇幅，只做简单介绍，详情可以查看源码，数据库文件在本项目根目录。<br><img src="https://wx1.sinaimg.cn/large/e0e01e43gy1fzsi4q8o9qj20ks05pdge.jpg" alt="image"></p><ul><li>resource表：资源表，有<code>id</code>，<code>name</code>两个字段，分别对应资源id和权限。</li><li>role表：角色表，有<code>id</code>，<code>name</code>两个字段，分别对应角色id和角色名。</li><li>role_resource表：角色资源权限表，有<code>id</code>，<code>roleid</code>，<code>resid</code>三个字段，分别对应自增id、角色id和资源id。</li><li>user表：用户表，有<code>id</code>，<code>username</code>，<code>password</code>三个字段，分别对应自增id、用户名和密码。</li><li>user_role表：有<code>id</code>，<code>uid</code>，<code>rid</code>三个字段，分别对应自增id、用户id、和角色id。</li></ul><h3 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h3><p><strong>AccountDao.java：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface AccountDao &#123;</span><br><span class="line">    User findUserByUsername(String username);</span><br><span class="line">    List&lt;Role&gt; findRoleByUserId(int id);</span><br><span class="line">    List&lt;Resource&gt; findResourceByUserId(int id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="service层"><a href="#service层" class="headerlink" title="service层"></a>service层</h3><p><strong>AccountService.java：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface AccountService &#123;</span><br><span class="line">    User findUserByUsername(String username);</span><br><span class="line">    List&lt;Role&gt; findRoleByUserId(int id);</span><br><span class="line">    List&lt;Resource&gt; findResourceByUserId(int id);</span><br><span class="line">    boolean login(User user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>AccountServiceImpl.java：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">package com.shiro.service.impl;</span><br><span class="line"></span><br><span class="line">import com.shiro.dao.AccountDao;</span><br><span class="line">import com.shiro.entity.Role;</span><br><span class="line">import com.shiro.entity.User;</span><br><span class="line">import com.shiro.service.AccountService;</span><br><span class="line">import org.apache.shiro.SecurityUtils;</span><br><span class="line">import org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class="line">import org.apache.shiro.subject.Subject;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @program: shiro</span><br><span class="line"> * @description:</span><br><span class="line"> * @author: Xue 8</span><br><span class="line"> * @create: 2019-02-01 15:37</span><br><span class="line"> **/</span><br><span class="line">@Service</span><br><span class="line">public class AccountServiceImpl implements AccountService &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @description: 根据用户名查找用户信息</span><br><span class="line">     * @param: [username]</span><br><span class="line">     * @return: com.shiro.entity.User</span><br><span class="line">     * @author: Xue 8</span><br><span class="line">     * @date: 2019/2/1</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public User findUserByUsername(String username) &#123;</span><br><span class="line">        return accountDao.findUserByUsername(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;Role&gt; findRoleByUserId(int id) &#123;</span><br><span class="line">        return accountDao.findRoleByUserId(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;com.shiro.entity.Resource&gt; findResourceByUserId(int id) &#123;</span><br><span class="line">        return accountDao.findResourceByUserId(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean login(User user)&#123;</span><br><span class="line">//        获取当前用户对象subject</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        System.out.println(&quot;subject:&quot; + subject.toString());</span><br><span class="line">//        创建用户名/密码身份证验证Token</span><br><span class="line">        UsernamePasswordToken token = new UsernamePasswordToken(user.getUsername(), user.getPassword());</span><br><span class="line">        System.out.println(&quot;token&quot; + token);</span><br><span class="line">        try &#123;</span><br><span class="line">            subject.login(token);</span><br><span class="line">            System.out.println(&quot;登录成功&quot;);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;登录失败&quot; + e);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>MyRealm.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">package com.shiro.service.impl;</span><br><span class="line"></span><br><span class="line">import com.shiro.entity.Role;</span><br><span class="line">import com.shiro.entity.User;</span><br><span class="line">import com.shiro.service.AccountService;</span><br><span class="line">import org.apache.shiro.SecurityUtils;</span><br><span class="line">import org.apache.shiro.authc.*;</span><br><span class="line">import org.apache.shiro.authz.AuthorizationInfo;</span><br><span class="line">import org.apache.shiro.authz.SimpleAuthorizationInfo;</span><br><span class="line">import org.apache.shiro.realm.AuthorizingRealm;</span><br><span class="line">import org.apache.shiro.session.Session;</span><br><span class="line">import org.apache.shiro.subject.PrincipalCollection;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @program: shiro</span><br><span class="line"> * @description:</span><br><span class="line"> * @author: Xue 8</span><br><span class="line"> * @create: 2019-02-01 15:16</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line">public class MyRealm extends AuthorizingRealm &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    AccountService accountService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      * 身份认证的方法 认证成功获取身份验证信息</span><br><span class="line">     * 这里最主要的是user.login(token);这里有一个参数token，这个token就是用户输入的用户密码，</span><br><span class="line">     * 我们平时可能会用一个对象user来封装用户名和密码，shiro用的是token，这个是控制层的代码，还没到shiro，</span><br><span class="line">     * 当调用user.login(token)后，就交给shiro去处理了，接下shiro应该是去token中取出用户名，然后根据用户去查数据库，</span><br><span class="line">     * 把数据库中的密码查出来。这部分代码一般都是要求我们自定义实现，自定义一个realm，重写doGetAuthenticationInfo方法</span><br><span class="line">    **/</span><br><span class="line">    @Override</span><br><span class="line">    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123;</span><br><span class="line">//        获取用户输入的用户名和密码</span><br><span class="line">//        实际上这个token是从UserResource面currentUser.login(token)传过来的</span><br><span class="line">//        两个token的引用都是一样的</span><br><span class="line">        String username = (String) authenticationToken.getPrincipal();</span><br><span class="line">//        密码要用字符数组来接受 因为UsernamePasswordToken(username, password) 储存密码的时候是将字符串类型转成字符数组的 查看源码可以看出</span><br><span class="line">        String password = new String((char[]) authenticationToken.getCredentials());</span><br><span class="line">//        调用service 根据用户名查询用户信息</span><br><span class="line">        User user = accountService.findUserByUsername(username);</span><br><span class="line">//        String password = user.getPassword();</span><br><span class="line">//        判断用户是否存在 不存在则抛出异常</span><br><span class="line">        if (user != null) &#123;</span><br><span class="line">//            判断用户密码是否匹配 匹配则不匹配则抛出异常</span><br><span class="line">            if (user.getPassword().equals(password)) &#123;</span><br><span class="line">//                登录成功 把用户信息储存在Session中</span><br><span class="line">                Session session = SecurityUtils.getSubject().getSession();</span><br><span class="line">                session.setAttribute(&quot;userSession&quot;, user);</span><br><span class="line">                session.setAttribute(&quot;userSessionId&quot;, user.getId());</span><br><span class="line">//                认证成功 返回一个AuthenticationInfo的实现</span><br><span class="line">                return new SimpleAuthenticationInfo(username, password, getName());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.println(&quot;密码不正确&quot;);</span><br><span class="line">                throw new IncorrectCredentialsException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;账号不存在&quot;);</span><br><span class="line">            throw new UnknownAccountException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      * 授权的方法</span><br><span class="line">     * 1、subject.hasRole(“admin”) 或 subject.isPermitted(“admin”)：自己去调用这个是否有什么角色或者是否有什么权限的时候；</span><br><span class="line">     *</span><br><span class="line">     * 2、@RequiresRoles(&quot;admin&quot;) ：在方法上加注解的时候；</span><br><span class="line">     *</span><br><span class="line">     * 3、[@shiro.hasPermission name = &quot;admin&quot;][/@shiro.hasPermission]：在页面上加shiro标签的时候，即进这个页面的时候扫描到有这个标签的时候。</span><br><span class="line">     * 4、xml配置权限的时候也会走</span><br><span class="line">    **/</span><br><span class="line">    @Override</span><br><span class="line">    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123;</span><br><span class="line">        System.out.println(&quot;授权&quot;);</span><br><span class="line">//        从principalCollection获取用户信息</span><br><span class="line">//        如果doGetAuthenticationInfo(user,password,getName()); 传入的是user类型的数据 那这里getPrimaryPrincipal获取到的也是user类型的数据</span><br><span class="line">        String username = (String) principalCollection.getPrimaryPrincipal();</span><br><span class="line">        User user = accountService.findUserByUsername(username);</span><br><span class="line">//        获取该用户的所有角色</span><br><span class="line">        List&lt;Role&gt; roleList = accountService.findRoleByUserId(user.getId());</span><br><span class="line">//        将角色的id放到一个String列表中 因为authorizationInfo.addRoles()方法只支持角色的String列表或者单个角色String</span><br><span class="line">        List&lt;String&gt; roleIdList = new ArrayList&lt;String&gt;();</span><br><span class="line">        for (Role role:roleList) &#123;</span><br><span class="line">            roleIdList.add(role.getName());</span><br><span class="line">        &#125;</span><br><span class="line">//        获取该用户的所有权限</span><br><span class="line">        List&lt;com.shiro.entity.Resource&gt; resourceList = accountService.findResourceByUserId(user.getId());</span><br><span class="line">        List&lt;String&gt; resourceIdList = new ArrayList&lt;String&gt;();</span><br><span class="line">//        将权限id放到一个String列表中 因为authorizationInfo.addRoles()方法只支持角色的String列表或者单个角色String</span><br><span class="line">        for (com.shiro.entity.Resource resource:resourceList) &#123;</span><br><span class="line">            resourceIdList.add(resource.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;授权11&quot;);</span><br><span class="line">        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();</span><br><span class="line">//        添加用户的角色</span><br><span class="line">        authorizationInfo.addRoles(roleIdList);</span><br><span class="line">//        添加用户的权限</span><br><span class="line">        authorizationInfo.addStringPermissions(resourceIdList);</span><br><span class="line">        return authorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="controller层"><a href="#controller层" class="headerlink" title="controller层"></a>controller层</h3><p><strong>AccountController.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package com.shiro.controller;</span><br><span class="line"></span><br><span class="line">import com.shiro.entity.User;</span><br><span class="line">import com.shiro.service.AccountService;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @program: shiro</span><br><span class="line"> * @description:</span><br><span class="line"> * @author: Xue 8</span><br><span class="line"> * @create: 2019-02-01 13:14</span><br><span class="line"> **/</span><br><span class="line">@Controller</span><br><span class="line">public class AccountController &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    AccountService accountService;</span><br><span class="line">    @Resource</span><br><span class="line">    HttpServletRequest servletRequest;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;/home&quot;)</span><br><span class="line">    public String  home()&#123;</span><br><span class="line">        return &quot;home&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;/login&quot;, method = RequestMethod.GET)</span><br><span class="line">    public String  getLogin()&#123;</span><br><span class="line">        return &quot;login&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;/login&quot;, method = RequestMethod.POST)</span><br><span class="line">    public String doLogin(@RequestParam(value = &quot;username&quot;) String username,</span><br><span class="line">                        @RequestParam(value = &quot;password&quot;) String password)&#123;</span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setUsername(username);</span><br><span class="line">        user.setPassword(password);</span><br><span class="line">        if (accountService.login(user)) &#123;</span><br><span class="line">            return &quot;/home&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;/login&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以<code>GET</code>方法访问<code>/login</code>的时候，会出现登录页面，输入账号密码点击登录数据将以<code>POST</code>方式提交给<code>/login</code>，如果账号密码匹配返回<code>/home</code>的页面，否则返回<code>/login</code>的页面。<code>/home</code>页面只有在登录且有权限的情况下才可以访问，<strong>未登录情况下</strong>访问会转跳<code>/login</code>页面，这个在Shiro的配置文件里面配置。</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p><strong>applicationContext.xml：配置Spring</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">       http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">       http://www.springframework.org/schema/context</span><br><span class="line">       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--开启扫描注册--&gt;</span><br><span class="line">    &lt;context:component-scan base-package=&quot;com.shiro&quot;&gt;&lt;/context:component-scan&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--读取properties配置--&gt;</span><br><span class="line">    &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;location&quot; value=&quot;classpath:jdbcConfig.properties&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置数据源--&gt;</span><br><span class="line">    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;driverClassName&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置session工厂--&gt;</span><br><span class="line">    &lt;bean id=&quot;sessionFactoryBean&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapping/*.xml&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置扫描mapping--&gt;</span><br><span class="line">    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;basePackage&quot; value=&quot;com.shiro.dao&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sessionFactoryBean&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p><strong>spring-shiro.xml：配置Shiro</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;realm&quot; ref=&quot;myRealm&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;myRealm&quot; class=&quot;com.shiro.service.impl.MyRealm&quot;&gt;</span><br><span class="line">        &lt;!--关闭权限缓存 不然doGetAuthorizationInfo授权方法不执行--&gt;</span><br><span class="line">        &lt;property name=&quot;authorizationCachingEnabled&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;successUrl&quot; value=&quot;/success&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;!--登录页面--&gt;</span><br><span class="line">        &lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot;&gt;&lt;/property&gt; </span><br><span class="line">        &lt;property name=&quot;filterChainDefinitions&quot;&gt;</span><br><span class="line">            &lt;value&gt;</span><br><span class="line">                &lt;!--配置`/home`只有拥有`admin`角色的用户才可以访问--&gt;</span><br><span class="line">                /home = authc,roles[admin]</span><br><span class="line">            &lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p><strong>这里需要注意的是 在配置Realm的时候，如果没用上缓存功能的话，需要将缓存关掉，不然进不到doGetAuthorizationInfo授权方法。</strong></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>打开<code>http://localhost:8080/login</code>登录页面，填写正确用户名和密码登录<br><img src="https://wx1.sinaimg.cn/large/e0e01e43gy1fzsitjvdxnj20hw04eweh.jpg" alt="image"><br>登录成功 转跳成功页面<br><img src="https://wx4.sinaimg.cn/large/e0e01e43gy1fzsiufh2cqj20cj04nmx5.jpg" alt="image"><br>清除浏览器cookie之后（未登录状态），打开<code>http://localhost:8080/home</code>页面，自动转跳到了<code>/login</code>登录页面（即没有权限访问），登录账户，再次打开<code>http://localhost:8080/home</code>页面即可正常访问。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是我学习Shiro时候根据自己的情况记录下来的，希望对大家有所帮助，如果大家想对Shiro进一步研究的话，推荐大家看张开涛老师的<a href="https://jinnianshilongnian.iteye.com/blog/2018936" target="_blank" rel="noopener">《跟我学Shiro》</a>，最后附上本项目的Github地址：<a href="https://github.com/xue8/Java-Demo/tree/master/shiro" target="_blank" rel="noopener">https://github.com/xue8/Java-Demo/tree/master/shiro</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/e0e01e43gy1fzsdwjowogj21rf0p0tc4.jpg&quot; style=&quot;width: 100%&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Apache Shiro 是Java的&lt;strong&gt;安全框架&lt;/strong&gt;，提供了认证（Authentication）、授权（Authorization）、会话（Session）管理、加密（Cryptography）等功能，且Shiro与Spring Security等安全框架相比具有简单性、灵活性、支持细粒度鉴权、支持一级缓存等，&lt;strong&gt;还有Shiro不跟任何容器（Tomcat等）和框架（Sping等）捆绑，可以独立运行，这也造就了Shiro不仅仅是可以用在Java EE上还可以用在Java SE上&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Shiro" scheme="http://ddnd.cn/categories/Shiro/"/>
    
    
      <category term="Mybatis" scheme="http://ddnd.cn/tags/Mybatis/"/>
    
      <category term="Spring MVC" scheme="http://ddnd.cn/tags/Spring-MVC/"/>
    
  </entry>
  
  <entry>
    <title>Shiro身份验证抛出AuthenticationException异常，解决方案</title>
    <link href="http://ddnd.cn/2019/02/01/shiro-password-char-authenticationexception/"/>
    <id>http://ddnd.cn/2019/02/01/shiro-password-char-authenticationexception/</id>
    <published>2019-02-01T13:43:35.000Z</published>
    <updated>2019-03-12T10:14:51.471Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://wx4.sinaimg.cn/large/e0e01e43gy1fzrauea0ruj20zy0ije81.jpg" alt="image" width="100%"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在学习Shiro的时候，遇到Shiro抛出<code>org.apache.shiro.authc.AuthenticationException</code>异常，完整异常如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.shiro.authc.AuthenticationException: Authentication failed for token submission [org.apache.shiro.authc.UsernamePasswordToken - xue8, rememberMe=false].  Possible unexpected error? (Typical or expected login exceptions should extend from AuthenticationException).</span><br></pre></td></tr></table></figure></p><p>出现这个异常的原因是因为身份验证出错了，但是我觉得我写的Realm应该没什么错误，最后折腾了一会，翻看了一下Shiro的一些源码，终于知道出现这个问题的原因了，于是想将过程记录下来。</p><a id="more"></a><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>我在<code>Realm</code>的身份证验证方法<code>doGetAuthenticationInfo</code>添加断点进行调试<br><img src="https://wx2.sinaimg.cn/large/e0e01e43gy1fzr9zjkpi0j21570kx780.jpg" alt="image"><br>发现是从<code>authenticationToken</code>获取用户<strong>密码</strong><code>getCredentials()</code>的时候出问题了，这就奇怪了，获取<strong>用户名</strong><code>getPrincipal()</code>的时候没问题，而且通过查看<code>authenticationToken</code>的源码，发现他们两个是一样的东西<br><img src="https://ws2.sinaimg.cn/large/e0e01e43gy1fzra4sam76j20pf058t91.jpg" alt="image"><br><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fzra5254joj20k5080aai.jpg" alt="image"><br>用户名和密码传给<code>doGetAuthenticationInfo</code>的时候都是成功的，那为什么会出错呢？在调试<code>doGetAuthenticationInfo</code>的时候，发现了username和password的储存方式不一样<br><img src="https://wx2.sinaimg.cn/large/e0e01e43gy1fzra90e7cyj20t606rt97.jpg" alt="image"><br>username是以字符串String的类型储存的，而password是以字符数组char[]类型储存的，那会不会是因为这个问题造成的呢，而且在<code>subject.login(token)</code>方法中，用户名和密码都是以字符串String储存在token中的，<br><img src="https://wx3.sinaimg.cn/large/e0e01e43gy1fzrad1250gj21150cdq4g.jpg" alt="image"><br>为什么到了<code>doGetAuthenticationInfo</code>就变了呢，于是我继续查看了<code>UsernamePasswordToken</code>的源码，会不会是因为这个对象将密码的字符串类型转成char[]类型呢<br><img src="https://wx1.sinaimg.cn/large/e0e01e43gy1fzrafmoin6j215j040gm6.jpg" alt="image"><br>通过查看源码，看到了确实是<code>UsernamePasswordToken</code>将传入的密码password从String字符串类型转成了char[]字符数组类型，到这里我也就明白了，在<code>Realm</code>的<code>doGetAuthenticationInfo</code>方法中，传入的<code>AuthenticationToken authenticationToken</code>用户名是以String方式储存的而密码是以Char[]储存的，用接收String的方式去接收Char[]类型数据肯定就不行了呢，所以我将密码改成用Char[]接收，如下<br><img src="https://wx3.sinaimg.cn/large/e0e01e43gy1fzralszlo4j214w0ermzw.jpg" alt="image"></p><p>即可解决问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://wx4.sinaimg.cn/large/e0e01e43gy1fzrauea0ruj20zy0ije81.jpg&quot; alt=&quot;image&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;在学习Shiro的时候，遇到Shiro抛出&lt;code&gt;org.apache.shiro.authc.AuthenticationException&lt;/code&gt;异常，完整异常如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;org.apache.shiro.authc.AuthenticationException: Authentication failed for token submission [org.apache.shiro.authc.UsernamePasswordToken - xue8, rememberMe=false].  Possible unexpected error? (Typical or expected login exceptions should extend from AuthenticationException).&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;出现这个异常的原因是因为身份验证出错了，但是我觉得我写的Realm应该没什么错误，最后折腾了一会，翻看了一下Shiro的一些源码，终于知道出现这个问题的原因了，于是想将过程记录下来。&lt;/p&gt;
    
    </summary>
    
      <category term="Shiro" scheme="http://ddnd.cn/categories/Shiro/"/>
    
    
      <category term="Shiro" scheme="http://ddnd.cn/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>Shiro抛出异常UnavailableSecurityManagerException</title>
    <link href="http://ddnd.cn/2019/02/01/shiro-unavailablesecuritymanagerexception/"/>
    <id>http://ddnd.cn/2019/02/01/shiro-unavailablesecuritymanagerexception/</id>
    <published>2019-02-01T11:20:05.000Z</published>
    <updated>2019-03-12T10:14:54.313Z</updated>
    
    <content type="html"><![CDATA[<p>Shiro报错<code>org.apache.shiro.UnavailableSecurityManagerException: No SecurityManager accessible to the calling code, either bound to the org.apache.shiro.util.ThreadContext or as a vm static singleton.  This is an invalid application configuration.</code>。<br>解决方法，修改<code>web.xml</code>的filter，将<code>&lt;url-pattern&gt;/&lt;/url-pattern&gt;</code>改成<code>&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</code>，即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">&lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;</span><br><span class="line">&lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">&lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Shiro报错&lt;code&gt;org.apache.shiro.UnavailableSecurityManagerException: No SecurityManager accessible to the calling code, either bound to the
      
    
    </summary>
    
      <category term="Shiro" scheme="http://ddnd.cn/categories/Shiro/"/>
    
    
      <category term="Shiro" scheme="http://ddnd.cn/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>Spring+Tomcat+WebSocket教程 附源码</title>
    <link href="http://ddnd.cn/2019/01/19/spring-websocket/"/>
    <id>http://ddnd.cn/2019/01/19/spring-websocket/</id>
    <published>2019-01-19T11:53:29.000Z</published>
    <updated>2019-03-12T10:15:48.648Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://wx4.sinaimg.cn/mw690/0060lm7Tly1fzc67i7oooj30b404cgll.jpg" style="width: 100%"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们知道<code>HTTP</code>协议是无状态、无连接的，采用的是请求/响应模式，通信请求只能由客户端发起，服务器响应。这种请求/响应模式在客户端服务器需要持续的交互时候就显得很鸡肋，在HMTL5出来之前，要实现客户端服务器持续交互大多数都是通过AJAX轮询，但是轮询效率低，浪费带宽和服务器资源。因此WebSocket就发明出来了，WebSocket是HTML5提供的一种在单个TCP连接上进行全双工通信的协议。接下来我运用Spring和WebSocket实现一个简单的聊天功能，希望能对大家有帮助。</p><a id="more"></a><h1 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h1><p><img src="https://ws3.sinaimg.cn/large/e0e01e43gy1fzcz2qqu1oj20c10ojabh.jpg" alt="image"></p><h1 id="添加依赖包"><a href="#添加依赖包" class="headerlink" title="添加依赖包"></a>添加依赖包</h1><p>pom.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;groupId&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;nChat&lt;/artifactId&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--Sping核心依赖--&gt;</span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-web --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context-support --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--Mybatis依赖--&gt;</span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.4.6&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-messaging --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-messaging&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-websocket --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-websocket&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.2.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--MySQL连接驱动--&gt;</span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;8.0.13&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.0.1&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p><h1 id="WebSocket实现"><a href="#WebSocket实现" class="headerlink" title="WebSocket实现"></a>WebSocket实现</h1><p>Java实现WebSocket的方式很多，不同厂商实现WebSocket的方式大径相同。</p><h2 id="Spring实现WebSocket"><a href="#Spring实现WebSocket" class="headerlink" title="Spring实现WebSocket"></a>Spring实现WebSocket</h2><p>Spring实现WebSocket，需要先添加Spring的对WebSocket支持的依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-messaging --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-messaging&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-websocket --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-websocket&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.2.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>在Java中导入Spring WebSocket的包<code>import org.springframework.web.socket.*;</code>，Spring实现WebSocket需要编写以下几项。</p><ol><li>配置WebSocket<br>配置WebSocket的方式有2中，一种是编写配置类，另一种是编写配置文件（XML文件），配置WebSocket的作用是将WebSocket处理器、拦截器添加到注册中心，这里我使用的是配置类来配置。<br>WebSocketConfig.java<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.nChat.websocket;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line">import org.springframework.web.socket.config.annotation.EnableWebSocket;</span><br><span class="line">import org.springframework.web.socket.config.annotation.WebSocketConfigurer;</span><br><span class="line">import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">@EnableWebSocket</span><br><span class="line">public class WebSocketConfig implements WebSocketConfigurer &#123;</span><br><span class="line">    public void registerWebSocketHandlers(WebSocketHandlerRegistry webSocketHandlerRegistry) &#123;</span><br><span class="line">        //这个网址是用于websocket连接的建立 通信用的</span><br><span class="line">        webSocketHandlerRegistry</span><br><span class="line">                .addHandler(new WebSocketHandler(), &quot;/ws/socketServer&quot;)</span><br><span class="line">                .addInterceptors(new WebSocketInterceptor())</span><br><span class="line">                .setAllowedOrigins(&quot;*&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>三个注解的作用如下</p><ul><li>@Configuration注解：声明这个类为配置类（相当于web.xml配置文件中的<beans>）配置Spring容器应用上下文，即项目启动的时候会加载这个配置类。</beans></li><li>@EnableWebMvc注解：开启Spring MVC，不加这个的话，在Controller的RequestMapping就失效，我也不知道为啥。</li><li>@EnableWebSocket注解：开启WebSocket服务。<br><code>registerWebSocketHandlers</code>方法配置WebSocket入口、允许访问的域，注册WebSocket处理器、拦截器等，当请求访问<code>/ws/socketServer</code>的时候，就会建立起WebSocket连接。</li></ul><ol start="2"><li>编写处理器<br>WebSocketHandler.java<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">package com.nChat.websocket;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.web.socket.*;</span><br><span class="line">import org.springframework.web.socket.handler.TextWebSocketHandler;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class WebSocketHandler extends TextWebSocketHandler &#123;</span><br><span class="line"></span><br><span class="line">    public static final Map&lt;Integer,WebSocketSession&gt; USER_SOCKET_SESSION_MAP;</span><br><span class="line">    static&#123;</span><br><span class="line">            USER_SOCKET_SESSION_MAP = new HashMap&lt;Integer, WebSocketSession&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterConnectionEstablished(WebSocketSession session) throws Exception &#123;</span><br><span class="line">        int uid = Integer.parseInt(session.getAttributes().get(&quot;WEBSOCKET_UID&quot;).toString());</span><br><span class="line">        //如果是新的用户连接 则将session保存在USER_SOCKET_SESSION_MAP中</span><br><span class="line">        if (USER_SOCKET_SESSION_MAP.get(uid) == null || !USER_SOCKET_SESSION_MAP.get(uid).isOpen()) &#123;</span><br><span class="line">            USER_SOCKET_SESSION_MAP.put(uid, session);</span><br><span class="line">        &#125;</span><br><span class="line">        super.afterConnectionEstablished(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(WebSocketSession session, WebSocketMessage&lt;?&gt; message) throws Exception &#123;</span><br><span class="line">        super.handleMessage(session, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception &#123;</span><br><span class="line">        super.handleTextMessage(session, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void handlePongMessage(WebSocketSession session, PongMessage message) throws Exception &#123;</span><br><span class="line">        super.handlePongMessage(session, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception &#123;</span><br><span class="line">        super.handleTransportError(session, exception);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception &#123;</span><br><span class="line">        super.afterConnectionClosed(session, status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean supportsPartialMessages() &#123;</span><br><span class="line">        return super.supportsPartialMessages();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @description: 给指定用户发送信息</span><br><span class="line">     * @param: [uid, message]</span><br><span class="line">     * @return: void</span><br><span class="line">     * @author: Xue 8</span><br><span class="line">     * @date: 2019/1/19</span><br><span class="line">     */</span><br><span class="line">    public void sendMessageToUser(int uid, TextMessage message)&#123;</span><br><span class="line">        WebSocketSession session = USER_SOCKET_SESSION_MAP.get(uid);</span><br><span class="line">        if (session != null &amp;&amp; session.isOpen()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                session.sendMessage(message);</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>WebSocket处理器继承<code>TextWebSocketHandler</code>（或<code>BinaryWebSocketHandler</code>），在这里重写相应的方法和编写自己的业务代码，Spring在收到WebSocket事件时，就会调用相事件相应的方法，这里我自定义了一个发送信息给指定用户的方法<code>sendMessageToUser</code>。<code>WebSocketSession</code>是WebSocket的抽象，WebSocketSession就像是连接服务器和客户端之间的一条专属通道，一个WebSocketSession对应一个用户，WebSocket的操作都是基于这个WebSocketSession进行的。</p><ol start="3"><li>编写拦截器<br>WebSocketInterceptor.java<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">package com.nChat.websocket;</span><br><span class="line"></span><br><span class="line">import org.springframework.http.server.ServerHttpRequest;</span><br><span class="line">import org.springframework.http.server.ServerHttpResponse;</span><br><span class="line">import org.springframework.http.server.ServletServerHttpRequest;</span><br><span class="line">import org.springframework.web.socket.WebSocketHandler;</span><br><span class="line">import org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor;</span><br><span class="line"></span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class WebSocketInterceptor extends HttpSessionHandshakeInterceptor &#123;</span><br><span class="line">    public WebSocketInterceptor() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public WebSocketInterceptor(Collection&lt;String&gt; attributeNames) &#123;</span><br><span class="line">        super(attributeNames);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Collection&lt;String&gt; getAttributeNames() &#123;</span><br><span class="line">        return super.getAttributeNames();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setCopyAllAttributes(boolean copyAllAttributes) &#123;</span><br><span class="line">        super.setCopyAllAttributes(copyAllAttributes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isCopyAllAttributes() &#123;</span><br><span class="line">        return super.isCopyAllAttributes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setCopyHttpSessionId(boolean copyHttpSessionId) &#123;</span><br><span class="line">        super.setCopyHttpSessionId(copyHttpSessionId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isCopyHttpSessionId() &#123;</span><br><span class="line">        return super.isCopyHttpSessionId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setCreateSession(boolean createSession) &#123;</span><br><span class="line">        super.setCreateSession(createSession);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isCreateSession() &#123;</span><br><span class="line">        return super.isCreateSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes) throws Exception &#123;</span><br><span class="line">        ServletServerHttpRequest servletServerHttpRequest = (ServletServerHttpRequest) request;</span><br><span class="line">        int uid = Integer.parseInt(servletServerHttpRequest.getServletRequest().getParameter(&quot;uid&quot;));</span><br><span class="line">        System.out.println(&quot;coming &quot; + uid);</span><br><span class="line">        if (uid != 0) &#123;</span><br><span class="line">            //在这里拦截请求 在捂手前将uid保存到WebSocketSession中 让处理器WebSocketHandler根据这个uid进行操作</span><br><span class="line">            attributes.put(&quot;WEBSOCKET_UID&quot;, uid);</span><br><span class="line">        &#125;</span><br><span class="line">        return super.beforeHandshake(request, response, wsHandler, attributes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Exception ex) &#123;</span><br><span class="line">        System.out.println(&quot;out&quot;);</span><br><span class="line">        super.afterHandshake(request, response, wsHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>WebSocket拦截器继承<code>HttpSessionHandshakeInterceptor</code>，在握手前后对请求进行拦截，在握手前将请求拦截，也就是当请求访问<code>/ws/socketServer</code>的时候，会对请求拦截，可以获取到请求中的URL参数、请求头、协议等信息，然后将这些信息保存在WebSocketSession中，将用户和WebSocketSession关联起来。</p><ol start="4"><li>编写Spring MVC控制器<br>IndexController.java<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package com.nChat.controller;</span><br><span class="line"></span><br><span class="line">import com.nChat.websocket.WebSocketHandler;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line">import org.springframework.web.socket.TextMessage;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class IndexController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    WebSocketHandler webSocketHandler;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/send&quot;)</span><br><span class="line">    public String send(HttpServletRequest request,</span><br><span class="line">                        HttpServletResponse response)&#123;</span><br><span class="line">        return &quot;send&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/doSend&quot;)</span><br><span class="line">    public String doSend(HttpServletRequest request,</span><br><span class="line">                       HttpServletResponse response,</span><br><span class="line">                       @RequestParam(value = &quot;uid&quot;) int uid,</span><br><span class="line">                       @RequestParam(value = &quot;messages&quot;) String messages)&#123;</span><br><span class="line"></span><br><span class="line">        HttpSession session = request.getSession(true);</span><br><span class="line">        session.setAttribute(&quot;SESSION_USERNAME&quot;, uid);</span><br><span class="line">        webSocketHandler.sendMessageToUser(uid,new TextMessage(messages));</span><br><span class="line">        return &quot;send&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/register&quot;)</span><br><span class="line">    public String register(HttpServletRequest request,</span><br><span class="line">                        HttpServletResponse response)&#123;</span><br><span class="line"></span><br><span class="line">        return &quot;register&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>注意这里的<code>@RequestMapping</code>和WebSocket配置类中的<code>/ws/socketServer</code>区别，配置类中的<code>/ws/socketServer</code>是用于客户端和服务器建立WebSocket连接用的，而Controller的<code>@RequestMapping</code>是用于处理客户端请求用的。</p><ol start="4"><li>编写前端 测试WebSocket的建立和发信息<br>用于新建WebSocket连接，其中用UID来表示WebSocket连接<br>register.jsp<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot;</span><br><span class="line">         pageEncoding=&quot;utf-8&quot;%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;register&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.bootcss.com/jquery/3.1.0/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.bootcss.com/sockjs-client/1.1.1/sockjs.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/reconnecting-websocket/1.0.0/reconnecting-websocket.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var websocket = null;</span><br><span class="line">    function createWebSocket() &#123;</span><br><span class="line">        if (&apos;WebSocket&apos; in window) &#123;</span><br><span class="line">            websocket = new WebSocket(&quot;ws://localhost:8080/ws/socketServer?uid=&quot; + $(&quot;#uid&quot;).val());</span><br><span class="line">            console.log($(&quot;#uid&quot;).val())</span><br><span class="line">        &#125;</span><br><span class="line">        else if (&apos;MozWebSocket&apos; in window) &#123;</span><br><span class="line">            websocket = new MozWebSocket(&quot;ws://localhost:8080/ws/socketServer?uid=&quot; + $(&quot;#uid&quot;).val());</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            websocket = new SockJS(&quot;http://localhost:8080/ws/socketServer?uid=&quot; + $(&quot;#uid&quot;).val());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        websocket.onopen = onOpen;</span><br><span class="line">        websocket.onmessage = onMessage;</span><br><span class="line">        websocket.onerror = onError;</span><br><span class="line">        websocket.onclose = onClose;</span><br><span class="line"></span><br><span class="line">        function onOpen(openEvt) &#123;</span><br><span class="line">            //alert(openEvt.Data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function onMessage(evt) &#123;</span><br><span class="line">            alert(evt.data);</span><br><span class="line">        &#125;</span><br><span class="line">        function onError() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        function onClose() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        window.close=function()</span><br><span class="line">        &#123;</span><br><span class="line">            websocket.onclose();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">请输入UID：&lt;input rows=&quot;5&quot; cols=&quot;10&quot; id=&quot;uid&quot; name=&quot;uid&quot;&gt;&lt;/input&gt;</span><br><span class="line">&lt;button onclick=&quot;createWebSocket();&quot;&gt;建立WS连接&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ol><p>用于发信息的页面，根据UID进行信息的发送<br>send.jsp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot;</span><br><span class="line">         pageEncoding=&quot;utf-8&quot;%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;send messages&lt;/h2&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;form action=&quot;/doSend&quot;&gt;</span><br><span class="line">  发送给谁：&lt;input type=&quot;text&quot; name=&quot;uid&quot;/&gt;</span><br><span class="line">  发送什么信息：&lt;input type=&quot;text&quot; name=&quot;messages&quot;/&gt;</span><br><span class="line">  &lt;input type=&quot;submit&quot; value=&quot;发送&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><ol start="5"><li>运行测试<br>分别建立UID为1、2的WebSocket连接。<br><img src="https://wx1.sinaimg.cn/large/e0e01e43gy1fzd4b56oarj20qd0773yt.jpg" alt="image"><br><img src="https://ws3.sinaimg.cn/large/e0e01e43gy1fzd4b56oarj20qd0773yt.jpg" alt="image"></li></ol><p>给UID为1的WebSocket发送信息<br><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fzd4dc1dkcj20r007j0t9.jpg" alt="image"><br><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fzd4djtrshj211y0bpjs1.jpg" alt="image"></p><p>给UID为2的WebSocket发送信息<br><img src="https://ws2.sinaimg.cn/large/e0e01e43gy1fzd4ebmmt7j20se098aan.jpg" alt="image"><br><img src="https://wx1.sinaimg.cn/large/e0e01e43gy1fzd4egz9i7j210509vgmb.jpg" alt="image"></p><h2 id="Tomcat实现WebSocket"><a href="#Tomcat实现WebSocket" class="headerlink" title="Tomcat实现WebSocket"></a>Tomcat实现WebSocket</h2><p>使用Tomcat实现WebSocket没有像Spring实现WebSocket那样繁琐，只需要编写一个处理器即可。<br>首先添加依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/javax.websocket/javax.websocket-api --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.websocket&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.websocket-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>然后编写处理类即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.nChat;</span><br><span class="line">  </span><br><span class="line">import java.io.IOException;  </span><br><span class="line">import java.util.Map;  </span><br><span class="line">import java.util.concurrent.ConcurrentHashMap;  </span><br><span class="line">import javax.websocket.*;  </span><br><span class="line">import javax.websocket.server.PathParam;  </span><br><span class="line">import javax.websocket.server.ServerEndpoint;  </span><br><span class="line">import net.sf.json.JSONObject;  </span><br><span class="line">  </span><br><span class="line">@ServerEndpoint(&quot;/websocket/&#123;username&#125;&quot;)  </span><br><span class="line">public class WebSocket &#123;  </span><br><span class="line">  </span><br><span class="line">    private static int onlineCount = 0;  </span><br><span class="line">    private static Map&lt;String, WebSocket&gt; clients = new ConcurrentHashMap&lt;String, WebSocket&gt;();  </span><br><span class="line">    private Session session;  </span><br><span class="line">    private String username;  </span><br><span class="line">      </span><br><span class="line">    @OnOpen  </span><br><span class="line">    public void onOpen(@PathParam(&quot;username&quot;) String username, Session session) throws IOException &#123;  </span><br><span class="line">  </span><br><span class="line">        this.username = username;  </span><br><span class="line">        this.session = session;  </span><br><span class="line">          </span><br><span class="line">        addOnlineCount();  </span><br><span class="line">        clients.put(username, this);  </span><br><span class="line">        System.out.println(&quot;已连接&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @OnClose  </span><br><span class="line">    public void onClose() throws IOException &#123;  </span><br><span class="line">        clients.remove(username);  </span><br><span class="line">        subOnlineCount();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @OnMessage  </span><br><span class="line">    public void onMessage(String message) throws IOException &#123;  </span><br><span class="line">  </span><br><span class="line">        JSONObject jsonTo = JSONObject.fromObject(message);  </span><br><span class="line">          </span><br><span class="line">        if (!jsonTo.get(&quot;To&quot;).equals(&quot;All&quot;))&#123;  </span><br><span class="line">            sendMessageTo(&quot;给一个人&quot;, jsonTo.get(&quot;To&quot;).toString());  </span><br><span class="line">        &#125;else&#123;  </span><br><span class="line">            sendMessageAll(&quot;给所有人&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @OnError  </span><br><span class="line">    public void onError(Session session, Throwable error) &#123;  </span><br><span class="line">        error.printStackTrace();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public void sendMessageTo(String message, String To) throws IOException &#123;  </span><br><span class="line">        // session.getBasicRemote().sendText(message);  </span><br><span class="line">        //session.getAsyncRemote().sendText(message);  </span><br><span class="line">        for (WebSocket item : clients.values()) &#123;  </span><br><span class="line">            if (item.username.equals(To) )  </span><br><span class="line">                item.session.getAsyncRemote().sendText(message);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public void sendMessageAll(String message) throws IOException &#123;  </span><br><span class="line">        for (WebSocket item : clients.values()) &#123;  </span><br><span class="line">            item.session.getAsyncRemote().sendText(message);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">  </span><br><span class="line">    public static synchronized int getOnlineCount() &#123;  </span><br><span class="line">        return onlineCount;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public static synchronized void addOnlineCount() &#123;  </span><br><span class="line">        WebSocket.onlineCount++;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public static synchronized void subOnlineCount() &#123;  </span><br><span class="line">        WebSocket.onlineCount--;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public static synchronized Map&lt;String, WebSocket&gt; getClients() &#123;  </span><br><span class="line">        return clients;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Jetty实现WebSocket"><a href="#Jetty实现WebSocket" class="headerlink" title="Jetty实现WebSocket"></a>Jetty实现WebSocket</h2><p>这个好像不常见…这里就不演示如何配置了，有兴趣可以网上搜相关文章。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>WebSocket是HTML5提供的一种在单个TCP连接进行的全双工通讯协议，不用的厂商都可以根据WebSocket API去实现自己的WebSocket框架，比如Spring的WebSocket、Tomcat的WebSocket，我觉得WebSocket和Spring的WebSocket、Tomcat的WebSocket的关系就像JPA和hibernate、Mybatis的关系一样，WebSocket和JPA都是定义了标准，而由各个厂商根据这个标准去实现自己的框架。</p><p>完整源代码：<a href="https://github.com/xue8/Java-Demo/tree/master/nChat" target="_blank" rel="noopener">https://github.com/xue8/Java-Demo/tree/master/nChat</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://wx4.sinaimg.cn/mw690/0060lm7Tly1fzc67i7oooj30b404cgll.jpg&quot; style=&quot;width: 100%&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们知道&lt;code&gt;HTTP&lt;/code&gt;协议是无状态、无连接的，采用的是请求/响应模式，通信请求只能由客户端发起，服务器响应。这种请求/响应模式在客户端服务器需要持续的交互时候就显得很鸡肋，在HMTL5出来之前，要实现客户端服务器持续交互大多数都是通过AJAX轮询，但是轮询效率低，浪费带宽和服务器资源。因此WebSocket就发明出来了，WebSocket是HTML5提供的一种在单个TCP连接上进行全双工通信的协议。接下来我运用Spring和WebSocket实现一个简单的聊天功能，希望能对大家有帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://ddnd.cn/categories/Spring-Programming/"/>
    
    
      <category term="WebSocket" scheme="http://ddnd.cn/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>我是如何一步步解决问题 让Spring MVC返回HTML类型的视图</title>
    <link href="http://ddnd.cn/2018/12/25/springmvc-view-webxml/"/>
    <id>http://ddnd.cn/2018/12/25/springmvc-view-webxml/</id>
    <published>2018-12-25T10:09:29.000Z</published>
    <updated>2019-03-12T10:15:39.236Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fyi08g83uwj20jd05hmxe.jpg" style="width: 100%"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这两天在折腾SSM，在捣鼓<code>Spring MVC</code>的时候，我想让Spring MVC的前端控制器（<code>DispatcherServlet</code>）给用户返回的是HTML类型的视图而不是JSP类型的视图，于是我按照常规的思路，把<code>Spring MVC</code>配置文件里面的视图解析器配置修改成HTML后缀的，然后就遇上了各种问题了……当然这些问题也都是我对Spring MVC不够了解才导致的，接下来详细说一下我遇到的问题以及解决过程。</p><a id="more"></a><h1 id="遇上问题"><a href="#遇上问题" class="headerlink" title="遇上问题"></a>遇上问题</h1><p>为了将返回给用户的视图从<code>JSP</code>改成<code>HTML</code>嘛，我就寻思着不就是把<code>Spring MVC</code>配置文件的视图配置改一下，把<code>.jsp</code>改成<code>.html</code>嘛。<br><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fyi32ct15hj20ug06qdgc.jpg" alt=""></p><p>原来返回JSP的配置 Spring-MVC.xml：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;prefix&quot; value=&quot;&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>因为我的JSP文件就是放在<code>web</code>根目录下，所以这里<code>prefix</code>就留空了。</p><p>修改成返回HTML的配置 Spring-MVC.xml：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;prefix&quot; value=&quot;&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;suffix&quot; value=&quot;.html&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>然后写<code>Controller</code>将视图返回给前端控制器<code>DispatchServlet</code>看看能不能将HTML类型的视图返回给用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.nChat.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;/login&quot;)</span><br><span class="line">    public String login()&#123;</span><br><span class="line">        return &quot;/register&quot;;  //返回web根目录下的register.html</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>emmmm配置文件修改好了，按照我的想法，运行肯定没“问题”吧，可现实总是打我脸…可能是我太年轻了吧，运行之后报错，页面显示404<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">24-Dec-2018 21:57:35.769 警告 [http-nio-8080-exec-3] org.springframework.web.servlet.DispatcherServlet.noHandlerFound No mapping for GET /</span><br><span class="line">24-Dec-2018 21:57:35.778 警告 [http-nio-8080-exec-2] org.springframework.web.servlet.DispatcherServlet.noHandlerFound No mapping for GET /</span><br><span class="line">24-Dec-2018 21:57:35.854 警告 [http-nio-8080-exec-1] org.springframework.web.servlet.DispatcherServlet.noHandlerFound No mapping for GET /</span><br><span class="line">24-Dec-2018 21:57:38.542 警告 [http-nio-8080-exec-4] org.springframework.web.servlet.DispatcherServlet.noHandlerFound No mapping for GET /register.html</span><br></pre></td></tr></table></figure></p><p>错误的意思大概是前端控制器<code>DispatchServlet</code>找不到<strong>请求</strong>相对应的<code>mapping</code>，所以抛出<code>noHandlerFound</code>的异常<br><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fyi704yuqaj20h807kq2w.jpg" alt=""></p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>我们来分析看看为啥出现这个问题，首先贴出我们前端控制器<code>DispatchServlet</code>的工作流程先<br><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fyi7aoqiz7j20w70mbdk1.jpg" alt=""><br>流程用文字说明大概如下：</p><ol><li>用户发送请求，被 SpringMVC 的<strong>前端控制器</strong><code>DispatcherServlet</code> 拦截。</li><li>DispatcherServlet 收到请求后自己不进行处理，而是将请求转发给<strong>处理器映射器</strong><code>HandlerMapping</code>。</li><li><strong>处理器映射器</strong>根据请求的URL确定映射关系找出相应的<strong>处理器适配器</strong>，并且返回HandlerExecutionChain对象给前端控制器。<br>处理器映射器找到具体的<strong>处理器适配器</strong>，生成处理器对象及处理器拦截器（如果有则生成）一并返回给 DispatcherServlet。</li><li>DispatcherServlet根据3返回的<code>HandlerExecutionChain</code> 调用相应的<strong>处理器适配器</strong><code>HandlerAdapter</code>。</li><li>经过<strong>处理器适配器</strong><code>HandlerAdapter</code>调用具体的处理器（<code>Controller</code>，也叫后端控制器）。</li><li>Controller将结果封装到ModelAndView返回给HandlerAdapter。</li><li>HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet。</li><li>DispatcherServlet将ModelAndView传给<strong>视图解析器</strong><code>ViewReslover</code>,查询到相应的视图View。</li><li>ViewReslover解析后返回具体的View。</li><li>DispatcherServlet把Model交给View进行渲染（即将模型数据填充至视图中）。</li><li>DispatcherServlet响应用户。</li></ol><p>看完整个流程是不是知道问题出在哪了？？<code>org.springframework.web.servlet.DispatcherServlet.noHandlerFound No mapping for GET /</code>这个报错是出在了流程的第<code>3</code>步中，也就是<code>DispatchServlet</code>将请求转发给<code>HandlerMapping</code>后，<code>HandlerMapping</code>根据用户的请求<strong>找不到相应处理器映射器</strong>，所以就报了这个错误。那造成这个问题的原因会不会是我们没定义相应的<code>Controller</code>,导致也没有相应的处理器适配器，但是我们的<code>Controller</code>确实已经写好了，而且用返回JSP类型视图的代码测试数是正常的，没任何问题。</p><p>那我们一步步排错，我们在<code>Controller</code>中打印输出个字符，判断看看请求有没有进<code>Controller</code>先<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/login&quot;)</span><br><span class="line">public String login()&#123;</span><br><span class="line">    System.out.println(&quot;coming&quot;);</span><br><span class="line">    return &quot;/register&quot;;  //返回web根目录下的register.html</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简单粗暴，添加个<code>System.out.println(&quot;coming&quot;);</code>如果请求进来了我们就可以看到打印<code>coming</code>的内容，我们再重新运行项目测试看看<br><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fyi8trsxpcj218b08175h.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">coming</span><br><span class="line">24-Dec-2018 23:07:38.974 警告 [http-nio-8080-exec-4] org.springframework.web.servlet.DispatcherServlet.noHandlerFound No mapping for GET /register.html</span><br></pre></td></tr></table></figure></p><p>我们可以看到确实进来了，既然进来了，也就是说<strong>用户的请求</strong>至少已经执行到第<code>5</code>步了，那和前面说错误出现在第<code>3</code>步不是矛盾了吗？？莫急，继续往下分析，既然肯定用户的请求前<code>5</code>步都没问题的，那打印完<code>coming</code>后为什么又出现了本该出现在第<code>2</code>的错误呢？<code>org.springframework.web.servlet.DispatcherServlet.noHandlerFound No mapping for GET /register.html</code>，莫不是从第<code>5</code>步又跳到第<code>2</code>步了？</p><p>为了继续排查下去，我们继续添加个<code>Controller</code>对应<code>register.html</code>,看看他还报错不<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;/login&quot;)</span><br><span class="line">    public String login()&#123;</span><br><span class="line">        System.out.println(&quot;coming&quot;);</span><br><span class="line">        return &quot;/register&quot;;  //返回web根目录下的register.html</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;/register.html&quot;)</span><br><span class="line">    public String  aa()&#123;</span><br><span class="line">        System.out.println(&quot;coming aa&quot;);</span><br><span class="line">        return &quot;/aa&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重新启动项目运行看看，输出如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">coming</span><br><span class="line">coming aa</span><br><span class="line">24-Dec-2018 23:29:00.759 警告 [http-nio-8080-exec-4] org.springframework.web.servlet.DispatcherServlet.noHandlerFound No mapping for GET /aa.html</span><br></pre></td></tr></table></figure></p><p>输出表明既进到了<code>/login</code>又进到了<code>/register.html</code>,然而还是继续报错<code>org.springframework.web.servlet.DispatcherServlet.noHandlerFound No mapping for GET /aa.html</code>，一样的错误但是造成的错误原因不一样，上面的错误是因为找不到<code>/register.html</code>相应的mapping，然后我们把<code>/register.html</code>的Controller加上并且返回<code>/aa.html</code>，所以导致了这次错误找不到<code>/aa.html</code>相应的mapping。<br>看到这里是不是有点头绪了？我们在<code>Controller</code>返回<code>ModelAndView</code>给<code>HandlerAdapter</code>，<code>HandlerAdapter</code>再把<code>ModelAndView</code>返回给<code>DispatchServlet</code>，然后<code>DispatchServlet</code>再把<code>ModelAndView</code>传给视图解析器<code>ViewReslover</code>解析，也就是图中对应的第<code>6</code>到第<code>8</code>步，到这里之前都是没问题的，问题就出现在了第<code>9</code>步身上了，<code>ViewReslover</code>返回的视图名给<code>DispatchServlet</code>，<strong>重点来了!!!! <code>DispatchServlet</code>又把这个视图名当做一个新的请求，去交给<code>HandlerMapping</code>处理！！也就是图中的第<code>2</code>步，然后无限死循环下去……</strong><br><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fyixffzt07j216q0h1n3z.jpg" alt=""></p><h1 id="遇上新问题"><a href="#遇上新问题" class="headerlink" title="遇上新问题"></a>遇上新问题</h1><p>那问题又来了，为什么<code>DispatchServlet</code>会把它当成一个新的请求去处理呢？是不是我们Servlet配置的匹配规则写的不对，把返回的视图也拦截上了？我们来看看我们的Servlet配置<br><strong>项目的web.xml</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;Spring-MVC&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;classpath:*.xml&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;Spring-MVC&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></p><p>匹配规则我写的是<code>/</code>，网上的很多文章也都说匹配规则<code>/</code>是不会拦截<code>.jsp、html</code>等格式的URL的，只会拦截<code>/login</code>这样的，而<code>/*</code>的匹配规则才会拦截所有请求包括<code>/login、.jsp、html</code>等，<strong>实践证明网上的这些观点都是错误的！</strong> 在这里我要更正一下，匹配规则<code>/</code>和<code>/*</code>都是会拦截所有请求（包括/login、.jsp、.html、.css等）也就是说他们俩的作用是一样的，既然说<code>.jsp、.html</code>都会拦截那为什么配置<code>/</code>规则的时候.jsp的能正常而.html的却被再次拦截导致死循环和配置<code>/*</code>不管是.jsp还是.html都再次被拦截从而进入死循环？</p><h1 id="拨开云雾见月明"><a href="#拨开云雾见月明" class="headerlink" title="拨开云雾见月明"></a>拨开云雾见月明</h1><p>既然配置<code>/</code>和<code>/*</code>的作用一样，为啥结果不一样呢？玄机就在<code>Tomcat</code>上，在<code>Tomcat</code>的<code>conf/</code>目录下，有个<code>web.xml</code>的文件。<br><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fyj0235488j20nd0bugn2.jpg" alt=""><br>这个<code>web.xml</code>在Tomcat启动的时候就被加载进来，对所有webapp都有效，至于Tomcat下的web.xml和我们自己项目下的web.xml的区别和联系请自行到<strong>参考文章</strong>查看。这里我们详细分析一下Tomcat下的web.xml里面有啥，打开<code>conf/web.xml</code>看到他里面定义了个<strong>拦截<code>.jsp</code>和<code>.jspx</code>的Servlet</strong><br><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fyj05hxdj0j20ud0irtak.jpg" alt=""><br><strong>Tomcat的conf/web.xml</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- The mappings for the JSP servlet --&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;</span><br><span class="line">    &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></p><p>这个拦截规则也就是把所有的<code>.jsp</code>、<code>.jspx</code> URL请求都拦截在<code>servlet-name</code>为jsp的servlet中，我们搜索<code>&lt;servlet-name&gt;jsp&lt;/servlet-name&gt;</code>查找一下servlet使用的类<br><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fyj09y1f5dj210x0hhdhy.jpg" alt=""><br><strong>Tomcat的conf/web.xml</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.apache.jasper.servlet.JspServlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;fork&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;false&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;xpoweredBy&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;false&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;load-on-startup&gt;3&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br></pre></td></tr></table></figure></p><p>可以看到这个拦截<code>.jsp</code>、<code>.jspx</code>的servlet使用的类是<code>org.apache.jasper.servlet.JspServlet</code>，也就是使用的类和我们项目下web.xml的servlet使用的<code>org.springframework.web.servlet.DispatcherServlet</code>类不一样，使用的类不一样也导致<code>.jsp</code>、<code>.jspx</code>的URL请求都不会走上图中DispatchServlet的流程，而是走它使用的类的具体流程，想了解的可以查询这个类的相关资料。到这里我们可以明确一点的就是我们项目下web.xml的servlet规则定义成<code>/</code>或者<code>/*</code>的时候<code>.jsp</code>正常来说应该是会被我们的项目下web.xml的servlet拦截的，但是根据servlet-mapping的匹配规则，<code>.jsp</code>、<code>.jspx</code>的URL都会先被Tomcat下web.xml里面的servlet拦截，而导致<code>.jsp</code>、<code>.jspx</code>不会被我们项目的web.xml里面的servlet拦截。<strong>这也就是为什么匹配规则写成<code>/</code>的时候<code>.jsp</code>会被忽略不进行拦截的原因，</strong>那问题又来了匹配规则写成<code>/*</code>的时候<code>.jsp</code>没有被忽略仍然进行拦截的呢？原因是规则<code>/*</code>会覆盖所有默认的servlet，从而将所有请求都拦截了下来<strong>，接下来我们可以修改Tomcat的web.xml下的servlet配置，让项目的web.xml下的servlet配置规则为<code>/</code>时候也支持返回<code>html</code>类型的视图</strong>Tomcat的conf/web.xml**<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- The mappings for the JSP servlet --&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;</span><br><span class="line">    &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;</span><br><span class="line">    &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></p><p>添加个规则<code>&lt;url-pattern&gt;*.html&lt;/url-pattern&gt;</code>，即URL是.html类型的话就走Tomcat的<code>&lt;servlet-name&gt;jsp&lt;/servlet-name&gt;</code>这个servlet而不走我们项目的servlet，然后重新运行项目测试一下<br><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fyj1k2ti1cj20fl0apmxp.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fyj1l076vrj20u904uaae.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fyj1ktek6vj20np08oq3j.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fyj1llbr8zj20br0ceaah.jpg" alt=""><br>（请忽略乱码问题o(╥﹏╥)o） 看到了吧，确实可以通过<code>Controller</code>返回html类型的视图了吧，也就是在执行完第<code>9</code>步后返回的视图不再是被<code>org.springframework.web.servlet.DispatcherServlet</code>拦截，而是被<code>org.apache.jasper.servlet.JspServlet</code>拦截，从而跳出了<code>DispatchServlet</code>的魔抓不会再死循环了。<br>那以后想要返回.html类型的视图是不是都要去修改Tomcat的web.xml？也不用这样，我们只要在我们的项目web.xml中配置一个<strong>相同名</strong>的servlet即可，它会自动覆盖Tomcat的web.xml的，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;.html&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></p><p>这样配，但是会报错<code>Cannot resolve Servlet &#39;jsp&#39;</code>，我也不懂为啥，知道的朋友可以补充下。Tomcat下的web.xml除了有名为<code>jsp</code>的servlet，还有一个大家应该都很熟悉的，就是名为<code>default</code>的servlet，它的作用和<code>jsp</code>的大概一样，大家知道它是拿来配置静态资源的，却很少了解它怎么来的<br><strong>Tomcat的conf/web.xml</strong><br><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fyj7w31ct9j20yx0huwgb.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fyj817fqjej20nd06rmxg.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;default&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;debug&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;0&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;listings&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;false&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">    </span><br><span class="line">&lt;!-- The mapping for the default servlet --&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;default&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></p><p>我们也可以用它来代替<code>jsp</code>的servlet来达到不拦截.html类型的视图，同样我们在项目的web.xml下配置名为<code>default</code>的servlet<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;default&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></p><p>这样即可让.html的请求都不会被前端控制器DispatchServlet拦截到。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当然要返回.html类型的视图也不是只有这种方法，也可以通过更换视图解析器，但是我觉得这样没必要，因为<code>InternalResourceViewResolver</code>视图解析器本身就是支持.html的，只是我们没处理正确而已。通过这次出现的问题，引发我了对Spring MVC的进一步了解，也把分析、解决问题的过程记录下，希望能让自己印象更深刻点，也希望能帮助到大家。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.cnblogs.com/tangwangming/p/8571551.html" target="_blank" rel="noopener">servlet-mapping url-pattern / 和 /*区别</a></p><p><a href="https://blog.csdn.net/yucdsn/article/details/78729912" target="_blank" rel="noopener">Tomcat文件夹下的context.xml和web.xml</a></p><p><a href="https://www.cnblogs.com/tv151579/p/3500880.html" target="_blank" rel="noopener">web.xml中出现<servlet-name>default</servlet-name>是什么意思？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/e0e01e43gy1fyi08g83uwj20jd05hmxe.jpg&quot; style=&quot;width: 100%&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这两天在折腾SSM，在捣鼓&lt;code&gt;Spring MVC&lt;/code&gt;的时候，我想让Spring MVC的前端控制器（&lt;code&gt;DispatcherServlet&lt;/code&gt;）给用户返回的是HTML类型的视图而不是JSP类型的视图，于是我按照常规的思路，把&lt;code&gt;Spring MVC&lt;/code&gt;配置文件里面的视图解析器配置修改成HTML后缀的，然后就遇上了各种问题了……当然这些问题也都是我对Spring MVC不够了解才导致的，接下来详细说一下我遇到的问题以及解决过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring MVC" scheme="http://ddnd.cn/categories/Spring-MVC/"/>
    
    
      <category term="Spring MVC" scheme="http://ddnd.cn/tags/Spring-MVC/"/>
    
      <category term="web.xml" scheme="http://ddnd.cn/tags/web-xml/"/>
    
      <category term="servlet" scheme="http://ddnd.cn/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>RPC和RESTful API入门篇</title>
    <link href="http://ddnd.cn/2018/12/19/rpc-and-restful/"/>
    <id>http://ddnd.cn/2018/12/19/rpc-and-restful/</id>
    <published>2018-12-19T05:31:55.000Z</published>
    <updated>2019-03-12T10:14:48.009Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fyaudx4yrxj209u03yt8m.jpg" style="width: 100%"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这两天在和同学谈到RPC、RESTful时候发现自己对这两者并不是很理解，于是查阅了网上相关资料加上自己的理解写下本篇文章以加深印象，由于本人水平有限，若对这两者的理解有不妥之处望指出。</p><a id="more"></a><h1 id="什么是REST和RESTful"><a href="#什么是REST和RESTful" class="headerlink" title="什么是REST和RESTful"></a>什么是REST和RESTful</h1><p>在认识RESTful之前，我们先科普一下REST。</p><h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><p>REST即Representational State Transfer的缩写，<strong>是基于HTTP协议之上的一组约束和属性</strong>，翻译过来是<strong>表现层状态转移</strong>。REST是一种<em>设计风格</em>（并非一种标准），描述的是在网络中Client和Server的一种交互形式，目的是便于<strong>不同</strong>的软件/程序在网络中互相传递消息。按照我的理解：<strong><em>我们通过URI定位到服务器上的资源（例如文本、图片、服务），然后对资源进行某种操作（CRUD）并且返回足够的信息描述服务器的状态（比如：状态码）让客户端知道如何处理，资源传递给客户端并且以某种形式表现（比如JSON、HTML、XML、PNG等）出来</em></strong>，而REST则是将URI的命名风格、对资源操作的实现方式、操作之后返回什么信息和资源以哪种形式表现出来等总结成了一种设计风格，让大家都使用这种设计风格去实现这些设计，当然REST的设计风格不止我指出的这几个，只是这几个是要点。<br>REST设计的风格遵循以下几点：<br>1.<strong>利用HTTP方法让接口统一化</strong><br>REST充分利用HTTP自身的GET、POST、PUT、DELETE的方法实现接口的统一化，比如对同一个资源进行CRUD操作时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /posts     获取文章             GET /getPosts       获取文章 </span><br><span class="line">POST /posts    发布文章             GET /addPosts       发布文章 </span><br><span class="line">PUT /posts     修改文章             GET /editPosts      修改文章 </span><br><span class="line">DELETE /posts  删除文章             GET /deletePosts    删除文章</span><br></pre></td></tr></table></figure></p><p>上面的设计中，左边的是符合REST设计风格的，右边的是不符合REST设计风格的。URI只需将资源准确无误的暴露出来就可以，而不需要加上动作词，而动作则体现在HTTP的GET、POST、PUT、DELETE方法中，其中URI还推荐使用复数。<br>2.<strong>利用HTTP状态码返回状态信息</strong><br>下面举例几个HTTP Status Code和表示的什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Status Code: 200 OK</span><br><span class="line">Status Code: 400 Bed Request</span><br><span class="line">Status Code: 404 Not Found</span><br><span class="line">Status Code: 500 Internal Server Error</span><br></pre></td></tr></table></figure></p><p>其中2XX的状态码表示请求已成功被服务器已接收、理解、并接受<br>3XX的状态码表示重定向<br>4XX的状态码表示客户端错误<br>5XX的状态码表示服务器错误<br>3.<strong>利用HTTP报头告知对方如何处理本次请求（相应）</strong><br>HTTP报头是描述客户端与服务器之间的请求或者响应应该如何处理本次请求的，比如该用什么表现形式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Authorization 认证报头 </span><br><span class="line">Cache-Control 缓存报头 </span><br><span class="line">Cnotent-Type  消息体类型报头</span><br></pre></td></tr></table></figure></p><p>4.<strong>无状态</strong><br>REST设计风格要求Server无状态，无状<strong>态并不等于</strong>不保存用户的状态，而是指服务器不保存请求状态（会话信息），客户端必须每次都<strong>带上自己的状态</strong>去请求服务器，如果确实要维持用户的状态，也应由客户端负责，例如：在服务端上通过Cookie保存Token，之后的请求中都带上Token，而这个Token就保存有了用户的状态（如登录信息）。这里需要注意的是：</p><ul><li>通过Session保存状态<strong>不是REST设计风格</strong>，因为Session是将状态信息（用户信息、过期时间等）保存在了服务器上，比如用户登录成功后，会将Session信息保存在服务器，然后返回个SessionID给客户端并且将SessionID保存在Cookies中,之后的请求客户端都会通过Cookies传递SessionID给服务器，服务器根据客户端传来的SessionID去匹配之前保存的Session状态信息，所以这个状态是保存在服务器上的，是靠服务器维持的，所以不是REST设计风格。</li><li>通过Token保存状态<strong>是REST设计风格</strong>，因为状态信息（用户信息、过期时间等）都是保存在Token中，而Token又是保存在客户端中（如Cookies），比如用户登录成功后，服务器会返回一个Token（包含了用户信息、过期时间等）给服务端，服务端将Token保存在Cookies中，之后的请求客户端都会取出Token放到Request Headers中传给服务器，服务器验证Token的有效性即可。<blockquote><p>看到这里是不是能理解*<em>状态转移</em>这个词了？就是状态通过客户端来转移。</p></blockquote></li></ul><p>简单的来说就是状态信息保存在服务器的就是<strong>有状态的</strong>，而状态信息保存在客户端的就是<strong>无状态的</strong>。通过REST的无状态原则恰好有利于实现负载均衡，在分布式的Web系统上，有多个可用的服务器，每个服务器都可以处理客户端发来的请求，及时有一台服务器宕机，无状态的请求可以交给别的服务器处理，这是有状态的请求所做不到的。</p><h2 id="什么是RESTful"><a href="#什么是RESTful" class="headerlink" title="什么是RESTful"></a>什么是RESTful</h2><p>理解完REST那我们就很容易理解RESTful了，RESTful即实现REST设计风格的一种架构，如RESTful API（REST设计风格的API）</p><h1 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h1><p>RPC就是Remote Procedure Call的简称，翻译成中文就是<strong>远程过程调用</strong>，什么是远程过程调用？举个例子：有两台服务器A、B，一个应用部署在A服务器上，另一个应用部署在B服务器上，A服务器上的应用想要调用B服务器上应用所提供的方法、函数，那么这个调用过程就需要网络来支撑，整个调用过程可以用下图表示。<br><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fyc1ig0m9tg207c072jr9.jpg" alt=""></p><h2 id="RPC分类"><a href="#RPC分类" class="headerlink" title="RPC分类"></a>RPC分类</h2><p>其中RPC分为两种：</p><ol><li><strong>同步调用</strong><br>在上面举的例子中，A服务器的应用调用B服务器上应用的方法、函数后，A服务器的应用会处在<strong>阻塞状态</strong>，只有等到B服务器上的应用通过网络返回结果后，A服务器的应用才会继续往下执行。</li><li><strong>异步调用</strong><br>在上面举的例子中，A服务器的应用调用B服务器上应用的方法、函数后，A服务器的应用并不会进入阻塞状态等待结果的返回，可以通过回调通知等方式获得返回的结果。</li></ol><h2 id="RPC的网络通信问题"><a href="#RPC的网络通信问题" class="headerlink" title="RPC的网络通信问题"></a>RPC的网络通信问题</h2><p>我们知道在RPC调用的时候需要网络来支撑，那么以何种方式来实现通信呢。</p><ol><li><strong>HTTP协议</strong><br>A服务器的应用可以通过HTTP将数据传输到B服务器，B服务器接收到数据后执行数据中调用的指定方法、函数，例如谷歌的gRPC就是在HTTP上进行数据传输的。但是由于HTTP报头中有太多不需要的信息造成带宽的浪费，所以很多人都是用比HTTP传输效率高的TCP、UDP进行数据传输。</li><li><strong>TCP、UDP</strong><br>例如著名的Netty就是基于TCP、UDP上进行传输的，当然你也可以不使用框架，自己编写Socket实现网络数据传输。</li></ol><h1 id="RESTful-API和RPC"><a href="#RESTful-API和RPC" class="headerlink" title="RESTful API和RPC"></a>RESTful API和RPC</h1><h2 id="RESTful-API和RPC区别和关系"><a href="#RESTful-API和RPC区别和关系" class="headerlink" title="RESTful API和RPC区别和关系"></a>RESTful API和RPC区别和关系</h2><p>在我理解中，RESTful API和RPC是两种完全不同概念的东西，是没法放在一起比较的，如果硬要将它俩比较，我认为RESTful是RPC的一种实现，即RPC包括RESTful API，但RPC不等于RESTful API。</p><ul><li>RPC：我认为RPC是一种为实现远程调用而提出<strong>一种思想</strong>，至于你用什么方式去达到目的都可以（例如：用什么网络协议来传输数据看自己的选择）。</li><li>RESTful API：符合REST设计风格的一种接口架构，它也是通过网络进行的远程调用，但是远程调用仅限于HTTP。<h2 id="RESTful-API和RPC用途"><a href="#RESTful-API和RPC用途" class="headerlink" title="RESTful API和RPC用途"></a>RESTful API和RPC用途</h2>既然RESTful API和RPC都可以实现远程调用，那我们应该在这两者之中如何抉择呢？</li><li>RESTful API：主要用在为第三方提供调用自家系统的一种途径。</li><li>RPC：主要用在自家系统之间的互相调用，即实现系统的分布式。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在这里我仅是以我掌握的知识给大家介绍RPC和RESTful，给初学者大概了解一下RPC和RESTful，若文中有不妥的地方希望大家指出。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/e0e01e43gy1fyaudx4yrxj209u03yt8m.jpg&quot; style=&quot;width: 100%&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这两天在和同学谈到RPC、RESTful时候发现自己对这两者并不是很理解，于是查阅了网上相关资料加上自己的理解写下本篇文章以加深印象，由于本人水平有限，若对这两者的理解有不妥之处望指出。&lt;/p&gt;
    
    </summary>
    
      <category term="技术杂谈" scheme="http://ddnd.cn/categories/Technique/"/>
    
    
      <category term="RPC" scheme="http://ddnd.cn/tags/RPC/"/>
    
      <category term="RESTful" scheme="http://ddnd.cn/tags/RESTful/"/>
    
  </entry>
  
  <entry>
    <title>SSM框架整合 附源码</title>
    <link href="http://ddnd.cn/2018/12/16/SSM-integration/"/>
    <id>http://ddnd.cn/2018/12/16/SSM-integration/</id>
    <published>2018-12-16T07:33:50.000Z</published>
    <updated>2019-03-12T10:15:51.531Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fy8muss9bdj20m8078mx7.jpg" style="width: 100%"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面已经介绍<a href="https://ddnd.cn/2018/12/01/Spring-Mybatis/">Spring和Mybatis整合</a>，而本篇介绍在IDEA下Spring、Spring MVC、Mybatis（SSM）三个框架的整合，在阅读本篇之前，建议大家先去了解一下Spring、Spring MVC、Mybatis（<a href="https://ddnd.cn/categories/">三大框架基础入门传送门</a>），会达到事半功倍的效果。至于Spring MVC相对于Servlet、JSP的优点这里就不累赘了，大家可以上网查阅相关资料。本篇注重整合思路、整合过程以及整合过程中出现的坑。</p><a id="more"></a><h1 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h1><p><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fy8nvkchhzj20ca0ofabe.jpg" alt=""></p><h1 id="添加依赖包"><a href="#添加依赖包" class="headerlink" title="添加依赖包"></a>添加依赖包</h1><p>pom.xml：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;ddnd&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;ddnd&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;!-- spring版本号 --&gt;</span><br><span class="line">        &lt;spring.version&gt;4.2.5.RELEASE&lt;/spring.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.4.6&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;8.0.13&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 添加spring核心依赖 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p><h1 id="创建数据库和数据表"><a href="#创建数据库和数据表" class="headerlink" title="创建数据库和数据表"></a>创建数据库和数据表</h1><p>本文中使用Mysql，为了演示方便，仅创建个简单的数据库spring，还有数据表user。数据表创建SQL代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `email` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,</span><br><span class="line">  `password` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `users_email_unique` (`email`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=240 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure></p><h1 id="新建数据库对应的实体类"><a href="#新建数据库对应的实体类" class="headerlink" title="新建数据库对应的实体类"></a>新建数据库对应的实体类</h1><p>为了实现与数据库中的user表进行关系映射，这里新建一个User类：User.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package cn.ddnd.www.Entity;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line">    int id;</span><br><span class="line">    String email;</span><br><span class="line">    String password;</span><br><span class="line"></span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setEmail(String email) &#123;</span><br><span class="line">        this.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getEmail() &#123;</span><br><span class="line">        return email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="新建Mapper-xml文件和Mapper接口（Dao层）"><a href="#新建Mapper-xml文件和Mapper接口（Dao层）" class="headerlink" title="新建Mapper.xml文件和Mapper接口（Dao层）"></a>新建Mapper.xml文件和Mapper接口（Dao层）</h1><blockquote><p>这里注意Mapper.xml文件名要和Mapper接口的名字相同</p></blockquote><p>1.Mapper接口：UserDao.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package cn.ddnd.www.Dao;</span><br><span class="line"></span><br><span class="line">import cn.ddnd.www.Entity.User;</span><br><span class="line"></span><br><span class="line">public interface UserDao &#123;</span><br><span class="line">    public User getUserByEmail(String email);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里为了测试，仅编写一个接口，即通过用户email查询到用户的信息。</p><ol start="2"><li>Mapper.xml文件：UserDao.xml<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace=&quot;cn.ddnd.www.Dao.UserDao&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;getUserByEmail&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">        select * from user where email = #&#123;email&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></li></ol><p>这里需要注意用一下：我们使用的是IDEA，而IDEA默认是不编译<code>main/src/java</code>目录下的xml文件的，即在编译的时候不会把将这些xml一块打包进classes文件，而是<strong>直接丢弃</strong>。为了解决这个问题，有两种方法，1.将xml文件都放到<code>resources</code>目录下。2.配置maven的pom文件。这里我就用第一种方法，将mapper.xml文件都放到resources目录。</p><h1 id="Mybatis配置文件"><a href="#Mybatis配置文件" class="headerlink" title="Mybatis配置文件"></a>Mybatis配置文件</h1><p>Mybatis-config.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;typeAliases&gt;</span><br><span class="line">        &lt;typeAlias type=&quot;cn.ddnd.www.Entity.User&quot; alias=&quot;User&quot;&gt;&lt;/typeAlias&gt;</span><br><span class="line">    &lt;/typeAliases&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p><p>这里为<code>cn.ddnd.www.Entity.User</code>这个类设置个<code>User</code>的别名，这样直接使用<code>User</code>即可使用<code>cn.ddnd.www.Entity.User</code>这个类。</p><h1 id="Spring-MVC配置文件"><a href="#Spring-MVC配置文件" class="headerlink" title="Spring MVC配置文件"></a>Spring MVC配置文件</h1><p>Spring-mvc.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;prefix&quot; value=&quot;&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p>这里配置个<code>InternalResourceViewResolver</code>解析器，<code>prefix</code>属性指定资源文件的<strong>前缀</strong>，因为我的资源文件就放在<code>web</code>目录下，所以我这个属性留空，<code>suffix</code>属性配置资源页面的<strong>后缀</strong>。</p><h1 id="Spring-配置文件"><a href="#Spring-配置文件" class="headerlink" title="Spring 配置文件"></a>Spring 配置文件</h1><p>前面配置完Mybatis是不是觉得配置的代码很少、很简单？这是因为Mybatis的一些配置都放在Spring中配置啦！接下来看我们Spring的配置文件。<br>applicationContext.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">       http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">       http://www.springframework.org/schema/context</span><br><span class="line">       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:component-scan base-package=&quot;cn.ddnd.www&quot;&gt;&lt;/context:component-scan&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置数据源--&gt;</span><br><span class="line">    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/spring?serverTimezone=GMT%2B8&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置Mybatis的SqlSessionFactory--&gt;</span><br><span class="line">    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">        &lt;!--注入连接池数据源配置--&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;!--注入mybatis配置信息 注意加上classpath 不然编译出来后是找不到Mybatis-config.xml的文件的--&gt;</span><br><span class="line">        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:Mybatis-config.xml&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;!--mapper.xml和mapper.java不在同一个目录 则配置此参数--&gt;</span><br><span class="line">        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置Mybatis的Mapper映射器 这个是指定接口配置--&gt;</span><br><span class="line">    &lt;!--&lt;bean id=&quot;userBean&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;--&gt;</span><br><span class="line">        &lt;!--SqlSessionFactory是用来指定生成实现SqlSession接口的SqlSessionTemplate对象的--&gt;</span><br><span class="line">        &lt;!--&lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;--&gt;</span><br><span class="line">        &lt;!--mapperInterface指定我们Mapper对应的接口--&gt;</span><br><span class="line">        &lt;!--&lt;property name=&quot;mapperInterface&quot; value=&quot;cn.ddnd.www.Dao.UserDaoao&quot;&gt;&lt;/property&gt;--&gt;</span><br><span class="line">    &lt;!--&lt;/bean&gt;--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--扫描Mapper接口并注册为Bean 这个是通过扫描包来配置--&gt;</span><br><span class="line">    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;basePackage&quot; value=&quot;cn.ddnd.www.Dao&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p>在<code>applicationContext</code>配置了<code>Mybatis</code>的<strong>数据源</strong>、<strong>SqlSessionFactory</strong>、<strong>Mapper映射器</strong>，为了简便我们选择用扫描包的方式注册。<br>这里需要注意一下几点：</p><ol><li>添加<code>mapperLocations</code>属性：因为我们把Mapper.xml文件和Mapper接口放在了不同的目录下，所以我们需要在配置Mybatis的<code>SqlSessionFactory</code>时候添加一个属性<code>mapperLocations</code>，即指定<code>mapper.xml</code>文件的路径。</li><li>启动扫描JavaBean：<code>&lt;context:component-scan base-package=&quot;cn.ddnd.www&quot;&gt;&lt;/context:component-scan&gt;</code>扫描指定包下的所有JavaBean，</li><li>添加XML命名空间：<code>xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</code>,<code>xsi:schemaLocation=&quot;http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</code>，不然会出现通配符的匹配很全面, 但无法找到元素 ‘context:component-scan’ 的声明的问题。</li><li>路径前添加classpath：在指定XML路径的时候，需要以<code>classpath:文件路径</code>的形式，不然会出现XML文件找不到的问题，因为工程编译后XML文件都是放在<code>classes</code>的文件夹下。<br><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fy8pkuz1huj20pk08ddgb.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fy8pl9cs0aj20nn08bwf4.jpg" alt=""></li></ol><h1 id="编写Service层"><a href="#编写Service层" class="headerlink" title="编写Service层"></a>编写Service层</h1><p>虽然前面已经编写了Dao层（UserDao）了，但是Dao层的工作主要是做数据持久化的，而Service层则负责业务模块的逻辑应用设计，Service调用已定义的Dao层的接口实现数据的持久化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package cn.ddnd.www.Service;</span><br><span class="line"></span><br><span class="line">import cn.ddnd.www.Dao.UserDao;</span><br><span class="line">import cn.ddnd.www.Entity.User;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class Uservice &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserDao userDao;</span><br><span class="line"></span><br><span class="line">    public User getUserByEmail(String email) &#123;</span><br><span class="line">        return userDao.getUserByEmail(email);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="编写Controller层"><a href="#编写Controller层" class="headerlink" title="编写Controller层"></a>编写Controller层</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package cn.ddnd.www.Controller;</span><br><span class="line"></span><br><span class="line">import cn.ddnd.www.Entity.User;</span><br><span class="line">import cn.ddnd.www.Service.Uservice;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class IndexController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    Uservice uservice;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;/&quot;)</span><br><span class="line">    public ModelAndView Index()&#123;</span><br><span class="line">        User user;</span><br><span class="line">        user = uservice.getUserByEmail(&quot;xue8@ddnd.cn&quot;);</span><br><span class="line">        return new ModelAndView(&quot;index&quot;, &quot;user&quot;, user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里自动装配Service层的Uservice，实现数据查询，查询结果将在View层显示。这里为了方便，默认查询email为<a href="mailto:`xue8@ddnd.cn">`xue8@ddnd.cn</a>`的用户信息。</p><h1 id="编写View层"><a href="#编写View层" class="headerlink" title="编写View层"></a>编写View层</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: xueba</span><br><span class="line">  Date: 2018/11/29</span><br><span class="line">  Time: 17:34</span><br><span class="line">  To change this template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;SSM整合&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    email：$&#123;user.email&#125; &lt;br&gt;</span><br><span class="line">    id：$&#123;user.id&#125; &lt;br&gt;</span><br><span class="line">    password：$&#123;user.password&#125; &lt;br&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>将查询出来的用户信息显示出来。</p><h1 id="配置Web-xml"><a href="#配置Web-xml" class="headerlink" title="配置Web.xml"></a>配置Web.xml</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span><br><span class="line">         version=&quot;4.0&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;Spring&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">            &lt;param-value&gt;classpath:*.xml&lt;/param-value&gt;</span><br><span class="line">        &lt;/init-param&gt;</span><br><span class="line">        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;Spring&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><p>在Web.xml中配置<strong>前端控制器</strong><code>DispatcherServlet</code>，负责发送每个请求到合适的处理程序。</p><h1 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h1><p><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fy8q8xln3bj20lr08mq3b.jpg" alt=""></p><p>源码下载：<a href="https://github.com/xue8/Java-Demo/tree/master/SSM" target="_blank" rel="noopener">SSM整合例子</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/e0e01e43gy1fy8muss9bdj20m8078mx7.jpg&quot; style=&quot;width: 100%&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前面已经介绍&lt;a href=&quot;https://ddnd.cn/2018/12/01/Spring-Mybatis/&quot;&gt;Spring和Mybatis整合&lt;/a&gt;，而本篇介绍在IDEA下Spring、Spring MVC、Mybatis（SSM）三个框架的整合，在阅读本篇之前，建议大家先去了解一下Spring、Spring MVC、Mybatis（&lt;a href=&quot;https://ddnd.cn/categories/&quot;&gt;三大框架基础入门传送门&lt;/a&gt;），会达到事半功倍的效果。至于Spring MVC相对于Servlet、JSP的优点这里就不累赘了，大家可以上网查阅相关资料。本篇注重整合思路、整合过程以及整合过程中出现的坑。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://ddnd.cn/categories/Spring-Programming/"/>
    
    
      <category term="Mybatis" scheme="http://ddnd.cn/tags/Mybatis/"/>
    
      <category term="Spring" scheme="http://ddnd.cn/tags/Spring/"/>
    
      <category term="Spring-MVC" scheme="http://ddnd.cn/tags/Spring-MVC/"/>
    
  </entry>
  
  <entry>
    <title>Spring和Mybatis整合</title>
    <link href="http://ddnd.cn/2018/12/01/Spring-Mybatis/"/>
    <id>http://ddnd.cn/2018/12/01/Spring-Mybatis/</id>
    <published>2018-12-01T10:14:46.000Z</published>
    <updated>2019-03-12T10:15:42.404Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fxreyw9u7sj21y013edog.jpg" style="width: 100%"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在很多项目中，Mybatis都是和Spring配合起来一起发挥作用的，利用Spring的注入、基于接口编程等优势，将Mybatis的一些琐事交给Spring管理，而Mybatis可以更加注重在自身业务SQL语句上。Mybatis和Spring的整合思路如下：</p><ol><li>Mybatis将SqlSessionFactory交给Spring创建和管理<br><code>SqlSessionFactoryBean</code>代替了<code>SqlSessionFactoryBuilder</code>来创建<code>SqlSessionFactory</code>,SqlSessionFactoryBean实现了Spring的FactoryBean接口，Spring在应用启动的时候为你创建SqlSessionFactory对象，然后将它以SqlSessionFactory为命名来存储。</li><li>Mybatis将数据映射器Mapper交给Spring管理<br><code>MapperFactoryBean</code>封装了原有的<code>session.getMapper()</code>功能的实现，它可以把我们对应的Mapper接口<strong>注入</strong>到由Spring管理的Bean对象中(如Service Bean对象)，这样当我们需要使用到相应的Mapper对象时候，<code>MapperFactoryBean</code>会从它的getObject方法中获取到对应的Mapper.xml文件，即通过<strong>Mapper接口</strong>(xx.java)获取我们想要的<strong>Mapper对象</strong>。<a id="more"></a></li></ol><h1 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h1><p><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fxtoptc78xj20b70eqmxo.jpg" alt=""></p><h1 id="添加依赖包"><a href="#添加依赖包" class="headerlink" title="添加依赖包"></a>添加依赖包</h1><p>pom.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;ddnd&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;ddnd&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;!-- spring版本号 --&gt;</span><br><span class="line">        &lt;spring.version&gt;4.2.5.RELEASE&lt;/spring.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.4.6&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;8.0.13&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 添加spring核心依赖 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p><h1 id="创建数据库和数据表"><a href="#创建数据库和数据表" class="headerlink" title="创建数据库和数据表"></a>创建数据库和数据表</h1><p>本文中使用Mysql，为了演示方便，仅创建个简单的数据库spring，还有数据表user。数据表创建SQL代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `email` varchar(255) DEFAULT NULL,</span><br><span class="line">  `name` varchar(255) DEFAULT NULL,</span><br><span class="line">  `password` varchar(255) DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=latin1;</span><br></pre></td></tr></table></figure></p><h1 id="新建数据表对应的实体类"><a href="#新建数据表对应的实体类" class="headerlink" title="新建数据表对应的实体类"></a>新建数据表对应的实体类</h1><p>为了实现与数据库中的user表进行关系映射，这里新建一个User类：User.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package cn.ddnd.www.Entity;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line">    String email;</span><br><span class="line">    String name;</span><br><span class="line">    String password;</span><br><span class="line"></span><br><span class="line">    User(String email, String name, String password)&#123;</span><br><span class="line">        this.email = email;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setEmail(String email) &#123;</span><br><span class="line">        this.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getEmail() &#123;</span><br><span class="line">        return email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="新建Mapper-xml文件和Mapper接口"><a href="#新建Mapper-xml文件和Mapper接口" class="headerlink" title="新建Mapper.xml文件和Mapper接口"></a>新建Mapper.xml文件和Mapper接口</h1><p>Mapper.xml文件和Mapper接口最好在同一个路径下，不同路径的话需要配置的话需要配置<code>SqlSessionFactoryBean</code>的<code>configLocation</code>属性来指定Mapper.xml文件的路径。</p><ol><li><p>Mapper对象：IUser.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace=&quot;cn.ddnd.www.Dao.IUser&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;getUser&quot; parameterType=&quot;String&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">        select * from user where email = #&#123;email&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></li><li><p>Mapper接口：IUser.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package cn.ddnd.www.Dao;</span><br><span class="line"></span><br><span class="line">import cn.ddnd.www.Entity.User;</span><br><span class="line"></span><br><span class="line">public interface IUser &#123;</span><br><span class="line">    public User getUser(String email);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="Mybatis配置文件"><a href="#Mybatis配置文件" class="headerlink" title="Mybatis配置文件"></a>Mybatis配置文件</h1><p>Mybatis-config.xml：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;typeAliases&gt;</span><br><span class="line">        &lt;typeAlias type=&quot;cn.ddnd.www.Entity.User&quot; alias=&quot;User&quot;&gt;&lt;/typeAlias&gt;</span><br><span class="line">    &lt;/typeAliases&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p><p>注意这里：如果Mybatis没有整合Spring的时候，数据源的配置信息需要在这个文件中配置好，现在配合Spring使用之后，数据源的配置也就交给了Spring来创建和管理。同时<code>typeAliases</code>别名也可以在Spring的<code>SqlSessionFactoryBean</code>中设置</p><h1 id="Spring配置文件"><a href="#Spring配置文件" class="headerlink" title="Spring配置文件"></a>Spring配置文件</h1><p>applicationContext.xml：</p><h2 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置数据源--&gt;</span><br><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/spring?serverTimezone=GMT%2B8&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h2 id="配置Mybatis的SqlSessionFactory"><a href="#配置Mybatis的SqlSessionFactory" class="headerlink" title="配置Mybatis的SqlSessionFactory"></a>配置Mybatis的SqlSessionFactory</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置Mybatis的SqlSessionFactory--&gt;</span><br><span class="line">&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">    &lt;!--注入连接池数据源配置 必要属性--&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--注入mybatis配置信息--&gt;</span><br><span class="line">    &lt;property name=&quot;configLocation&quot; value=&quot;Mybatis-config.xml&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>在配置<code>SqlSessionFactoryBean</code>的时候，有一个属性是<strong>必须</strong>的，就是<code>dataSource</code>,它表示用于连接数据库的数据源（可以是Tomcat DBCP、C3P0等连接池）。除了<code>SqlSessionFactoryBean</code>外，别的属性都不是必要的，如指定Mybatis配置文件的<code>configLocation</code>，指定Mapper.xml文件存放位置的属性<code>mapperLocations</code>，当我们的Mapper.xml文件跟Mapper接口处在同一个目录下时候，这个参数不用设置。<code>typeAliasesPackage</code>可以设置别名，一般对应我们的<strong>实体类</strong>所在的包，会<strong>自动扫描</strong>包下的类并且将类名设置为别名，如果有多个包的话，可以用逗号<code>,</code>或者分号<code>:</code>进行分隔。</p><h2 id="配置Mybatis数据映射器Mapper"><a href="#配置Mybatis数据映射器Mapper" class="headerlink" title="配置Mybatis数据映射器Mapper"></a>配置Mybatis数据映射器Mapper</h2><p>有两种方式将Mapper的接口注册成Bean，分别是单例注册、扫描注册</p><h3 id="通过指定Mapper的接口注册相应的Bean"><a href="#通过指定Mapper的接口注册相应的Bean" class="headerlink" title="通过指定Mapper的接口注册相应的Bean"></a>通过指定Mapper的接口注册相应的Bean</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置Mybatis的Mapper映射器--&gt;</span><br><span class="line">&lt;bean id=&quot;userBean&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;</span><br><span class="line">    &lt;!--SqlSessionFactory是用来指定生成实现SqlSession接口的SqlSessionTemplate对象的--&gt;</span><br><span class="line">    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--mapperInterface指定我们Mapper对应的接口--&gt;</span><br><span class="line">    &lt;property name=&quot;mapperInterface&quot; value=&quot;cn.ddnd.www.Dao.IUser&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--如果要配置多个的话 得新建MapperFactoryBean --&gt;</span><br><span class="line">&lt;!--&lt;bean id=&quot;userBean&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;</span><br><span class="line">    &lt;!--SqlSessionFactory是用来指定生成实现SqlSession接口的SqlSessionTemplate对象的--&gt;</span><br><span class="line">    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--mapperInterface指定我们Mapper对应的接口--&gt;</span><br><span class="line">    &lt;property name=&quot;mapperInterface&quot; value=&quot;cn.ddnd.www.Dao.IBook&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;--&gt;</span><br></pre></td></tr></table></figure><ol><li><code>mapperInterface</code>：指定接口的路径，<code>MapperFactoryBean</code>创建的代理类实现了<code>IUser</code>接口（Spring将接口注入到Spring管理的Bean中），并且注入到应用程序中。注意IUser.xml文件的路径需要和IUser.java接口的路径相同，否则需要在<code>SqlSessionFactoryBean</code>中设置<code>configLocation</code>属性，指定.xml文件路径。</li><li><code>sqlSessionFactory</code>：指定<code>SqlSessionFactory</code>,用于提供SqlSession。</li></ol><h3 id="通过扫描指定包批量将Mapper的接口并注册相应的Bean"><a href="#通过扫描指定包批量将Mapper的接口并注册相应的Bean" class="headerlink" title="通过扫描指定包批量将Mapper的接口并注册相应的Bean"></a>通过扫描指定包批量将Mapper的接口并注册相应的Bean</h3><p>通过指定Mapper的接口进行注册Bean的话，我们的Mapper少的时候还可以应付，但是Mapper多了就显得很麻烦了，Mybatis-Spring为了我们提供了一个<code>MapperScannerConfigurer</code>的类，它可以自动扫描Mapper接口并注册为Bean。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--扫描Mapper接口并注册为Bean--&gt;</span><br><span class="line">&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;basePackage&quot; value=&quot;cn.ddnd.www.Dao&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><ol><li><code>basePackage</code>：指定接口所在的包的路径，<code>MapperScannerConfigurer</code>会自动扫描包下的接口并创建为<code>MapperFactoryBean</code>。</li><li>可以不指定<code>sqlSessionFactory</code>，因为<code>MapperScannerConfigurer</code>会创建在创建<code>MapperFactoryBean</code>之后自动装配<code>sqlSessionFactory</code>。但是如果你使用了一个以上的DataSource，那么自动装配<strong>失效</strong>。</li></ol><p>applicationContext.xml完整代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置数据源--&gt;</span><br><span class="line">    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/spring?serverTimezone=GMT%2B8&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置Mybatis的SqlSessionFactory--&gt;</span><br><span class="line">    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">        &lt;!--注入连接池数据源配置--&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;!--注入mybatis配置信息--&gt;</span><br><span class="line">        &lt;property name=&quot;configLocation&quot; value=&quot;Mybatis-config.xml&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置Mybatis的Mapper映射器--&gt;</span><br><span class="line">    &lt;bean id=&quot;userBean&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;</span><br><span class="line">        &lt;!--SqlSessionFactory是用来指定生成实现SqlSession接口的SqlSessionTemplate对象的--&gt;</span><br><span class="line">        &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;!--mapperInterface指定我们Mapper对应的接口--&gt;</span><br><span class="line">        &lt;property name=&quot;mapperInterface&quot; value=&quot;cn.ddnd.www.Dao.IUser&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--扫描Mapper接口并注册为Bean--&gt;</span><br><span class="line">    &lt;!--&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;property name=&quot;basePackage&quot; value=&quot;cn.ddnd.www.Dao&quot; /&gt;--&gt;</span><br><span class="line">    &lt;!--&lt;/bean&gt;--&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><h1 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h1><p>test.jav：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import cn.ddnd.www.Dao.IUser;</span><br><span class="line">import cn.ddnd.www.Entity.User;</span><br><span class="line">import org.apache.ibatis.session.SqlSession;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.apache.ibatis.io.Resources;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">import java.io.Reader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line">    private static Reader reader;</span><br><span class="line">    private static SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    private static ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    static&#123;</span><br><span class="line">//        只需要加载Spring的配置文件</span><br><span class="line">        applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void a() throws IOException &#123;</span><br><span class="line">//            获取Mapper对象</span><br><span class="line">            IUser iUser = (IUser) applicationContext.getBean(&quot;userBean&quot;);</span><br><span class="line">//            调用Mapper对象的方法</span><br><span class="line">            User user = iUser.getUser(&quot;xue8@qq.com&quot;);</span><br><span class="line">            System.out.println(&quot;用户的邮箱是：&quot; + user.getEmail() + &quot;，用户的名称是：&quot; + user.getName() + &quot;，用户的密码是：&quot; + user.getPassword());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从这里可以看到单独使用Mybatis<a href="https://ddnd.cn/2018/11/29/Mybatis-Introduction/">Mybatis实现数据库操作</a>和Mybatis-Spring整合使用的区别，Mybatis将<code>SqlSessionFactory</code>和<code>数据映射器Mapper</code>交给Spring管理之后，我们不再需要sqlSession的获取和close，不在需要手动指定映射器。<br>运行结果：<br><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fxtoo9a2naj20s606s74v.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/e0e01e43gy1fxreyw9u7sj21y013edog.jpg&quot; style=&quot;width: 100%&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在很多项目中，Mybatis都是和Spring配合起来一起发挥作用的，利用Spring的注入、基于接口编程等优势，将Mybatis的一些琐事交给Spring管理，而Mybatis可以更加注重在自身业务SQL语句上。Mybatis和Spring的整合思路如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Mybatis将SqlSessionFactory交给Spring创建和管理&lt;br&gt;&lt;code&gt;SqlSessionFactoryBean&lt;/code&gt;代替了&lt;code&gt;SqlSessionFactoryBuilder&lt;/code&gt;来创建&lt;code&gt;SqlSessionFactory&lt;/code&gt;,SqlSessionFactoryBean实现了Spring的FactoryBean接口，Spring在应用启动的时候为你创建SqlSessionFactory对象，然后将它以SqlSessionFactory为命名来存储。&lt;/li&gt;
&lt;li&gt;Mybatis将数据映射器Mapper交给Spring管理&lt;br&gt;&lt;code&gt;MapperFactoryBean&lt;/code&gt;封装了原有的&lt;code&gt;session.getMapper()&lt;/code&gt;功能的实现，它可以把我们对应的Mapper接口&lt;strong&gt;注入&lt;/strong&gt;到由Spring管理的Bean对象中(如Service Bean对象)，这样当我们需要使用到相应的Mapper对象时候，&lt;code&gt;MapperFactoryBean&lt;/code&gt;会从它的getObject方法中获取到对应的Mapper.xml文件，即通过&lt;strong&gt;Mapper接口&lt;/strong&gt;(xx.java)获取我们想要的&lt;strong&gt;Mapper对象&lt;/strong&gt;。
    
    </summary>
    
      <category term="Spring" scheme="http://ddnd.cn/categories/Spring-Programming/"/>
    
    
      <category term="Mybatis" scheme="http://ddnd.cn/tags/Mybatis/"/>
    
      <category term="Spring" scheme="http://ddnd.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis mapper动态代理方式</title>
    <link href="http://ddnd.cn/2018/11/30/Mybatis-Proxy/"/>
    <id>http://ddnd.cn/2018/11/30/Mybatis-Proxy/</id>
    <published>2018-11-30T13:33:59.000Z</published>
    <updated>2019-03-12T10:14:28.246Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fxqf5iw6clj20m80cin0d.jpg" style="width: 100%"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们在使用Mybatis的时候，获取需要执行的SQL语句的时候，都是通过调用xml文件来获取，例如：<code>User user = (User) sqlSession.selectOne(&quot;cn.ddnd.www.Entity.User.getUser&quot;, &quot;xue8@qq.com&quot;);</code>。这种方式是通过字符串去调用标签定义的SQL语句，第一容易出错，第二是当xml当中的id修改过后你不知道在程序当中有多少个地方使用了这个id，需要手动一一修改。后来Mybatis推出了Mapper动态代理方式，只需要编写<strong>Mapper接口</strong>（相当于Dao层）,由Mybatis框架根据接口定义创建接口的动态代理对象。</p><a id="more"></a><h1 id="Mapper接口规范"><a href="#Mapper接口规范" class="headerlink" title="Mapper接口规范"></a>Mapper接口规范</h1><ol><li>Mapper.xml中的namespace和Mapper.java接口中的类路径相同，即<code>&lt;mapper namespace=&quot;cn.ddnd.www.Dao.User&quot;&gt;</code>对应的是<code>cn.ddnd.www.Dao</code>包下的<code>User</code>类。</li><li>Mapper.xml中的<code>select</code>ID要和Mapper.java接口中的类方法名相同，即<code>&lt;select id=&quot;getUser&quot; parameterType=&quot;String&quot; resultType=&quot;User&quot;&gt;</code>的<code>getUser</code>和<code>public User getUser(String email);</code>的<code>getUser</code>方法名对应。</li><li>Mapper.xml中的<code>parameterType</code>的类型要和Mapper接口中方法的<strong>传入参数类型</strong>相同。</li><li>Mapper.xml中的<code>resultType</code>的类型要和Mapper接口中方法的<strong>返回参数类型</strong>相同。</li></ol><h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><h2 id="配置Mapper-xml"><a href="#配置Mapper-xml" class="headerlink" title="配置Mapper.xml"></a>配置Mapper.xml</h2><p>IUser.xml：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace=&quot;cn.ddnd.www.Dao.IUser&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;getUser&quot; parameterType=&quot;String&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">        select * from user where email = #&#123;email&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></p><h2 id="配置Mapper-java接口"><a href="#配置Mapper-java接口" class="headerlink" title="配置Mapper.java接口"></a>配置Mapper.java接口</h2><p>IUser.java：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package cn.ddnd.www.Dao;</span><br><span class="line"></span><br><span class="line">import cn.ddnd.www.Entity.User;</span><br><span class="line"></span><br><span class="line">public interface IUser &#123;</span><br><span class="line">    public User getUser(String email);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="编写Mybatis配置文件"><a href="#编写Mybatis配置文件" class="headerlink" title="编写Mybatis配置文件"></a>编写Mybatis配置文件</h2><p>Mybatis-config.xml：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;typeAliases&gt;</span><br><span class="line">        &lt;typeAlias type=&quot;cn.ddnd.www.Entity.User&quot; alias=&quot;User&quot;&gt;&lt;/typeAlias&gt;</span><br><span class="line">    &lt;/typeAliases&gt;</span><br><span class="line">    &lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/spring?serverTimezone=GMT%2B8&quot; /&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource=&quot;cn/ddnd/www/Dao/IUser.xml&quot;&gt;&lt;/mapper&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p><h1 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h1><p>test.java：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import cn.ddnd.www.Dao.IUser;</span><br><span class="line">import cn.ddnd.www.Entity.User;</span><br><span class="line">import org.apache.ibatis.session.SqlSession;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.apache.ibatis.io.Resources;</span><br><span class="line"></span><br><span class="line">import java.io.Reader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line">    private static Reader reader;</span><br><span class="line">    private static SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    static&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            reader = Resources.getResourceAsReader(&quot;Mybatis-config.xml&quot;);</span><br><span class="line">            sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);</span><br><span class="line">        &#125;catch (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void a() throws IOException &#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        try&#123;</span><br><span class="line">            IUser IUser = (IUser) sqlSession.getMapper(IUser.class);</span><br><span class="line">            User user = IUser.getUser(&quot;xue8@qq.com&quot;);</span><br><span class="line">            System.out.println(&quot;用户的邮箱是：&quot; + user.getEmail() + &quot;，用户的名称是：&quot; + user.getName() + &quot;，用户的密码是：&quot; + user.getPassword());</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>IUser IUser = (IUser) sqlSession.getMapper(IUser.class);</code>sqlSession会帮我们生成一个实现类（给IUser接口）,这样即可获取IUser接口的代理对象。<code>User user = IUser.getUser(&quot;xue8@qq.com&quot;);</code>代理对象方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/e0e01e43gy1fxqf5iw6clj20m80cin0d.jpg&quot; style=&quot;width: 100%&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们在使用Mybatis的时候，获取需要执行的SQL语句的时候，都是通过调用xml文件来获取，例如：&lt;code&gt;User user = (User) sqlSession.selectOne(&amp;quot;cn.ddnd.www.Entity.User.getUser&amp;quot;, &amp;quot;xue8@qq.com&amp;quot;);&lt;/code&gt;。这种方式是通过字符串去调用标签定义的SQL语句，第一容易出错，第二是当xml当中的id修改过后你不知道在程序当中有多少个地方使用了这个id，需要手动一一修改。后来Mybatis推出了Mapper动态代理方式，只需要编写&lt;strong&gt;Mapper接口&lt;/strong&gt;（相当于Dao层）,由Mybatis框架根据接口定义创建接口的动态代理对象。&lt;/p&gt;
    
    </summary>
    
      <category term="Mybatis" scheme="http://ddnd.cn/categories/Mybatis-Programming/"/>
    
    
      <category term="Mybatis" scheme="http://ddnd.cn/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis接口注解实现映射</title>
    <link href="http://ddnd.cn/2018/11/30/Mybatis-Annotation/"/>
    <id>http://ddnd.cn/2018/11/30/Mybatis-Annotation/</id>
    <published>2018-11-30T07:50:28.000Z</published>
    <updated>2019-03-12T10:14:19.380Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fxq59jtsmsj20jk09mjr9.jpg" style="width:100%"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇文章介绍了xml文件映射SQL语句，即<code>User user = (User) sqlSession.selectOne(&quot;cn.ddnd.www.Entity.User.getUser&quot;, &quot;xue8@qq.com&quot;)</code>，但是这种方式过于繁杂，所以我们本篇介绍使用<strong>注解</strong>和<strong>SQL语句返回值的接口</strong>（如：IUser.class），即可实现xml配置文件的功能。<br><a id="more"></a></p><h1 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h1><p>将工程新建成和上篇的一样<a href="https://ddnd.cn/2018/11/29/Mybatis-Introduction/">Mybatis实现数据库操作</a>，即把上篇的内容搬过来。</p><h1 id="修改成用注解方式"><a href="#修改成用注解方式" class="headerlink" title="修改成用注解方式"></a>修改成用注解方式</h1><ol><li><p>可以删除 <code>cn.ddnd.www.Entity</code>包下的<code>User.xml</code>，去掉<code>Mybatis-config.xml</code>的如下代码。因为此时<code>User.xml</code>已经没用了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">    &lt;mapper resource=&quot;cn/ddnd/www/Entity/User.xml&quot;&gt;&lt;/mapper&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure></li><li><p>新建<code>cn.ddnd.www.Dao</code>包，并且建立<code>IUser</code>接口和方法。<br>IUser.java：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package cn.ddnd.www.Dao;</span><br><span class="line"></span><br><span class="line">import cn.ddnd.www.Entity.User;</span><br><span class="line">import org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line">public interface IUser &#123;</span><br><span class="line">    @Select(&quot;select * from user where email = #&#123;email&#125;&quot;)</span><br><span class="line">    public User getUser(String email);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改测试类，即增加了<code>sqlSessionFactory.getConfiguration().addMapper(IUser.class);</code>，作用是注册SQL语句映射的接口，去掉<code>User user = (User) sqlSession.selectOne(&quot;cn.ddnd.www.Entity.User.getUser&quot;, &quot;xue8@qq.com&quot;);</code>，增加<code>IUser IUser = (IUser) sqlSession.getMapper(IUser.class); User user = IUser.getUser(&quot;xue8@qq.com&quot;);</code>即可。<br>text.java：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import cn.ddnd.www.Dao.IUser;</span><br><span class="line">import cn.ddnd.www.Entity.User;</span><br><span class="line">import org.apache.ibatis.session.SqlSession;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.apache.ibatis.io.Resources;</span><br><span class="line"></span><br><span class="line">import java.io.Reader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line">    private static Reader reader;</span><br><span class="line">    private static SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    static&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            reader = Resources.getResourceAsReader(&quot;Mybatis-config.xml&quot;);</span><br><span class="line">            sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);</span><br><span class="line">//            注册SQL语句映射的接口</span><br><span class="line">            sqlSessionFactory.getConfiguration().addMapper(IUser.class);</span><br><span class="line">        &#125;catch (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void a() throws IOException &#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        try&#123;</span><br><span class="line">//            User user = (User) sqlSession.selectOne(&quot;cn.ddnd.www.Entity.User.getUser&quot;, &quot;xue8@qq.com&quot;);</span><br><span class="line"></span><br><span class="line">//            IUser.class只是个接口 Mybatis面向接口编程 只写接口 不用写接口的实现类 Mybatis帮我们去写实现类了！</span><br><span class="line">            IUser IUser = (IUser) sqlSession.getMapper(IUser.class);</span><br><span class="line">            User user = IUser.getUser(&quot;xue8@qq.com&quot;);</span><br><span class="line">            System.out.println(&quot;用户的邮箱是：&quot; + user.getEmail() + &quot;，用户的名称是：&quot; + user.getName() + &quot;，用户的密码是：&quot; + user.getPassword());</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><p><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fxq6alhwtcj20e90e6t9a.jpg" alt=""></p><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p>运行测试类<br><img src="https://ws1.sinaimg.cn/large/e0e01e43gy1fxq6bhkzs1j20pb06iq3a.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/e0e01e43gy1fxq59jtsmsj20jk09mjr9.jpg&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上一篇文章介绍了xml文件映射SQL语句，即&lt;code&gt;User user = (User) sqlSession.selectOne(&amp;quot;cn.ddnd.www.Entity.User.getUser&amp;quot;, &amp;quot;xue8@qq.com&amp;quot;)&lt;/code&gt;，但是这种方式过于繁杂，所以我们本篇介绍使用&lt;strong&gt;注解&lt;/strong&gt;和&lt;strong&gt;SQL语句返回值的接口&lt;/strong&gt;（如：IUser.class），即可实现xml配置文件的功能。&lt;br&gt;
    
    </summary>
    
      <category term="Mybatis" scheme="http://ddnd.cn/categories/Mybatis-Programming/"/>
    
    
      <category term="Mybatis" scheme="http://ddnd.cn/tags/Mybatis/"/>
    
  </entry>
  
</feed>
