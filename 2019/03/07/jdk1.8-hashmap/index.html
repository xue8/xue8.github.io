<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000">
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top">
  
  
  <title>HashMap从认识到源码分析 | 薛8的个人网站 - xue8&#39;s Blog - DDND.CN</title>
  <meta name="description" content="MapMap在开发过程中使用频率很高的数据结构，Map是Key-value键值对映射的抽象接口，该映射不包括重复的键，既一个键对应一个值。HashMap、HashTable、ConcurrentHashMap都是Java Collection Framework的重要成员。Map接口提供三种collection视图，允许以键集(keySet())、值集(values())或键-值映射关系集(e">
<meta name="keywords" content="HashMap">
<meta property="og:type" content="article">
<meta property="og:title" content="HashMap从认识到源码分析">
<meta property="og:url" content="http://ddnd.cn/2019/03/07/jdk1.8-hashmap/index.html">
<meta property="og:site_name" content="薛8的个人网站 - xue8&#39;s Blog - DDND.CN">
<meta property="og:description" content="MapMap在开发过程中使用频率很高的数据结构，Map是Key-value键值对映射的抽象接口，该映射不包括重复的键，既一个键对应一个值。HashMap、HashTable、ConcurrentHashMap都是Java Collection Framework的重要成员。Map接口提供三种collection视图，允许以键集(keySet())、值集(values())或键-值映射关系集(e">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://wx3.sinaimg.cn/large/e0e01e43ly1g0vf2bq3xgj21g80ytkjm.jpg">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/3/7/169575a7d1acb827?w=1018&h=636&f=png&s=48415">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/3/7/16957dc37460bcb7?w=541&h=336&f=png&s=15864">
<meta property="og:image" content="http://ws4.sinaimg.cn/large/e0e01e43ly1g0vezgvmdvj211l0jnq8d.jpg">
<meta property="og:image" content="http://ws2.sinaimg.cn/large/e0e01e43ly1g0vezylsa5j20he0dhwg2.jpg">
<meta property="og:image" content="http://ws4.sinaimg.cn/large/e0e01e43ly1g0vf07q9plj20vt0ldacm.jpg">
<meta property="og:image" content="http://wx4.sinaimg.cn/large/e0e01e43ly1g0vf0g8sq8j20q10netbf.jpg">
<meta property="og:image" content="http://ws2.sinaimg.cn/large/e0e01e43ly1g0vf0lbaphj20fo0b0ab8.jpg">
<meta property="og:updated_time" content="2019-03-13T11:11:49.458Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HashMap从认识到源码分析">
<meta name="twitter:description" content="MapMap在开发过程中使用频率很高的数据结构，Map是Key-value键值对映射的抽象接口，该映射不包括重复的键，既一个键对应一个值。HashMap、HashTable、ConcurrentHashMap都是Java Collection Framework的重要成员。Map接口提供三种collection视图，允许以键集(keySet())、值集(values())或键-值映射关系集(e">
<meta name="twitter:image" content="http://wx3.sinaimg.cn/large/e0e01e43ly1g0vf2bq3xgj21g80ytkjm.jpg">
  <!-- Canonical links -->
  <link rel="canonical" href="http://ddnd.cn/2019/03/07/jdk1.8-hashmap/index.html">
  
    <link rel="alternate" href="/atom.xml" title="薛8的个人网站 - xue8&#39;s Blog - DDND.CN" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  <link rel="stylesheet" href="/css/style.css">
  
  
  
  
</head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope="" itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/xue8" target="_blank">
          <img class="img-circle img-rotate" src="/img/logo.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">薛8</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Web Developer</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Guiling, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="Search">
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="Type something..." x-webkit-speech="">
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope="" itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">Home</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">Archives</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">Categories</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">Tags</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">Links</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">About</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/xue8" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope="" itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">Board</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java-Programming/">Java编程基础</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mybatis-Programming/">Mybatis</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Shiro/">Shiro</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Programming/">Spring</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-MVC/">Spring MVC</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Technique/">技术杂谈</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Computer-Foundation/">计算机基础</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-body">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AQS/">AQS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CAS/">CAS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ConcurrentHashMap/">ConcurrentHashMap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/">HashMap</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hashtable/">Hashtable</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java内存模型/">Java内存模型</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jdbc/">Jdbc</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVC/">MVC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/">Mybatis</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTful/">RESTful</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPC/">RPC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shiro/">Shiro</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-MVC/">Spring MVC</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-MVC/">Spring-MVC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TEA算法/">TEA算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TomcatDBCP/">TomcatDBCP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebSocket/">WebSocket</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/">servlet</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/volatile/">volatile</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web-xml/">web.xml</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机内存模型/">计算机内存模型</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/连接池/">连接池</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/AQS/" style="font-size: 13px;">AQS</a> <a href="/tags/CAS/" style="font-size: 13px;">CAS</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 13px;">ConcurrentHashMap</a> <a href="/tags/HashMap/" style="font-size: 13.33px;">HashMap</a> <a href="/tags/Hashtable/" style="font-size: 13.33px;">Hashtable</a> <a href="/tags/Java内存模型/" style="font-size: 13px;">Java内存模型</a> <a href="/tags/Jdbc/" style="font-size: 13.67px;">Jdbc</a> <a href="/tags/MVC/" style="font-size: 13px;">MVC</a> <a href="/tags/Mybatis/" style="font-size: 14px;">Mybatis</a> <a href="/tags/RESTful/" style="font-size: 13px;">RESTful</a> <a href="/tags/RPC/" style="font-size: 13px;">RPC</a> <a href="/tags/Shiro/" style="font-size: 13.33px;">Shiro</a> <a href="/tags/Spring/" style="font-size: 14px;">Spring</a> <a href="/tags/Spring-MVC/" style="font-size: 13.33px;">Spring MVC</a> <a href="/tags/Spring-MVC/" style="font-size: 13px;">Spring-MVC</a> <a href="/tags/TEA算法/" style="font-size: 13px;">TEA算法</a> <a href="/tags/TomcatDBCP/" style="font-size: 13px;">TomcatDBCP</a> <a href="/tags/WebSocket/" style="font-size: 13px;">WebSocket</a> <a href="/tags/servlet/" style="font-size: 13px;">servlet</a> <a href="/tags/volatile/" style="font-size: 13px;">volatile</a> <a href="/tags/web-xml/" style="font-size: 13px;">web.xml</a> <a href="/tags/多线程/" style="font-size: 14px;">多线程</a> <a href="/tags/计算机内存模型/" style="font-size: 13px;">计算机内存模型</a> <a href="/tags/连接池/" style="font-size: 13px;">连接池</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">Archive</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">12</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2019/03/19/java-synchronized/" class="title">java-synchronized</a>
              </p>
              <p class="item-date">
                <time datetime="2019-03-19T10:14:36.000Z" itemprop="datePublished">2019-03-19</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Java-Programming/">Java编程基础</a>
              </p>
              <p class="item-title">
                <a href="/2019/03/19/java-volatile/" class="title">Java volatile关键字解析</a>
              </p>
              <p class="item-date">
                <time datetime="2019-03-19T07:21:09.000Z" itemprop="datePublished">2019-03-19</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Java-Programming/">Java编程基础</a>
              </p>
              <p class="item-title">
                <a href="/2019/03/15/java-abstractqueuedsynchronizer/" class="title">一文带你快速掌握AQS</a>
              </p>
              <p class="item-date">
                <time datetime="2019-03-15T13:53:03.000Z" itemprop="datePublished">2019-03-15</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Java-Programming/">Java编程基础</a>
              </p>
              <p class="item-title">
                <a href="/2019/03/13/java-cas/" class="title">CAS原理分析及ABA问题详解</a>
              </p>
              <p class="item-date">
                <time datetime="2019-03-13T09:09:33.000Z" itemprop="datePublished">2019-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Java-Programming/">Java编程基础</a>
              </p>
              <p class="item-title">
                <a href="/2019/03/11/java-memory-model/" class="title">什么是Java内存模型？</a>
              </p>
              <p class="item-date">
                <time datetime="2019-03-11T08:24:28.000Z" itemprop="datePublished">2019-03-11</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope="" itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">Catalogue</h3>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Map"><span class="toc-number">1.</span> <span class="toc-text">Map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HasH表"><span class="toc-number">2.</span> <span class="toc-text">HasH表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap"><span class="toc-number">3.</span> <span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据结构"><span class="toc-number">3.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数"><span class="toc-number">3.2.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#put方法"><span class="toc-number">3.3.</span> <span class="toc-text">put方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get方法"><span class="toc-number">3.4.</span> <span class="toc-text">get方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#remove方法"><span class="toc-number">3.5.</span> <span class="toc-text">remove方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#containsKey方法"><span class="toc-number">3.6.</span> <span class="toc-text">containsKey方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哈希表的初始化和加倍扩容resize方法"><span class="toc-number">3.7.</span> <span class="toc-text">哈希表的初始化和加倍扩容resize方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">4.</span> <span class="toc-text">参考资料</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-jdk1.8-hashmap" class="article article-type-post" itemscope="" itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      HashMap从认识到源码分析
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2019/03/07/jdk1.8-hashmap/" class="article-date">
	  <time datetime="2019-03-07T07:58:20.000Z" itemprop="datePublished">2019-03-07</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Java-Programming/">Java编程基础</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/HashMap/">HashMap</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2019/03/07/jdk1.8-hashmap/#comments" class="article-comment-link">Comments</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">Word Count: 5.9k(words)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">Read Count: 23(minutes)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <a id="more"></a>
<p><img src="http://wx3.sinaimg.cn/large/e0e01e43ly1g0vf2bq3xgj21g80ytkjm.jpg" alt="image" width="100%"></p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map在开发过程中使用频率很高的数据结构，Map是<code>Key-value</code>键值对映射的抽象<strong>接口</strong>，该映射不包括重复的键，既一个键对应一个值。<code>HashMap</code>、<code>HashTable</code>、<code>ConcurrentHashMap</code>都是Java Collection Framework的重要成员。Map接口提供三种collection视图，允许以键集(keySet())、值集(values())或键-值映射关系集(entrySet())的形式查看某个映射的内容。<br><img src="https://user-gold-cdn.xitu.io/2019/3/7/169575a7d1acb827?w=1018&amp;h=636&amp;f=png&amp;s=48415" alt=""></p>
<h2 id="HasH表"><a href="#HasH表" class="headerlink" title="HasH表"></a>HasH表</h2><p>我们知道数组的储存方式是在内存上分配固定的连续的空间，寻址速度快（查询速度快），时间复杂度为<code>O(1)</code>，但是在插入、删除元素时候需要移动数组的元素，所以插入、删除时候速度慢，时间复杂度为<code>O(n)</code>。链表的存储方式在内存上是不连续的，每个元素都保存着下个元素的内存地址，通过这个地址找到下个元素，所以链表在查询的时候速度慢，时间复杂度为<code>O(n)</code>，在插入和删除的时候速度快，时间复杂度为<code>O(1)</code>。<br>如果我们想要一个数据结构既查询速度快，插入和删除速度也要快，那我们应该怎么做呢？这时<strong>哈希(Hash)表</strong>就应时而生了，通过<strong>哈希函数</strong>计算出<strong>键</strong>在哈希表中指定的储存位置(注意这里的储存位置是在表中的位置，并不是内存的地址)，称为哈希地址，然后将值储存在这个哈希地址上，然后通过<strong>键</strong>就可以直接操作到<strong>值</strong>，查询、插入、删除等操作时间复杂度都是<code>O(1)</code>。<br>既然是键通过哈希函数计算出储存位置，那么哈希函数的好坏直接影响到哈希表的操作效率，如会出现浪费储存空间、出现大量冲突(即不同的键计算出来的储存位置一样)。     </p>
<blockquote>
<p>哈希函数可以将任意长度的输入映射成固定长度的输出，也就是哈希地址<br>哈希冲突是不可避免的，常用的哈希冲突解决办法有以下2种方法。            </p>
</blockquote>
<ol>
<li><strong>链地址法(拉链法)</strong><br>采用数组和链表结合的方法，对哈希表中每个哈希地址建立一个线性表，将哈希地址相同的数据储存在线性表中，并将<strong>链表的头指针保存在数组中</strong>，哈希地址、键、值等信息一般保存在链表节点中。一般通过哈希地址计算出数组的下标，将哈希值相同的保存在下标相同的数组中的。拉链法适合经常进行插入、删除操作的情况。<br><img src="https://user-gold-cdn.xitu.io/2019/3/7/16957dc37460bcb7?w=541&amp;h=336&amp;f=png&amp;s=15864" alt=""></li>
<li><strong>开放定址法</strong><br>开放定址法也称线性探测法，基本思想是：将哈希表T[0…m-1]看成是个循环向量，若初始探测地址为d，则最长的探测路径为：d，d+i，d+2i，…，m-1。即探测时候从地址d开始，首先探测T[d]，如果T[d]发生哈希冲突则继续探测下一个T[d+1]…直到探测到T[m-1]为止，i为自定义的常数。开放定址法很容易产生<strong>堆聚现象</strong>，所谓堆聚现象就是哈希表中的数据连成一片，在加入新元素的时候就容易产生哈希冲突。</li>
<li><strong>拉链法和开放定址比较</strong><br>拉链法：处理冲突简单，无堆聚现象，同时链表插入、删除操作简单，所以拉链法适合经常进行插入、删除操作的情况。<br>开放定址法：为了减少冲突，要求<strong>负载因子(装填因子)</strong>较小，当节点规模较大时候会浪费很多空间。且开放定址法在删除节点的时候，不能简单的将节点所在的空间置为空，否则将截断在它之后的节点的查找路径，这是因为各种开放定址法中，<strong>空地址单元都是查找失败的条件</strong>。因此在进行删除节点操作的时候，需要使用逻辑删除，即在被删除的节点上做删除标记。                   </li>
</ol>
<blockquote>
<p>负载因子 = 填入哈希表中的元素个数 / 哈希表的数组长度   </p>
</blockquote>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><code>HashMap</code>采用上述的<strong>拉链法</strong>解决哈希冲突.HashMap是非线程安全的，允许键、值为<code>null</code>，不保证有序(比如插入的顺序)，也不保证顺序不随时间变化(哈希表加倍扩容后，数据会有迁移)。<br>我们创建个HashMap运行看看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; map = new HashMap();</span><br><span class="line">map.put(&quot;语文&quot;, 1);</span><br><span class="line">map.put(&quot;数学&quot;, 2);</span><br><span class="line">map.put(&quot;英语&quot;, 3);</span><br><span class="line">map.put(&quot;历史&quot;, 4);</span><br><span class="line">map.put(&quot;政治&quot;, 5);</span><br><span class="line">map.put(&quot;地理&quot;, 6);</span><br><span class="line">map.put(&quot;生物&quot;, 7);</span><br><span class="line">map.put(&quot;化学&quot;, 8);</span><br></pre></td></tr></table></figure></p>
<p><img src="http://ws4.sinaimg.cn/large/e0e01e43ly1g0vezgvmdvj211l0jnq8d.jpg" alt="image"><br>通过图可以看到HashMap并不是按照插入顺序存储的(无序的)。<br>接下来我们看看HashMap的<strong>数据结构</strong><br><img src="http://ws2.sinaimg.cn/large/e0e01e43ly1g0vezylsa5j20he0dhwg2.jpg" alt="image"><br>HashMap有几个重要的成员变量，<code>table</code>，<code>size</code>，<code>threshold</code>，<code>loadFactor</code>，<code>modCount</code>。</p>
<ul>
<li>table：是一个<code>Entry[]</code>数组类型，而<code>Entry</code>实际上是一个<strong>单向链表</strong>，哈希表的键值对都是储存在<code>Entry</code>数组中，每个<code>Entry</code>对应一个哈希地址，这里的<code>Entry</code>即常说的桶</li>
<li>size：是HashMap的大小，为保存的键值对的数量</li>
<li>DEFAULT_INITIAL_CAPACITY：HashMap默认容量(数组的大小) 默认为16</li>
<li>MAXIMUM_CAPACITY：HashMap的最大容量(2的30)，如果传入的容量大于这个值，则被最大容量替换</li>
<li>threshold：是HashMap的阈值，用于判断是否需要调整HashMap的容量。threshold=容量*负载因子，当HashMap中储存的键值对数量到达threshold时，HashMap就会将容量<strong>加倍</strong>的扩容</li>
<li>loadFactor：即负载因子</li>
<li>modCount：用来实现<strong>快速失败(fail-fast)机制</strong>的<blockquote>
<p>快速失败机制：对于<strong>线程不安全</strong>(注意是线程不安全的集合才有这个机制)的集合对象的迭代器，如果在使用迭代器的过程中有其他的线程修改了集合对象的结构或者元素数量，那么迭代立刻结束，迭代器将抛出<code>ConcurrentModificationException</code>。</p>
</blockquote>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3>HashMap有4个构造函数，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//无参构造函数，负载因子为默认的0.75，HashMap的容量(数组大小)默认容量为16</span><br><span class="line">public HashMap() &#123;</span><br><span class="line">    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//指定HashMap容量大小的构造函数 负载因子为默认的0.75</span><br><span class="line">public HashMap(int initialCapacity) &#123;</span><br><span class="line">    this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//指定HashMap容量大小和负载因子的构造函数</span><br><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    this.loadFactor = loadFactor;</span><br><span class="line">    this.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//包含子Map的构造函数，负载因子为默认的0.75</span><br><span class="line">public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">    this.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>为什么负载因子默认是0.75？按照官方给出的解释是，当负载因子为0.75时候，<code>Entry</code>单链表的长度几乎不可能超过<code>8</code>(到达8的概率是0.00000006)，作用就是让<code>Entry</code>单链表的长度尽量小，让HashMap的查询效率尽可能高。</p>
</blockquote>
<p>由于当HashMap的大小(即size)大于初始容量(capacity)时候，HashMap就会扩大一倍，由于很多时候并不需要扩大这么多，所以当我们知道我们的数据的大小的时候，就可以在HashMap初始化的时候指定容量(数组大小)。<br>需要注意的是，我们指定的容量必须是<strong>2的幂次方</strong>，即使我们传入的容量不是2的幂次方，源码中也会将容量转成2的幂次方，比如我们传入的是5，最终的容量是8。</p>
<blockquote>
<p>为什么容量一定要是2的幂次方？因为HashMap是数组+单链表的结构，我们希望元素的存放的更均匀，最理想的状态是每个<code>Entry</code>中只存放一个元素，这样在查询的时候效率最高。那怎么才能均匀的存放呢？我们首先想到的是取模运算 哈希地址%容量大小，SUN的大师们的想法和我们的也一样，只不过他们使用位运算来实现这个运算(位运算效率高)，为了使位运算和取模运算结果一样，即<code>hash &amp; (capacity - 1) == hash % capacity</code>，容量(Capacity)的大小就必须为2的幂次方。</p>
</blockquote>
<h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><p>在JDK1.8之前hashMap的插入是在链表的头部插入的，本文分析的是JDK1.8源码，是在链表的尾部插入的。     </p>
<ol>
<li>根据键(key)的<code>hashCode()</code>计算出当前键值对的<strong>哈希地址</strong>，用于定位键值对在HashMap数组中存储的下标</li>
<li>判断<code>table</code>是否初始化，没有初始化则调用<code>resize()</code>为<code>table</code>初始化容量，以及threshold的值</li>
<li>根据<strong>table数组长度和哈希地址做&amp;运算(i = (n - 1) &amp; hash)</strong>计算出该key对应的<code>table</code>数组索引，如果对应的数组索引位置没有值，则调用<code>newNode(hash, key, value, null)</code>方法，为该键值对创建节点。<blockquote>
<p>这里思考个问题，当table数组长度变化后，是不是取到的值就不正确了？后面给出分析。这里简单分析下为什么不是直接按照哈希地址做数组下标，而是用<strong>table数组长度和哈希地址做&amp;运算(i = (n - 1) &amp; hash)</strong>(因为数组的大小是2的幂次方，所以这个运算等效于mod 数组大小的运算)计算数组下标，因为哈希地址可能超过数组大小，还有就是为了让键值对更均匀的分布的在各个桶(链表)中，也因为容量会变所以各个桶(链表)中的节点的哈希地址并不是相同的，相同的哈希地址也可能分到不同的下标。</p>
</blockquote>
</li>
<li>如果根据哈希地址计算出该key对应的<code>table</code>数组索引有节点，且节点的键<code>key</code>和传入的键<code>key</code>相等，哈希地址和传入的哈希地址也相等，<strong>则将对应的节点引用赋值给e</strong>。</li>
<li>如果根据哈希地址计算出该key对应的<code>table</code>数组索引有节点，且节点的哈希地址和传入的哈希地址一样，但是节点的键<code>key</code>和传入的键<code>key</code>不相等，则遍历链表，如果遍历过程中找到节点的键<code>key</code>和传入的键<code>key</code>相等，哈希地址和传入的哈希地址也相等，则将对应的<code>value</code>值更新。否则调用<code>newNode(hash, key, value, null)</code>方法，为该键值对创建节点添加到链表<strong>尾部</strong>，如果追加节点后的链表长度 &gt;= 8，则转为红黑树</li>
<li>如果e不为空，且<code>onlyIfAbsent</code>为<code>true</code>则不会覆盖相同<code>key</code>和相同哈希地址的<code>value</code>。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果参数onlyIfAbsent是true，那么不会覆盖相同key的值value。如果evict是false。那么表示是在初始化时调用的</span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    //tab存放 当前的哈希桶， p用作临时链表节点  </span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    //如果当前哈希表是空的，代表是初始化</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        //那么直接去扩容哈希表，并且将扩容后的哈希桶长度赋值给n</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    //如果当前index的节点是空的，表示没有发生哈希碰撞。 直接构建一个新节点Node，挂载在index处即可。</span><br><span class="line">    //这里再啰嗦一下，数组下标index 是利用 哈希地址 &amp; 哈希桶的长度-1，替代模运算</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123;//否则 发生了哈希冲突。</span><br><span class="line">        //e</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        //如果哈希值相等，key也相等，则是覆盖value操作</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;//将当前节点引用赋值给e</span><br><span class="line">        else if (p instanceof TreeNode)//红黑树暂且不谈</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123;//不是覆盖操作，则插入一个普通链表节点</span><br><span class="line">            //遍历链表</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                if ((e = p.next) == null) &#123;//遍历到尾部，追加新节点到尾部</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    //如果追加节点后，链表数量》=8，则转化为红黑树</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //如果找到了要覆盖的节点</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果e不是null，说明有需要覆盖的节点，</span><br><span class="line">        if (e != null) &#123; // existing mapping for key</span><br><span class="line">            //则覆盖节点值，并返回原oldValue</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            //这是一个空实现的函数，用作LinkedHashMap重写使用。</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果执行到了这里，说明插入了一个新的节点，所以会修改modCount，以及返回null。</span><br><span class="line"></span><br><span class="line">    //修改modCount</span><br><span class="line">    ++modCount;</span><br><span class="line">    //更新size，并判断是否需要扩容。</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    //这是一个空实现的函数，用作LinkedHashMap重写使用。</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>hashCode()是Object类的一个方法，hashCode()方法返回对象的hash code，这个方法是为了更好的支持hash表，比如Set、HashTable、HashMap等。hashCode()的作用：如果用equals去比较的话，如果存在1000个元素，你new一个新的元素出来，需要去调用1000次equals去逐个和它们比较是否是同一个对象，这样会大大降低效率。ashcode实际上是返回对象的存储地址，如果这个位置上没有元素，就把元素直接存储在上面，如果这个位置上已经存在元素，这个时候才去调用equal方法与新元素进行比较，相同的话就不存了，散列到其他地址上。</p>
</blockquote>
<h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><ol>
<li><code>table</code>不为空，且<code>table</code>的长度大于0，且根据键<code>key</code>的<code>hashCode()</code>计算出<strong>哈希地址</strong>，再<strong>根据桶的数量-1和哈希地址做&amp;运算</strong>计算出数组的下标，该下标下不为空(即存有链表头指针)则继续往下进行，否则返回<code>null</code>。</li>
<li>如果和第一个节点的哈希地址、键<code>key</code>都相同，则返回第一个节点。</li>
<li>如果第一个节点的下个节点不为空，则继续，如果第一个节点为树的节点，则执行<code>getTreeNode(hash, key)</code>，在树中寻找节点，并且返回。否则遍历链表，找到键<code>key</code>、哈希地址一样的则返回此节点。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        if (first.hash == hash &amp;&amp; // 如果索引到的第一个Node，key 和 hash值都和传递进来的参数相等，则返回该Node</span><br><span class="line">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        if ((e = first.next) != null) &#123; //如果索引到的第一个Node 不符合要求，循环变量它的下一个节点。</span><br><span class="line">            if (first instanceof TreeNode) // 在树中get</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            do &#123;// 在链表中get</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><ol>
<li><code>table</code>不为空，且<code>table</code>的长度大于0，且根据键<code>key</code>的<code>hashCode()</code>计算出<strong>哈希地址</strong>，再根据哈希地址计算出数组的下标，该下标下不为空(即存有链表头指针)则继续往下进行，否则执行6`。</li>
<li>如果哈希地址、键<code>key</code>一样，<strong>则将对应的节点引用赋值给node</strong>，然后执行4。否则执行3。</li>
<li>如果为树，则执行<code>getTreeNode(hash, key)</code>在树中寻找节点并且返回，否则遍历链表，找到键<code>key</code>、哈希地址一样的节点然后<strong>将对应的节点引用赋值给node</strong>，然后执行4，否则执行6。</li>
<li>如果节点<code>node</code>不为空(即查询到键<code>key</code>对应的节点)，且当<code>matchValue</code>为<code>false</code>的时候或者<code>value</code>也相等的时候，则执行5，否则执行6。</li>
<li>如果节点为树，则调用<code>removeTreeNode(this, tab, movable)</code>移除相应的节点。否则在链表中移除相应的节点，</li>
<li>返回<code>null</code>。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = removeNode(hash(key), key, null, false, true)) == null ?</span><br><span class="line">        null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,</span><br><span class="line">                           boolean matchValue, boolean movable) &#123;</span><br><span class="line">    // p 是待删除节点的前置节点</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;</span><br><span class="line">    //如果哈希表不为空，则根据hash值算出的index下 有节点的话。</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        //node是待删除节点</span><br><span class="line">        Node&lt;K,V&gt; node = null, e; K k; V v;</span><br><span class="line">        //如果链表头的就是需要删除的节点</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;//将待删除节点引用赋给node</span><br><span class="line">        else if ((e = p.next) != null) &#123;//否则循环遍历 找到待删除节点，赋值给node</span><br><span class="line">            if (p instanceof TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            else &#123;</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; while ((e = e.next) != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果有待删除节点node，  且 matchValue为false，或者值也相等</span><br><span class="line">        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != null &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            if (node instanceof TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);</span><br><span class="line">            else if (node == p)//如果node ==  p，说明是链表头是待删除节点</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            else//否则待删除节点在表中间</span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;//修改modCount</span><br><span class="line">            --size;//修改size</span><br><span class="line">            afterNodeRemoval(node);//LinkedHashMap回调函数</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="containsKey方法"><a href="#containsKey方法" class="headerlink" title="containsKey方法"></a>containsKey方法</h3><p>如果存在指定的键<code>key</code>，返回true，否则返回false。<br>containsKey方法调用的get调用的方法一样的方法，参考get方法的解析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean containsKey(Object key) &#123;</span><br><span class="line">    return getNode(hash(key), key) != null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="哈希表的初始化和加倍扩容resize方法"><a href="#哈希表的初始化和加倍扩容resize方法" class="headerlink" title="哈希表的初始化和加倍扩容resize方法"></a>哈希表的初始化和加倍扩容resize方法</h3><p>分析resize方法，我们就可以知道为什么哈希表的容量变化后，仍然能取到正确的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    //如果哈希表是空的 则将旧容量置为0，否则置为旧哈希表的容量</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    //旧的哈希表的阈值</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    //新的哈希表的容量和阈值 都置为0</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    //如果旧的容量大于0 即不是第一次初始化 是扩容操作</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        //旧的容量是否大于2的30次幂方(容量的最大值)</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            //阈值设置为Integer的最大值</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            //返回旧的哈希表(旧的哈希表已经到最大的容量了，不能继续扩容 所以返回)</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        //新的哈希表容量的=旧的容量&lt;&lt;1，即新的容量=旧的2倍，如果新的容量小于2的30次幂方(容量的最大值) 且 旧的容量大于等于默认的容量(16)</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            //新的哈希表的阈值=旧的哈希表的阈值&lt;&lt;1，既即新的阈值=旧的2倍 扩容table</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    //第一次初始化，如果旧的阈值&gt;0 即HashMap是以传入容量大小或者传入容量大小、负载因子的构造函数进行初始化的，阈值threshlod已经在构造函数初始化过了，所以阈值在这里大于0</span><br><span class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">        //新的容量=旧的阈值</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    //如果是以无参构造函数进行初始化的，则 新的容量大小=默认的容量大小，新的阈值=默认的负载因子*默认的容量大小</span><br><span class="line">    else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    //新的阈值=0，即执行的是上面的else if (oldThr &gt; 0)(使用带参数的构造函数初始化)，是使用带参数的构造函数进行的初始化，并且计算出新的阈值</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">    //创建新的哈希表，容量为新的容量</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    //重点看这部分，如果旧的哈希表不为空</span><br><span class="line">    if (oldTab != null) &#123;</span><br><span class="line">        //遍历旧的哈希表，</span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            //如果旧的哈希表的节点不为空</span><br><span class="line">            if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                oldTab[j] = null;</span><br><span class="line">                //如果节点没有下个节点了(即只有一个节点)，则直接放到新的哈希表中</span><br><span class="line">                if (e.next == null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                else &#123; // preserve order</span><br><span class="line">                    //将旧的哈希表的节点全部重新定位，比如旧的哈希表容量是16，有一个值a放在数组下标为0上，现在新的哈希表容量是32，重新定位后值a就被重新定位到下标为32上，即新的哈希表的下标为32储存值a，简单来说就是 新的下标=旧的哈希表的下标+新的哈希表的容量，正是因为这个节点的迁移，所以我们在hashMap put get操作的时候，在哈希表容量变化后仍让取到正确的值，但是也因为这个迁移操作，</span><br><span class="line">                    会消耗很多资源，所以尽量在创建HashMap的时候就估计哈希表的容量，尽量不要让他加倍扩容。这里的迁移也都是运用的位运算，所以在初始化的时候，桶的数量必须是2</span><br><span class="line">                    幂次方，才能保证位运算和取模运算结果一样。</span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                            if (loTail == null)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail == null)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e = next) != null);</span><br><span class="line">                    if (loTail != null) &#123;</span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (hiTail != null) &#123;</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以运行个例子，调试看看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; map = new HashMap();</span><br><span class="line">for (int i = 1; i &lt;= 24; i ++) &#123;</span><br><span class="line">    map.put(String.valueOf(i), i);</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 25; i &lt;= 80; i ++) &#123;</span><br><span class="line">    map.put(String.valueOf(i), i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们以无参构造函数(即哈希表容量默认是16，负载因子默认是0.75)<code>new</code>一个HashMap，然后调试看看</p>
<p><img src="http://ws4.sinaimg.cn/large/e0e01e43ly1g0vf07q9plj20vt0ldacm.jpg" alt="image"><br>运行第一个<code>for</code>循环，看到<code>11</code>保存的下标为0，<code>12</code>保存的下标是1<br>在继续运行第二个<code>for</code>，发现下标为0的变成了44，下标为1的变成了45<br><img src="http://wx4.sinaimg.cn/large/e0e01e43ly1g0vf0g8sq8j20q10netbf.jpg" alt="image"><br>那我们的11和12保存在哪了？可以发现11和12到了下标为32、33上，即当执行第二个<code>for</code>的时候哈希表发生了扩容，然后节点都迁移了，新的下标=旧的下标+新的哈希表的容量<br><img src="http://ws2.sinaimg.cn/large/e0e01e43ly1g0vf0lbaphj20fo0b0ab8.jpg" alt="image"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://user-gold-cdn.xitu.io/2019/3/8/1695c2ad3c842d8a" target="_blank" rel="noopener">Java HashMap工作原理及实现</a><br><a href="https://blog.csdn.net/justloveyou_/article/details/62893086" target="_blank" rel="noopener">Map 综述（一）：彻头彻尾理解 HashMap</a>      </p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://ddnd.cn/2019/03/07/jdk1.8-hashmap/" title="HashMap从认识到源码分析" target="_blank" rel="external">http://ddnd.cn/2019/03/07/jdk1.8-hashmap/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/xue8" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/img/logo.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/xue8" target="_blank"><span class="text-dark">薛8</span><small class="ml-1x">Web Developer</small></a></h3>
        <div>个人简介。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom="">
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2019/03/08/jdk1-8-hashtable/" title="五分钟看懂Hashtable源码以及与HashMap的区别"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;Newer</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2019/02/16/byte-hex-ascii/" title="计算机如何储存数字和字符"><span>Older&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="Catalogue" role="button">
        <span>[&nbsp;</span><span>Catalogue</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope="" itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/xue8" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script src="/js/plugin.min.js"></script>
<script src="/js/application.js"></script>

    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>





   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>