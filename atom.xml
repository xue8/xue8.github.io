<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>薛8的个人网站 - xue8&#39;s Blog - DDND.CN</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ddnd.cn/"/>
  <updated>2019-11-21T06:44:56.157Z</updated>
  <id>http://ddnd.cn/</id>
  
  <author>
    <name>薛8</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>filter(过滤器)、interceptor(拦截器)、aspect(切面)【转载】</title>
    <link href="http://ddnd.cn/2019/11/21/filter-interceptor-aspect/"/>
    <id>http://ddnd.cn/2019/11/21/filter-interceptor-aspect/</id>
    <published>2019-11-21T06:17:05.000Z</published>
    <updated>2019-11-21T06:44:56.157Z</updated>
    
    <content type="html"><![CDATA[<p>在工作中如何选择拦截机制去处理我们的业务请求，过滤器，拦截器，还是切面的选择一直比较模糊，今天花时间整理一下。<strong>这三者都是 AOP 的一种实现【转载者注】。</strong></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="Filter（过滤器）"><a href="#Filter（过滤器）" class="headerlink" title="Filter（过滤器）"></a>Filter（过滤器）</h2><p>首先，过滤器是服务端的一个组件，是基于servlet实现从客户端访问服务端web资源的一种拦截机制，对请求request和响应response都进行过滤，依赖于serverlet容器，使用时，实现Filter接口，在web.xml里配置对应的class还有mapping-url，springboot工程可以通FilterRegisteration配置后,设置要过滤的URL， <em>注意</em>  两种方式过滤器都是有序的，谁在前就先调用谁！定义过滤器后会重写三个方法，分别是init(),doFilter(),和destory(),</p><ul><li><p>init方法是过滤器的初始化方法，当web容器创建这个bean的时候就会执行，这个方法可以读取web.xml里面的参数</p></li><li><p>doFilter方法是执行过滤的请求的核心，当客户端请求访问web资源时，这个时候我们可以拿到request里面的参数，对数据进行处理后，通过filterChain方法将请求将请求放行，放行后我们也可以通过response对响应进行处理（比如压缩响应），然后会传递到下一个过滤器</p></li><li><p>destory方法是当web容器中的过滤器实例被销毁时，会被执行，释放资源</p></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author wtzhouc@gmail.com</span></span><br><span class="line"><span class="comment"> * @date 2019-04-12 19:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TimeFilter</span> <span class="title">implements</span> <span class="title">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span>(<span class="params">FilterConfig filterConfig</span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"过滤器初始化"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span>(<span class="params">ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain</span>) throws IOException, ServletException</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"过滤器执行了"</span>);</span><br><span class="line">        <span class="keyword">long</span> start2 = System.currentTimeMillis();</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis() - start2;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"过滤器执行的时间是 ："</span> + time);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"过滤器执行结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"过滤器销毁了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&lt;/pre&gt;</span><br></pre></td></tr></table></figure><p>spring boot工程可以通过加@Component注解添加进spring管理，也可以通过下面注册的方式去执行，推荐用下方的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">timeFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FilterRegistrationBean filterRegistrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">    TimeFilter filter = <span class="keyword">new</span> TimeFilter();</span><br><span class="line">    filterRegistrationBean.setFilter(filter);</span><br><span class="line">    filterRegistrationBean.addUrlPatterns(<span class="string">"/user"</span>,<span class="string">"/users"</span>);</span><br><span class="line">    <span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">&#125;</span><br><span class="line">    接下来，我们可以看下图示的过滤器执行流程和生命周期，就能很好的理解Filter了</span><br></pre></td></tr></table></figure><blockquote><p>流程图</p><p><img src="https:////upload-images.jianshu.io/upload_images/6619796-1ed03d5be99285be.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p><p>image.png</p><p>生命周期</p><p><img src="https:////upload-images.jianshu.io/upload_images/6619796-729c020b5ca0f90c.png?imageMogr2/auto-orient/strip|imageView2/2/w/640/format/webp" alt="img"></p><p>image.png</p></blockquote><h2 id="interceptor（拦截器）"><a href="#interceptor（拦截器）" class="headerlink" title="interceptor（拦截器）"></a>interceptor（拦截器）</h2><p>拦截器，顾名思义，他的作用就是拦截，这个要和过滤器区分开，过滤器依赖serverlet容器，获取request和response处理，是基于函数回调，简单说就是“去取你想取的”，拦截器是通过java反射机制，动态代理来拦截web请求，是“拒你想拒绝的”，他只拦截web请求，但不拦截静态资源，Struts2里面就是将拦截器串联，实现对请求的处理，下面以spring 的拦截器为例，写个demo</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author wtzhouc@gmail.com</span></span><br><span class="line"><span class="comment"> * @date 2019-04-13 14:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="title">implements</span> <span class="title">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">preHandle</span>(<span class="params">HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object hanlder</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">out</span>.println(<span class="string">"拦截器.preHandle 开始执行。。。"</span>);</span><br><span class="line">        <span class="keyword">out</span>.println(hanlder.getClass().getSimpleName());</span><br><span class="line">        <span class="keyword">out</span>.println(((HandlerMethod) hanlder).getBean().getClass().getName());</span><br><span class="line">        httpServletRequest.setAttribute(<span class="string">"start"</span>, currentTimeMillis());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span>(<span class="params">HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object hanlder, ModelAndView modelAndView</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">out</span>.println(<span class="string">"拦截器.postHandle 开始执行。。。"</span>);</span><br><span class="line">        <span class="keyword">long</span> start = (<span class="keyword">long</span>) httpServletRequest.getAttribute(<span class="string">"start"</span>);</span><br><span class="line">        <span class="keyword">out</span>.println(<span class="string">"postHandle执行时间为："</span> + (currentTimeMillis() - start));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span>(<span class="params">HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object hanlder, Exception e</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//会打印两次 spring里面的basic error 也会被拦截</span></span><br><span class="line">        <span class="keyword">out</span>.println(<span class="string">"拦截器.afterCompletion 开始执行。。。"</span>);</span><br><span class="line">        <span class="keyword">long</span> start = (<span class="keyword">long</span>) httpServletRequest.getAttribute(<span class="string">"start"</span>);</span><br><span class="line">        <span class="keyword">out</span>.println(<span class="string">"afterCompletion执行时间为："</span> + (currentTimeMillis() - start));</span><br><span class="line">        <span class="keyword">out</span>.println(<span class="string">"\n ex is :"</span> + e+<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看拦截器再spring boot里面的配置，首先要继承WebMvcConfigurerAdapter适配器，重写addIntercepors方法再调用register方法添加拦截器，前提，自定义的interceptor要加上spring注解被spring容器管理。<strong>可以通过配置，声明拦截器的作用域【转载者注】。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wtzhouc@gmail.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-13 14:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyInterceptor myInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebConfig</span><span class="params">(MyInterceptor myInterceptor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myInterceptor = myInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Bean</span></span><br><span class="line"><span class="comment">//    public FilterRegistrationBean timeFilter() &#123;</span></span><br><span class="line"><span class="comment">//        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();</span></span><br><span class="line"><span class="comment">//        TimeFilter filter = new TimeFilter();</span></span><br><span class="line"><span class="comment">//        filterRegistrationBean.setFilter(filter);</span></span><br><span class="line"><span class="comment">//        filterRegistrationBean.addUrlPatterns("/user","/users");</span></span><br><span class="line"><span class="comment">//        return filterRegistrationBean;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(myInterceptor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    我们再来看看控制台的输出</span><br></pre></td></tr></table></figure><blockquote><p><img src="https:////upload-images.jianshu.io/upload_images/6619796-76703d0ae668e4ff.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p><p>image.png</p></blockquote><p>接下来来讲讲拦截器的三个方法,preHandle(),postHandle(),afterCompletion()</p><blockquote><p>⚠️：拦截器与过滤器方法内参数不同，多了一个Object handler,在请求进入控制层前，spring mvc 会将请求交给handler处理，handler参数就是用来描述处理请求的，从上面的demo可以看出来 他的类型是handlerMethod的，处理的请求的是BrowserAuthenticationController</p></blockquote><ul><li><p>preHandler(): 这个方法是在controller调用之前调用，通过返回true或者false决定是否进入Controller层</p></li><li><p>postHandler()：在请求进入控制层之后调用，但是在处理请求抛出异常时不会调用</p></li><li><p>afterCompletion(): 在请求处理完成之后，也就是在DispatherServlet渲染了视图之后执行，也就是说这个方法必定是执行，包含异常信息，它的主要作用就是清理资源</p></li></ul><blockquote><p>接下来总结一下过滤器和拦截的前后顺序，看下图：</p><p><img src="https:////upload-images.jianshu.io/upload_images/6619796-584ee2d9d1d76b7b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p><p>image.png</p></blockquote><h2 id="Aspect（切片）"><a href="#Aspect（切片）" class="headerlink" title="Aspect（切片）"></a>Aspect（切片）</h2><p>在使用过滤器的时能获取request和response对象，对请求和响应进行处理，使用拦截器时，我们可以通过handler来获取当前请求控制器的方法名称，但是有一个弊端，我们拿不到控制器要接收的参数，先看下servlet源码的执行顺序</p><blockquote><p><img src="https:////upload-images.jianshu.io/upload_images/6619796-cf3060350ea9467c.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p><p>image.png</p><p><img src="https:////upload-images.jianshu.io/upload_images/6619796-71d3c2112e507bb5.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p><p>image.png</p><p><img src="https:////upload-images.jianshu.io/upload_images/6619796-9b2f91c1f80abf64.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p><p>image.png</p></blockquote><p>从DispatherServlet分发请求时，进入doService()方法内部，在方法参数封装之前，添加了判断，applyPreHandle()方法就时判断拦截器里面的preHandler（）方法，根据返回的true或者false，判断是否执行真正的handler，所以我们在拦截器的handler参数里面是获取不到请求的参数的，因此，我们要引入Spring AOP，也就是切片编程，它可以在控制器的执行之前，执行之后，抛出异常等等，进行控制！</p><blockquote><p>切片编程，在网上看到了一个很贴切的说法，面对的是处理过程中的方法或者阶段，以获得各部分的低耦合性的隔离效果，它是基于动态代理，它关注的是行为和过程，它常用的注解为，下面通过spring boot 实现一个demo</p></blockquote><ul><li><p>@Aspect(声明一个切面)</p></li><li><p>@Before(相当于拦截器preHandler，在方法执行前调用)</p></li><li><p>@After（相当于拦截器的afterComplement（）在方法执行后调用）</p></li><li><p>@AfterThrowing（方法抛出异常时调用）</p></li><li><p>@AfterReturning（当方法返回时调用）</p></li><li><p>@Around(包含以上方的执行顺序)</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wtzhouc<span class="doctag">@gmail</span>.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-13 16:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(<span class="meta-string">"execution(* com.wtzhou.security.controller.UserController.*(..))"</span>)</span></span><br><span class="line"><span class="comment">//    @After("")</span></span><br><span class="line"><span class="comment">//    @Before("")</span></span><br><span class="line"><span class="comment">//    @AfterThrowing()</span></span><br><span class="line"><span class="comment">//    @AfterReturning()</span></span><br><span class="line">    <span class="keyword">public</span> Object handlerControllerMethod(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123;</span><br><span class="line">        Object[] args = proceedingJoinPoint.getArgs();</span><br><span class="line">        <span class="keyword">for</span> (Object arg : args) &#123;</span><br><span class="line">            <span class="keyword">out</span>.println(<span class="string">"请求参数为："</span>+arg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">out</span>.println(<span class="string">"TimeAspect 切片开始执行"</span>);</span><br><span class="line">        long start = currentTimeMillis();</span><br><span class="line">        Object proceed = proceedingJoinPoint.proceed();</span><br><span class="line">        <span class="keyword">out</span>.println(<span class="string">"切片执行耗时："</span> + (currentTimeMillis() - start));</span><br><span class="line">        <span class="keyword">out</span>.println(<span class="string">"切片执行结束！"</span>);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过注解内部的表达式不同，可以定义你想要的切入点，ProceedingJoinPoint对象可以当前的请求参数，对参数处理后，可以调用proceed方法放行，我们可以看看控制台的输出</p></blockquote><blockquote><p><img src="https:////upload-images.jianshu.io/upload_images/6619796-9acaddfa4a2fe641.png?imageMogr2/auto-orient/strip|imageView2/2/w/818/format/webp" alt="img"></p><p>image.png</p><p><img src="https:////upload-images.jianshu.io/upload_images/6619796-427bceb6f6460d97.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p><p>image.png</p></blockquote><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>在代码里面将过滤器，拦截器，切片，还有我们常用的@ControllerAdvice异常拦截机制注解放开时，我们来看看控制台的输出</p><blockquote><p><img src="https:////upload-images.jianshu.io/upload_images/6619796-1f7382cd626b488d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p><p>image.png</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过控制台的日志 我们可以用一张简单的图来直观展现出来</span><br></pre></td></tr></table></figure><blockquote><p><img src="https:////upload-images.jianshu.io/upload_images/6619796-b7db58ef28eba5d2.png?imageMogr2/auto-orient/strip|imageView2/2/w/1106/format/webp" alt="img"></p><p>image.png</p></blockquote><p><strong>通过图示:</strong>当收到请求响应时，执行的顺序为filter–》interceptor–》ControllerAdvice–》Aspect，然后到大控制层，如果控制层抛出异常，最先也会被Aspect捕获，如果未处理，会继续向上一层抛出，如果到Filter也没有处理的话，就会抛到容器内部</p><p><strong>目前 Spring 提供了 <code>@ControllerAdvice</code> 的注解，让我们更方便的使用切面【转载者注】。</strong></p><p>转自：<a href="https://www.jianshu.com/p/2ec6a5f24a33" target="_blank" rel="noopener">https://www.jianshu.com/p/2ec6a5f24a33</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在工作中如何选择拦截机制去处理我们的业务请求，过滤器，拦截器，还是切面的选择一直比较模糊，今天花时间整理一下。&lt;strong&gt;这三者都是 AOP 的一种实现【转载者注】。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="Spring" scheme="http://ddnd.cn/categories/Spring-Programming/"/>
    
    
      <category term="过滤器" scheme="http://ddnd.cn/tags/%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
      <category term="拦截器" scheme="http://ddnd.cn/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    
      <category term="切面" scheme="http://ddnd.cn/tags/%E5%88%87%E9%9D%A2/"/>
    
  </entry>
  
  <entry>
    <title>远程接口设计经验分享【转载】</title>
    <link href="http://ddnd.cn/2019/11/19/rpc-interface-design/"/>
    <id>http://ddnd.cn/2019/11/19/rpc-interface-design/</id>
    <published>2019-11-19T11:45:01.000Z</published>
    <updated>2019-11-19T11:46:57.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前边"><a href="#写在前边" class="headerlink" title="写在前边"></a>写在前边</h2><p>分布式架构是互联网应用的基础架构，很多新人入职以来就开始负责编写和调用阿里的各种远程接口。但如同结婚一般，用对一个正确的接口就如同嫁一个正确的人一样，往往难以那么顺利的实现，或多或少大家都会在这个上边吃亏。</p><p>每年双十一系统调用复盘的时候，我都会听到以下声音</p><ul><li>你们调我的接口报错了竟然不会自己重试？</li><li>我的返回值应该从这里取</li><li>我返回isSuccess() == true，不代表业务成功，你还需要判断ERROR_CODE</li><li>这个ERROR_CODE没说全部都要重试啊！</li><li>这个ERROR_CODE必须要重试！</li></ul><p>还有很多了，本文的目标就是帮助大家思考，如何设计自己的远程接口，让接口做到<code>健壮</code>、<code>易用</code>，节省大家在这块泥潭中所挣扎的时间。</p><h2 id="一个日志服务LogService"><a href="#一个日志服务LogService" class="headerlink" title="一个日志服务LogService"></a>一个日志服务LogService</h2><p><em>PS：本例子的代码可以见 Excavatore-DEMO</em></p><table><thead><tr><th style="text-align:left">…</th><th style="text-align:left">苍老师</th></tr></thead><tbody><tr><td style="text-align:left">上课！大家好，我是你们的苍老师。今天就由我来给大家讲讲如何编写一个健壮的远程接口。老师将在这里给大家设计一个集中式的日志系统。  虽然这个系统的存在不合理，但这是能找到的最简单例子，所以不要在课堂上就系统的合理性展开讨论，否则老师会生气的哟～</td><td style="text-align:left"><a href="https://yq.aliyun.com/go/articleRenderRedirect?url=http%3A%2F%2Fimg4.tbcdn.cn%2FL1%2F461%2F1%2Feb10f02f448966babe614f9140c5b695e327bea2" target="_blank" rel="noopener"><img src="http://img4.tbcdn.cn/L1/461/1/eb10f02f448966babe614f9140c5b695e327bea2" alt="老师"></a></td></tr></tbody></table><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p>一个集中性的日志服务器，要求应用通过日志系统提供的日志服务，将所有日志集中统一的输出到固定的文件中。</p><p><em>系统架构图</em></p><p><a href="https://yq.aliyun.com/go/articleRenderRedirect?url=http%3A%2F%2Fimg1.tbcdn.cn%2FL1%2F461%2F1%2F6c77caaf612292c1654ec92473df1ac199b4f866" target="_blank" rel="noopener"><img src="http://img1.tbcdn.cn/L1/461/1/6c77caaf612292c1654ec92473df1ac199b4f866" alt="日志服务器架构"></a></p><table><thead><tr><th style="text-align:left">小明</th><th style="text-align:left">…</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://yq.aliyun.com/go/articleRenderRedirect?url=http%3A%2F%2Fimg1.tbcdn.cn%2FL1%2F461%2F1%2Fd956d1cc3aeeae2a6cec93616b222e9b13239078" target="_blank" rel="noopener"><img src="http://img1.tbcdn.cn/L1/461/1/d956d1cc3aeeae2a6cec93616b222e9b13239078" alt="xiaoming_head"></a></td><td style="text-align:left">这很简单嘛，根据系统的要求和架构特性，我很快就能写出接口定义，老师你看。“如果方法顺利无异常返回，则说明日志已经被成功写入了日志文件”</td></tr></tbody></table><h3 id="接口v0-1版"><a href="#接口v0-1版" class="headerlink" title="接口v0.1版"></a>接口v0.1版</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 日志服务</span><br><span class="line"> * @author : xiaoming.xm@cainiao.com</span><br><span class="line"> * @version: 0.1</span><br><span class="line"> */</span><br><span class="line">public interface LogService &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 记录INFO级别日志</span><br><span class="line">     *</span><br><span class="line">     * @param format 日志模版(同String.format())</span><br><span class="line">     * @param args   日志参数</span><br><span class="line">     */</span><br><span class="line">    void info(String format, Serializable... args);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">…</th><th style="text-align:left">苍老师</th></tr></thead><tbody><tr><td style="text-align:left">非常好，但这种接口只能用在单机版的程序中，如果遇到远程调用的场景就不适用了。要了解这个事实，首先大家就要知道远程调用的大概实现原理。</td><td style="text-align:left"><a href="https://yq.aliyun.com/go/articleRenderRedirect?url=http%3A%2F%2Fimg4.tbcdn.cn%2FL1%2F461%2F1%2Feb10f02f448966babe614f9140c5b695e327bea2" target="_blank" rel="noopener"><img src="http://img4.tbcdn.cn/L1/461/1/eb10f02f448966babe614f9140c5b695e327bea2" alt="老师"></a></td></tr></tbody></table><h3 id="RPC调用"><a href="#RPC调用" class="headerlink" title="RPC调用"></a>RPC调用</h3><h4 id="什么是RPC调用"><a href="#什么是RPC调用" class="headerlink" title="什么是RPC调用"></a>什么是RPC调用</h4><p>RPC（Remote Procedure Call）远程过程调用，一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的技术实现。</p><blockquote><p>RPC采用C/S模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息的到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。</p><p><em>以上信息摘录自百度百科</em></p></blockquote><h4 id="一次完整的RPC调用过程"><a href="#一次完整的RPC调用过程" class="headerlink" title="一次完整的RPC调用过程"></a>一次完整的RPC调用过程</h4><p><a href="https://yq.aliyun.com/go/articleRenderRedirect?url=http%3A%2F%2Fimg4.tbcdn.cn%2FL1%2F461%2F1%2Fe3cb58049ce66a0ceb0cef2be932a5ade41f4eab" target="_blank" rel="noopener"><img src="http://img4.tbcdn.cn/L1/461/1/e3cb58049ce66a0ceb0cef2be932a5ade41f4eab" alt="RPC调用流程"></a></p><ul><li><strong>请求过程</strong></li></ul><ol><li><p><code>客户端函数</code>将参数传递到<code>客户端句柄</code>。</p></li><li><p><code>客户端句柄</code>将请求序号、远程方法、参数等信息封装到请求对象中，并完成请求对象序列化形成请求报文，通过<code>网络客户端</code>发送请求报文。</p></li><li><p>请求报文通过<code>网络客户端</code>与<code>网络服务端</code>所约定的协议（HTTP、RMI或自定义）进行通讯。</p></li><li><p><code>网络服务端</code>收到请求报文之后，通过反序列化，从请求对象中解析出远程方法、参数等信息，并根据这些信息找到<code>服务器句柄</code>。</p></li><li><p>通过<code>服务器句柄</code>完成<code>服务器函数</code>的本地调用过程</p><p>自此，整个请求流程完成。</p></li></ol><ul><li><strong>应答过程</strong></li></ul><ol><li><p><code>服务器函数</code>执行的过程将结果返回<code>服务器句柄</code>，返回的结果可能是正常返回，也可能是以抛异常的形式返回。</p></li><li><p><code>服务器句柄</code>根据返回的值与请求序号封装到应答对象中，并完成应答对象的序列化，形成应答报文，通过<code>网络服务端</code>发送应答报文。</p></li><li><p>应答报文通过<code>网络服户端</code>与<code>网络客务端</code>所约定的协议（HTTP、RMI或自定义）进行通讯。</p></li><li><p><code>网络客户端</code>收到应答报文之后，通过反序列化，从应答对象中解析出请求序号所挂钩的<code>客户端句柄</code></p></li><li><p><code>客户端句柄</code>将返回数据返回到<code>客户端函数</code>，以返回值或抛异常的形式将信息返回</p><p>自此，整个应答流程完成。</p></li></ol><table><thead><tr><th style="text-align:left">…</th><th style="text-align:left">苍老师</th></tr></thead><tbody><tr><td style="text-align:left">一次完整的RPC调用一共分10步，每一步都有可能出错，所以在设计一个远程接口的时候必须充分考虑到所有的出错可能，与客户端约定出错的应对方案。无论哪个环节出问题，都要求你的业务逻辑依旧保证不能错乱！</td><td style="text-align:left"><a href="https://yq.aliyun.com/go/articleRenderRedirect?url=http%3A%2F%2Fimg4.tbcdn.cn%2FL1%2F461%2F1%2Feb10f02f448966babe614f9140c5b695e327bea2" target="_blank" rel="noopener"><img src="http://img4.tbcdn.cn/L1/461/1/eb10f02f448966babe614f9140c5b695e327bea2" alt="老师"></a></td></tr></tbody></table><table><thead><tr><th style="text-align:left">小明</th><th style="text-align:left">…</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://yq.aliyun.com/go/articleRenderRedirect?url=http%3A%2F%2Fimg1.tbcdn.cn%2FL1%2F461%2F1%2Fd956d1cc3aeeae2a6cec93616b222e9b13239078" target="_blank" rel="noopener"><img src="http://img1.tbcdn.cn/L1/461/1/d956d1cc3aeeae2a6cec93616b222e9b13239078" alt="xiaoming_head"></a></td><td style="text-align:left">不愧是苍老师，果然 博 大精深。我明白了，因为增加了远程访问的因素，所以原本单机中非常小的出错概率就被放大了，这也不得不让程序被迫感知和处理这些通讯错误。  那请问遇到这些错误都应该怎样进行归纳和处理呢？</td></tr></tbody></table><h3 id="一次远程调用出错的可能"><a href="#一次远程调用出错的可能" class="headerlink" title="一次远程调用出错的可能"></a>一次远程调用出错的可能</h3><h4 id="通讯框架错误"><a href="#通讯框架错误" class="headerlink" title="通讯框架错误"></a>通讯框架错误</h4><p>通讯框架错误根据发生环节分可以细分为</p><ol><li><p>Marshell &amp; UnMarshell</p><p>C/S双方采用了不一致的序列化／反序列化算法，导致在通讯之前或之后无法正常取得通讯的对象。从而导致双方在编码、解码的过程中发生错误。</p><p>如果你的通讯框架使用了Hessian那基本上你都有机会遇到过。至于序列化和反序列化的梗，都可以开个专题了。这里就不在啰嗦。</p></li><li><p>网络通讯错误</p><p>系统错误会导致无法预测的异常产生，具体取决于RPC的实现方式。对于这种错误，唯一的处理方式只有：另外找时间／机会重试。</p></li></ol><h4 id="业务系统错误"><a href="#业务系统错误" class="headerlink" title="业务系统错误"></a>业务系统错误</h4><p>业务系统错误分两种情况</p><ol><li><p>业务错误</p><p>Client传递了违背业务规则的参数，导致业务逻辑处理失败。这种错误无论重复多少次都会得到一样结局。</p></li><li><p>系统错误</p><p>Server处理内部逻辑时出现了无法控制的错误，常见的有：</p></li></ol><ul><li><p>数据库访问失败</p></li><li><p>文件写入失败</p></li><li><p>网络通讯失败</p><p>一般遇到这种错误，可以通过重试解决。</p></li></ul><h4 id="各种出错场景-amp-解决方案梳理"><a href="#各种出错场景-amp-解决方案梳理" class="headerlink" title="各种出错场景&amp;解决方案梳理"></a>各种出错场景&amp;解决方案梳理</h4><table><thead><tr><th style="text-align:left">出错情况</th><th style="text-align:left">解决方案</th><th style="text-align:left">是否重试</th></tr></thead><tbody><tr><td style="text-align:left">通讯框架错误</td><td style="text-align:left">抛出框架异常</td><td style="text-align:left">重试</td></tr><tr><td style="text-align:left">系统错误</td><td style="text-align:left">抛出系统异常</td><td style="text-align:left">重试</td></tr><tr><td style="text-align:left">业务错误</td><td style="text-align:left">返回明确的错误码</td><td style="text-align:left">禁止重试</td></tr></tbody></table><table><thead><tr><th style="text-align:left">小明</th><th style="text-align:left">…</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://yq.aliyun.com/go/articleRenderRedirect?url=http%3A%2F%2Fimg1.tbcdn.cn%2FL1%2F461%2F1%2Fd956d1cc3aeeae2a6cec93616b222e9b13239078" target="_blank" rel="noopener"><img src="http://img1.tbcdn.cn/L1/461/1/d956d1cc3aeeae2a6cec93616b222e9b13239078" alt="xiaoming_head"></a></td><td style="text-align:left">嗯，我了解了，一个好的远程方法定义必须考虑到上边所罗列的异常场景，要求做到<code>明确的错误处理约定</code>。那请问苍老师这个接口应该如何写呢？</td></tr></tbody></table><table><thead><tr><th style="text-align:left">…</th><th style="text-align:left">苍老师</th></tr></thead><tbody><tr><td style="text-align:left">先别着急，要写出健壮的接口，你还有几个概念要理解。首先我们先来看这个接口的声明。我的比你多了两个重要的信息<code>ResultDO&lt;Void&gt;</code>与<code>LogException</code>，接下来我会讲解这定义这两个类的作用</td><td style="text-align:left"><a href="https://yq.aliyun.com/go/articleRenderRedirect?url=http%3A%2F%2Fimg4.tbcdn.cn%2FL1%2F461%2F1%2Feb10f02f448966babe614f9140c5b695e327bea2" target="_blank" rel="noopener"><img src="http://img4.tbcdn.cn/L1/461/1/eb10f02f448966babe614f9140c5b695e327bea2" alt="老师"></a></td></tr></tbody></table><h3 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h3><p>如果你有机会重新搭建一个应用，推荐大家采用分包的策略来考虑自己的模块组织。</p><p><a href="https://yq.aliyun.com/go/articleRenderRedirect?url=http%3A%2F%2Fimg2.tbcdn.cn%2FL1%2F461%2F1%2F31c5a1fd707e2ab11d37cde52460eab02ce45af4" target="_blank" rel="noopener"><img src="http://img2.tbcdn.cn/L1/461/1/31c5a1fd707e2ab11d37cde52460eab02ce45af4" alt="代码组织结构"></a></p><ul><li><strong>common：</strong>定义core和client所共用的内容<ul><li><strong>业务接口声明</strong></li><li>LogService</li><li><strong>Domain对象</strong>（这里为了简单，所有的DO、TO、DTO都统一命名为DO）</li><li>ResultDO<t></t></li><li><strong>业务异常</strong></li><li>LogException</li></ul></li><li><strong>client：</strong>富客户端，在这一层可以组织cache、业务无关的通用校验，这一次层并非必须。<ul><li><strong>服务客户端实现</strong></li><li>LogServiceClient</li><li>AsyncLogServiceClient</li></ul></li><li><strong>core：</strong>业务服务的实现，这一层的代码运行在服务端。<ul><li><strong>服务业务逻辑实现</strong>，同时内部按照习惯可以再次分层为(<code>Service</code>、<code>Manager</code>、<code>Dao</code>)</li><li>LogServiceImpl</li></ul></li></ul><p><a href="https://yq.aliyun.com/go/articleRenderRedirect?url=http%3A%2F%2Fimg1.tbcdn.cn%2FL1%2F461%2F1%2Fb37ec8f6d761181b6b1cdb90d36880b13fb764ca" target="_blank" rel="noopener"><img src="http://img1.tbcdn.cn/L1/461/1/b37ec8f6d761181b6b1cdb90d36880b13fb764ca" alt="代码组织图"></a></p><h3 id="正确处理返回值"><a href="#正确处理返回值" class="headerlink" title="正确处理返回值"></a>正确处理返回值</h3><p>这套RPC接口声明的理念在于：如何通过约定区分出系统异常与业务异常。区分的关键就在于<code>ResultDO&lt;?&gt;</code>与<code>LogException</code>上</p><ul><li><p>ResultDO<t></t></p><p><code>info</code>方法不需要返值，但服务端需要在业务出错的时候，将错误码返回给客户端，以便友好的错误提示。所以在Result对象中有两个方法：</p><ul><li><code>public boolean isSuccess();</code></li></ul><p><code>isSuccess</code>为<code>true</code>时表明业务处理成功：当客户端获取到这个值时，表明服务端已正确经接请求到并且成功的处理了这个请求，业务完成。这是最好的情况。</p><p><code>isSuccess</code>为<code>false</code>时表明业务处理失败：当客户端获取到时，表明服务端已经正确接到请求，但业务处理失败，失败原因在错误码<code>errorCode</code>中体现。</p><ul><li><code>public String getErrorCode();</code></li></ul><p>当服务端正确接到请求，但业务处理失败时，失败的原因以错误码形式返回。</p></li><li><p>LogException</p><p>这个异常主要用于收缩和屏蔽服务层的具体错误信息，当服务端遇到无法处理的错误情况时，需要继续向客户端外抛，让客户端来择机进行重试。客户端亦可通过LogException快速判断当前业务中断的原因来自于LogService的失败。</p></li></ul><h3 id="客户端对返回值的处理总结"><a href="#客户端对返回值的处理总结" class="headerlink" title="客户端对返回值的处理总结"></a>客户端对返回值的处理总结</h3><ul><li><p>客户端处理逻辑表</p><p>| 调用情况 | isSuccess | errorCode | throw LogException | throw Exception | 客户端处理 |<br>| :——- | :——– | :——– | :—————– | :————– | :——— |<br>| 框架错误 | /         | /         | /                  | true            | 重试       |<br>| 系统错误 | /         | /         | true               | /               | 重试       |<br>| 业务错误 | false     | true      | /                  | /               | 不重试     |<br>| 成功返回 | true      | true      | /                  | /               | 不重试     |</p><p>所有情况也不是一层不变。比如<code>业务错误</code>返回错误码，但有时处于性能考虑（抛异常非常消耗JVM性能），可以在接口声明中约定部分错误码也必须要进入重试。但这种场景越少越好，而且一旦做出约定，出于接口向下兼容的考虑，这种需要重试的错误码自声明以来，只能减少不能增加，否则会引起兼容问题。</p></li></ul><table><thead><tr><th style="text-align:left">…</th><th style="text-align:left">苍老师</th></tr></thead><tbody><tr><td style="text-align:left">老师也见过有系统在ResultDO中声明了<code>public boolean isReTry();</code>方法，这样当系统发生业务错误的时候，是否重试的判断就交由<code>isReTry()</code>来进行判断，这也是不错的选择。</td><td style="text-align:left"><a href="https://yq.aliyun.com/go/articleRenderRedirect?url=http%3A%2F%2Fimg4.tbcdn.cn%2FL1%2F461%2F1%2Feb10f02f448966babe614f9140c5b695e327bea2" target="_blank" rel="noopener"><img src="http://img4.tbcdn.cn/L1/461/1/eb10f02f448966babe614f9140c5b695e327bea2" alt="老师"></a></td></tr></tbody></table><ul><li><p>增加isReTry后的客户端处理逻辑表</p><p>| 调用情况 | isSuccess | isReTry | errorCode | throw LogException | throw Exception | 客户端处理 |<br>| :——- | :——– | :—— | :——– | :—————– | :————– | :——— |<br>| 框架错误 | /         | /       | /         | /                  | true            | 重试       |<br>| 系统错误 | /         | /       | /         | true               | /               | 重试       |<br>| 业务错误 | false     | true    | true      | /                  | /               | 重试       |<br>| 业务错误 | false     | false   | true      | /                  | /               | 不重试     |<br>| 成功返回 | true      | /       | true      | /                  | /               | 不重试     |</p></li></ul><h3 id="为什么要有Client层"><a href="#为什么要有Client层" class="headerlink" title="为什么要有Client层"></a>为什么要有<code>Client</code>层</h3><p>老实说，这一层不是必须的，很多情况下客户端直接使用服务端声明的Service接口足矣。但若遇到在客户端容灾、增强的场景，则ServiceClient的优势就体现出来。</p><p><a href="https://yq.aliyun.com/go/articleRenderRedirect?url=http%3A%2F%2Fimg3.tbcdn.cn%2FL1%2F461%2F1%2F8f74c86ac9e4fd64628f73abeddd5f8fdcfeae7c" target="_blank" rel="noopener"><img src="http://img3.tbcdn.cn/L1/461/1/8f74c86ac9e4fd64628f73abeddd5f8fdcfeae7c" alt="ServiceClient"></a></p><h3 id="接口v0-2版"><a href="#接口v0-2版" class="headerlink" title="接口v0.2版"></a>接口v0.2版</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 日志服务</span><br><span class="line"> * @author : cangjingkong.cjk@cainiao.com</span><br><span class="line"> * @version: 0.2</span><br><span class="line"> */</span><br><span class="line">public interface LogService &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 记录INFO级别日志</span><br><span class="line">     *</span><br><span class="line">     * @param format 日志模版(同String.format())</span><br><span class="line">     * @param args   日志参数</span><br><span class="line">     * @return 记录日志是否成功</span><br><span class="line">     * @throws LogException 记录日志发生异常</span><br><span class="line">     */</span><br><span class="line">    ResultDO&lt;Void&gt; info(String format, Serializable... args)</span><br><span class="line">            throws LogException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">小明</th><th style="text-align:left">…</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://yq.aliyun.com/go/articleRenderRedirect?url=http%3A%2F%2Fimg1.tbcdn.cn%2FL1%2F461%2F1%2Fd956d1cc3aeeae2a6cec93616b222e9b13239078" target="_blank" rel="noopener"><img src="http://img1.tbcdn.cn/L1/461/1/d956d1cc3aeeae2a6cec93616b222e9b13239078" alt="xiaoming_head"></a></td><td style="text-align:left">一个好的系统约定能减少很多不必要的错误，但毕竟不是所有系统都是新的系统，在面临各种<code>先人的智慧</code>时，如何让不符合约定的远程接口也纳入约定来？</td></tr></tbody></table><table><thead><tr><th style="text-align:left">…</th><th style="text-align:left">苍老师</th></tr></thead><tbody><tr><td style="text-align:left">在面对<code>先人的智慧</code>时，改变现有被大量调用的接口声明是不可能的，在这种情况下<code>存在即合理</code>，哪怕明知接口声明或实现存在问题，你也不能去变更这个接口。接口维护原则请听下堂课《远程接口维护经验分享》。  当遇到这种不在约定的接口时，需要用<code>装饰模式</code>将不规范的接口包装成为规范的接口。</td><td style="text-align:left"><a href="https://yq.aliyun.com/go/articleRenderRedirect?url=http%3A%2F%2Fimg4.tbcdn.cn%2FL1%2F461%2F1%2Feb10f02f448966babe614f9140c5b695e327bea2" target="_blank" rel="noopener"><img src="http://img4.tbcdn.cn/L1/461/1/eb10f02f448966babe614f9140c5b695e327bea2" alt="老师"></a></td></tr></tbody></table><h3 id="接口的Wrapper"><a href="#接口的Wrapper" class="headerlink" title="接口的Wrapper"></a>接口的Wrapper</h3><p>几乎可以肯定的，在公司中你肯定不是第一个声明接口的人。所以当你定出了远程接口设计规范之后，如何面对老接口则成了一个头疼的问题。</p><p><code>先人的智慧</code>是无穷的，现在我们讨论的问题，我们的前辈都已经面临并解决了（运气不好你可能还会遇到新手练手写的接口），只是解决的方法各种各样，没有形成约定。何解？</p><p>此时可以考虑使用<code>装饰模式</code>将不规范的接口重新包装成符合设计规范的接口，这样做有两个好处：</p><ul><li><p>解决老接口不规范问题</p></li><li><p>减小老接口暴露到业务代码中的概率</p><p>这里需要解释下。外部接口的定义不受控制，如果此时一个Service需要升级，则改动、回归、代码REVIEW范围仅限于Wrapper类即可，若将所有业务代码直接引用外部的Service/ServiceClient类，则升级的回归面将被放大。</p></li></ul><p>所以无论对方声明的接口是否符合约定，我都会建议客户端不要直接使用Service/ServiceClient，而是Wrapper一层。</p><table><thead><tr><th style="text-align:left">小明</th><th style="text-align:left">…</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://yq.aliyun.com/go/articleRenderRedirect?url=http%3A%2F%2Fimg1.tbcdn.cn%2FL1%2F461%2F1%2Fd956d1cc3aeeae2a6cec93616b222e9b13239078" target="_blank" rel="noopener"><img src="http://img1.tbcdn.cn/L1/461/1/d956d1cc3aeeae2a6cec93616b222e9b13239078" alt="xiaoming_head"></a></td><td style="text-align:left">太好了，经过老师提点，我终于写出了一个健壮的远程接口，并知道如何与客户端约定重试的关系。  不过我还是想问问，这种远程的日志系统存在是否不是太合理，老师你举这个例子是不是不太恰当？</td></tr></tbody></table><p><a href="https://yq.aliyun.com/go/articleRenderRedirect?url=http%3A%2F%2Fimg1.tbcdn.cn%2FL1%2F461%2F1%2Fd024c6ab859d61976f1d4a8c7a35735ccba8392c" target="_blank" rel="noopener"><img src="http://img1.tbcdn.cn/L1/461/1/d024c6ab859d61976f1d4a8c7a35735ccba8392c" alt="滚"></a></p><p><em>PS：本例子的代码可以见 Excavatore-DEMO</em></p><p>转自：<a href="https://yq.aliyun.com/articles/2945" target="_blank" rel="noopener">https://yq.aliyun.com/articles/2945</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前边&quot;&gt;&lt;a href=&quot;#写在前边&quot; class=&quot;headerlink&quot; title=&quot;写在前边&quot;&gt;&lt;/a&gt;写在前边&lt;/h2&gt;&lt;p&gt;分布式架构是互联网应用的基础架构，很多新人入职以来就开始负责编写和调用阿里的各种远程接口。但如同结婚一般，用对一个正确的接口
      
    
    </summary>
    
      <category term="微服务" scheme="http://ddnd.cn/categories/micro-service/"/>
    
    
      <category term="微服务" scheme="http://ddnd.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="RPC 接口设计" scheme="http://ddnd.cn/tags/RPC-%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="RPC 调用结果" scheme="http://ddnd.cn/tags/RPC-%E8%B0%83%E7%94%A8%E7%BB%93%E6%9E%9C/"/>
    
  </entry>
  
  <entry>
    <title>第八届中国软件杯大赛-云监控系统设计思路</title>
    <link href="http://ddnd.cn/2019/07/28/cnsoftbei8-huayun/"/>
    <id>http://ddnd.cn/2019/07/28/cnsoftbei8-huayun/</id>
    <published>2019-07-28T07:08:52.000Z</published>
    <updated>2019-07-28T07:17:14.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>好久没写博客了，主要是因为最近 2 个月在忙着做 2 个比赛，一个是中国软件杯，另一个是阿里的第五届中间件性能挑战赛，另外还有就是忙着准备秋招，所以差不多 3 个月没写博客了，最近刚结束了中国软件杯的比赛，阿里的第五届中间件性能挑战赛也结束了初赛，所以趁着空闲的时间总结一下这两个比赛。<br>首先汇报一下成绩，中国软件杯获得了三等奖（国家级），第五届中间件性能挑战赛初赛取得了第六名（4094个队伍），目前已经进入复赛。<br>先说一下中国软件杯这个比赛成绩，首先这个成绩对于我来说挺出乎意料的，首先对这个比赛感到挺失望的，一开始参赛的时候以为这个比赛是属于技术类比赛，结果到头来还是偏向于 PPT 型的比赛，至于为什么这么说，这里不得不吐槽一下，我参加的赛题是关于云平台的监控报警系统，大概使用出题企业提供的 <code>HTTP API</code> 获取到云服务器的性能指标，然后通过对这些指标进行监控，当指标符合用户规定的规则时候则触发报警，赛题需求看起来没啥问题，清晰明了，我和我队友也就中规中矩的实现赛题的需求，最后也就止步于三等奖了，决赛都没进（我参加的赛题只有 3 个队伍进入了决赛）。后面通过观看现场的决赛视频，了解到进入决赛的队伍的实现情况，他们竟然使用上了<strong>人工智能、区块链、人脸识别、AR等等这热门的技术，使用区块链技术保障从 API 中获取到的数据不丢失、不被篡改，使用 AR 来查看云服务器的监控信息，使用人脸识别来身份证验证，使用人工智能来….</strong>，听起来牛逼的技术都往上堆，先不说这些跟监控报警系统有啥关系吧，也不说他们到底有没有实现，单靠这些名词就把”专家”治的服服帖帖，也难怪进了决赛，这些高大上的技术我和我队友一个都没用上，所以最后比赛也就获得了三等奖而已。<br>再说一下第五届中间件性能挑战赛初赛，这个成绩对于我来说挺满意的了，初赛第一天拿了个第 5 名，然后中间陆陆续续也当过几天第一名，最后成绩为第 6 名，总体来说这个成绩也并不意外，因为从初赛第一天开始到结束我的排名都是靠前的。</p><p>这两个比赛就说到这里吧，然后下面是分享下我和我队友参加中国软件杯的大概思路，最后也附上源码、成品视频。</p><p>喜欢的朋友可以点个赞~要是点赞数多的话我下一篇写一下第五届中间件性能挑战赛初赛的思路。</p><h2 id="赛题分析"><a href="#赛题分析" class="headerlink" title="赛题分析"></a>赛题分析</h2><p>赛题地址: <a href="http://www.cnsoftbei.com/bencandy.php?fid=155&amp;aid=1685" target="_blank" rel="noopener">基于华云公有云平台，设计公有云监控系统</a>    </p><p>在全民云时代的当下，单体应用已无法满足急速增加的业务需求，本文设计思路是将单体应用按照业务功能拆分成多个小型服务，每个小型服务提供专门业务功能，不同的服务之间可以通过 <code>RPC</code> 或者 <code>HTTP</code> 进行通讯，这样一来系统就可以解耦成多个服务，各个服务可以独立的进行开发、部署、维护和管理，同时也可以基于服务进行横向的扩展，可以进行更细粒度的扩展。      </p><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p>按照赛题需求，本文将系统按照业务拆分成五个主要服务：   </p><ul><li>数据收集：负责收集来自不同应用的数据，将数据清洗之后发布到消息队列中间件。     </li><li>数据存储与检索：主要的功能是将数据持久化，同时向外提供检索服务。通过订阅消息队列，异步的处理收集到的数据，将数据存储到检索框架中，方便对数据的检索，同时将数据持久化到数据库中，以防数据丢失。    </li><li>监控报警：主要的功能是提供自定义报警规则和异常报警。向外提供接口进行自定义报警规则，通过 <code>RPC</code> 调用数据存储与检索的检索服务，对数据进行分析和统计，当数据满足报警规则时实现自动报警。    </li><li>统一服务层：主要功能是将各个服务统一起来，向外提供 <code>API</code> 进行通讯。    </li><li>前端：主要功能是提供用户对云主机管理操作、自定义监控报警的页面，将云主机性能数据可视化展示。  </li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/7/5/16bc14befdab9715?w=903&amp;h=911&amp;f=png&amp;s=72901" alt=""></p><p>数据收集实时的对华云系统数据进行收集，保证了数据的有效性，数据收集和数据存储与检索通过 <code>RabbitMQ</code> 达到解耦、异步的目的，让海量的数据收集提供了可能，同时依靠 <code>RabbitMQ</code> 提供的消息可靠性，保证了数据的可靠性。数据存储与检索通过订阅 <code>RabbitMQ</code> 实时的将数据存储到 <code>MySQL</code> 和 <code>Elasticsearch</code> 中，通过 <code>Elasticsearch</code> 提高了检索效率，让海量的数据检索成为了可能。          </p><p>监控报警将实时的对数据进行监控、分析和统计，当数据符合报警规则的时候，将会通过 <code>Email</code>、手机短信将报警信息及时发送给用户，让用户对云主机的安全了如指掌。同时用户可以自定义报警规则，可以对报警规则进行多维度的设置，比如监控的参数、监控周期、周期数、符合一次报警规则还是总是符合时候才报警等信息，让用户可以对云主机的性能进行多维度的掌控。    </p><p>统一服务层将数据存储与检索、监控报警、云主机管理等统一集成，对外提供统一的 <code>API</code> 进行操作。      </p><p>前端将为用户提供云主机管理、数据可视化、监控报警的界面。     </p><p><img src="https://user-gold-cdn.xitu.io/2019/7/5/16bc14d0a85b5a3b?w=1135&amp;h=884&amp;f=png&amp;s=129954" alt=""></p><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p><strong>1. 开发语言</strong>   </p><p>本文采用 <code>Java</code> 作为开发语言，主要原因是 <code>Java</code> 稳定性高、安全性高，拥有庞大的生态系统，同时具有跨平台的特性，所以本文采用 <code>Java</code> 作为开发语言。    </p><p><strong>2. 开发框架</strong>     </p><p>本文采用 <code>Spring Boot</code> 作为系统开发的框架，原因是 <code>Spring</code> 系列的框架生态非常好，能进行快速的开发和敏捷的部署，还有提高后期的可维护性。<code>Spring Boot</code> 作为 <code>Spring</code> 系列框架下的一个子项目，可以快速的整合第三方框架，同时支持将系统打包成应用程序进行执行，为微服务提供了可能。     </p><p><strong>3. 消息队列</strong>     </p><p>本文采用 <code>RabbitMQ</code> 作为消息队列中间件，原因是 <code>RabbitMQ</code> 低延迟、可用性高、消息可靠性高。      </p><p><strong>4. RPC 框架</strong>   </p><p>本文采用 <code>Dubbo</code> 作为 <code>RPC</code> 框架，<code>Dubbo</code> 是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 <code>RPC</code> 实现服务的输出和输入功能，可以和 <code>Spring</code> 框架无缝集成。      </p><p><strong>5. 分布式服务框架</strong>   </p><p>本文采用 <code>ZooKeeper</code> 作为分布式服务框架，<code>ZooKeeper</code> 是一个分布式的，开源的分布式应用程序协调服务。  </p><p><strong>6. 全文检索框架</strong>    </p><p>本文采用 <code>Elasticsearch</code> ，<code>ElasticSearch</code> 是一个基于 <code>Lucene</code> 的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于 <code>RESTful web</code> 接口。<code>Elasticsearch</code> 是用 <code>Java</code> 开发的，并作为 <code>Apache</code> 许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。     </p><p><strong>7. 缓存框架</strong>    </p><p>文本采用 <code>Redis</code> 作为缓存框架，<code>Redis</code> 是一个开源的使用 <code>ANSI C</code> 语言编写、支持网络、可基于内存亦可持久化的日志型、<code>Key-Value</code> 数据库。    </p><p><strong>8. 数据库</strong>    </p><p>本文采用 <code>MySQL</code> 作为数据库系统。    </p><h2 id="后端实现"><a href="#后端实现" class="headerlink" title="后端实现"></a>后端实现</h2><h3 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h3><p>将日志数据收集和业务抽离出来，动态的从各种数据源搜集数据，并对数据进行过滤、分析、丰富、统一格式等操作，然后存储以供后续使用，实现不同服务器生成的日志的统一化管理，日志数据统一化管理具有非常重要的作用：</p><ul><li>日志分析：通过日志统一平台进行日志分析、统计，而不再需要运维者到一个个服务器里面去查看日志。  </li><li>数据查找：通过检索日志，掌握服务器的负荷和运行状态。     </li></ul><p>通过定时任务去获取华云提供的云主机性能数据，让数据和华云官方的保持数据一致，保证了数据的实时性、有效性。同时将获取到的数据进行清洗，只保留有用的数据，将数据发布到消息队列中间件 <code>RabbitMQ</code> 中。通过扇形交换器 <code>huayun.fanout</code> 将消息发布到 <code>huayun.es</code> 和 <code>huayun.persistence</code> 这两个队列中，前者用于将消息存储到 <code>Elasticsearch</code> 中，后者用于将消息存储到 <code>MySQL</code> 中。    </p><p><img src="https://user-gold-cdn.xitu.io/2019/7/5/16bc14f03e60eaef?w=1276&amp;h=368&amp;f=png&amp;s=45034" alt=""></p><p>通过消息延迟投递进行数据可靠性的保障，上游服务数据收集将数据将一个消息发送到 RabbitMQ 之后继续发送一个延迟消息到 RabbitMQ 中，下游服务消费消息之后，将取消消息投递给 RabbitMQ，回调服务 <code>Callback Service</code> 通过订阅下游服务投递的取消消息，知道了有哪些消息成功被消费了，如果当上游服务投递的延迟消息到达 RabbitMQ之后，回调服务获取到这个延迟消息之后，发现该消息并没有收到下游服务发来的取消消息，那么回调服务将重新调用上游服务，让上游服务重新投递，保证消息投递的可靠性。</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/5/16bc15549bcf551c?w=915&amp;h=501&amp;f=png&amp;s=45454" alt=""></p><h3 id="数据存储与检索"><a href="#数据存储与检索" class="headerlink" title="数据存储与检索"></a>数据存储与检索</h3><p>利用 <code>Elasticsearch</code> 对数据进行全文检索，其具有高扩展性，可以扩展到上百台服务器，处理PB级别的数据，同时还具有高效的检索能力，对于大量的数据也能快速的检索。采用 <code>Dubbo</code> + <code>ZooKeeper</code> 对外提供分布式的 RPC 服务，利用 <code>Zookeeper</code> 作为分布式服务管理，服务提供方将服务发布到注册中心，而服务消费方可以通过注册中心订阅服务，接收服务提供方服务变更通知，使用<code>Zookeeper</code>，能够对服务的调用情况进行监控分析。   </p><p><img src="https://user-gold-cdn.xitu.io/2019/7/5/16bc15c43eb4431e?w=784&amp;h=557&amp;f=png&amp;s=77778" alt=""></p><p>订阅消息队列中间件 <code>RabbitMQ</code>，<code>Elasticsearch</code> 服务层通过监听队列 <code>huayun.es</code>，当这个队列有消息达到时，<code>RabbitMQ</code> 将会主动将消息推送过来，<code>Elasticsearch</code> 服务层将接收到的消息存储到 <code>Elasticsearch</code> 中。同样，<code>MySQL</code> 服务层也将推送过来的消息存储到 <code>MySQL</code> 中。      </p><p>数据存储与检索除了提供数据持久化服务外，还对外提供数据检索的服务，通过 <code>ZooKeeper</code> 进行检索服务的注册，通过 <code>Dubbo</code> 提供<code>RPC</code>。     </p><p><img src="https://user-gold-cdn.xitu.io/2019/7/5/16bc15d2b6e31a3f?w=1128&amp;h=653&amp;f=png&amp;s=114914" alt=""></p><h3 id="监控报警"><a href="#监控报警" class="headerlink" title="监控报警"></a>监控报警</h3><p>基于数据存储与检索提供的服务，可以多维度的自定义规则，对服务器的运行状态实时监控，同时对于服务器出现的异常，监控报警能够及时的进行通知用户，报警消息发送后，可以让开发者一目了然地发现问题出现在什么地方，从而快速解决。    </p><p>监控报警通过订阅 <code>Zookeeper</code> 获取到服务信息，通过 <code>Dubbo 获取到数据存储与检索提供的检索服务，基于检索服务对数据进行检索和分析，根据报警规则定时的去对数据进行分析，当数据满足报警条件时自动进行报警，将报警信息实时的发送发给用户，同时将报警信息存储到</code> <code>MySQL</code>  中，以便日后查询。    </p><p>用户可以对报警规则进行多维度的设置，比如监控的属性、监控周期、周期数、触发报警的条件和阈值等。     </p><p><img src="https://user-gold-cdn.xitu.io/2019/7/5/16bc1637a334ceab?w=1173&amp;h=885&amp;f=png&amp;s=189434" alt=""></p><h3 id="统一服务层"><a href="#统一服务层" class="headerlink" title="统一服务层"></a>统一服务层</h3><p>统一服务层对外提供统一的 <code>API</code> ，前端可以通过统一服务层提供的 <code>API</code> 对数据的检索、报警规则的设置、云主机的管理、镜像管理和快照管理等。    </p><p>通过 <code>RPC</code> 使用数据的检索和监控报警的服务，同时通过增加 <code>Redis</code> 缓存层，将查询结果缓存到 <code>Redis</code> 中，提高效率。        </p><p><img src="https://user-gold-cdn.xitu.io/2019/7/5/16bc1640e3909626?w=1157&amp;h=612&amp;f=png&amp;s=119177" alt=""></p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>开源了我们队伍的作品，欢迎大家批评指正</p><p>源代码：<a href="https://github.com/xue8/huayun-cloud" target="_blank" rel="noopener">https://github.com/xue8/huayun-cloud</a></p><p>演示视频：<a href="https://www.bilibili.com/video/av61070949/" target="_blank" rel="noopener">https://www.bilibili.com/video/av61070949/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;好久没写博客了，主要是因为最近 2 个月在忙着做 2 个比赛，一个是中国软件杯，另一个是阿里的第五届中间件性能挑战赛，另外还有就是忙着准备秋
      
    
    </summary>
    
      <category term="技术杂谈" scheme="http://ddnd.cn/categories/Technique/"/>
    
    
  </entry>
  
  <entry>
    <title>深入浅出Spring Boot 起步依赖和自动配置</title>
    <link href="http://ddnd.cn/2019/05/10/springboot-starter-and-autoconfiguration/"/>
    <id>http://ddnd.cn/2019/05/10/springboot-starter-and-autoconfiguration/</id>
    <published>2019-05-10T13:06:25.000Z</published>
    <updated>2019-05-11T04:13:01.031Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ws4.sinaimg.cn/large/e0e01e43gy1g2x8t9auhqj21g80ys4qr.jpg" alt="image" width="100%"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们知道 Spring Boot 能快速的搭建起一个应用，简化了大量的配置过程，那到底有多”简”呢？<br>我们通过一个例子来说明，平时我们通过 <code>Spring</code>和<code>Spring MVC</code> 搭建一个<code>helloword</code>的 Web 应用，需要做以下工作：  </p><ul><li><ol><li>配置 pom.xml 添加 <code>Spring</code>、<code>Spring MVC</code>框架的依赖，同时还需要考虑这些不同的框架的不同版本是否存在不兼容的问题。</li></ol></li><li><ol start="2"><li>配置 Web.xml，加载 Spring、Spring MVC。</li></ol></li><li><ol start="3"><li>配置 Spring 。</li></ol></li><li><ol start="4"><li>配置 Spring MVC。</li></ol></li><li><ol start="5"><li>编写业务逻辑代码。</li></ol></li></ul><p>而使用 Spring Boot 搭建的话，需要做以下工作:    </p><ul><li><ol><li>配置 pom.xml 继承 Spring Boot 的 <code>pom.xml</code>，添加 Web 起步依赖。</li></ol></li><li><ol start="2"><li>创建启动引导类。</li></ol></li><li><ol start="3"><li>编写业务逻辑代码。</li></ol></li></ul><p>单从步骤数量上看就知道通过 Spring、Spring MVC 搭建比通过 <code>Spring Boot</code> 搭建更复杂，需要编写大量的配置，这还仅仅是在很少框架和 Spring 整合情况下，如果需要将多个第三方框架和 Spring 整合，恐怕就要陷入”配置地狱”了，此外这些配置基本都是固化的，也就是搭建新的应用，你仍然需要再次编写相同的配置信息，特别是在微服务这么火的当下，一个应用可能由十几个甚至几十个小型服务无组成，如果每个小型服务都重复的做着这些配置工作……。    </p><p>那有没有什么办法解决这个局面呢？答案是有的，那就是使用 <code>Spring Boot</code>，上从上面的例子就可以发现，使用 <code>Spring Boot</code> 的最大优点就是减少了配置的工作，那么是不是说使用 <code>Spring Boot</code> 就不需要这些配置过程了？当然不是，而是 <code>Spring Boot</code> 帮我们把这些工作给做了。   </p><p>那 Spring Boot 是如何帮我们把这些配置工作给做了呢？这就是本文需要探讨的问题了，在探讨之前，我们需要了解两个概念<strong>起步依赖</strong>和<strong>自动配置</strong>，这里暂且知道这两个东西是<code>Spring Boot</code>的核心、是<code>Spring Boot</code>的精华所在、是我们不需要再进行大量配置工作的原因所在就行了。  </p><h2 id="起步依赖"><a href="#起步依赖" class="headerlink" title="起步依赖"></a>起步依赖</h2><p>起步依赖说白了就是<code>Spring Boot</code>通过对常用的依赖进行再一次封装，例如我们平时需要搭建一个<code>Web</code>应用的时候，一般都会导入以下几个依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>也就是需要将<code>spring-web</code>和<code>spring mvc</code>分别导入，而使用<code>Spring Boot</code>的话只需要导入一个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>也就是只需要导入一个名为<code>web</code>的起步依赖即可，我们点<code>spring-boot-starter-web</code>进去可以看到，其实这个起步依赖集成了常用的 web 依赖，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.1.4.RELEASE&lt;/version&gt;</span><br><span class="line">  &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.1.4.RELEASE&lt;/version&gt;</span><br><span class="line">  &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.1.4.RELEASE&lt;/version&gt;</span><br><span class="line">  &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;6.0.16.Final&lt;/version&gt;</span><br><span class="line">  &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-web&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;5.1.6.RELEASE&lt;/version&gt;</span><br><span class="line">  &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;5.1.6.RELEASE&lt;/version&gt;</span><br><span class="line">  &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>也就是前面所说的，Spring Boot的起步依赖说白了就是对常用的依赖进行再一次封装，方便我们引入，简化了 pom.xml 配置，但是更重要的是将依赖的管理交给了 Spring Boot，我们无需关注不同的依赖的不同版本是否存在冲突的问题，Spring Boot 都帮我们考虑好了，我们拿来用即可！   </p><p>在使用 Spring Boot 的起步依赖之前，我们需要在<code>pom.xml</code>中添加配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.4.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure></p><p>即让<code>pom.xml</code>继承 Spring Boot 的<code>pom.xml</code>，而 Spring Boot 的<code>pom.xml</code>里面定义了常用的框架的依赖以及相应的版本号。    </p><p>总结一下 Spring Boot 的起步依赖的优点：   </p><ul><li><ol><li>无需考虑不同框架的不同版本的冲突问题。  </li></ol></li><li><ol start="2"><li>简化了<code>pom.xml</code>配置。</li></ol></li></ul><h2 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h2><p>如果将开发一个应用比喻成装修房子的过程，那么 Spring Boot 就像是一个全能型公司一样存在，而起步依赖可以比喻成购买装修用品的过程，自动配置比喻成用装修用品进行装修的过程。    </p><p>我们可以通过 Spring Boot 的起步依赖获取到你想要的涂料、瓷砖、装饰品等， Spring Boot 公司会根据最佳的组合将这些装修用品打包好给我们，我们无需考虑各种装修用品是否搭配、是否冲突等问题。     </p><p>通过起步依赖我们获取到了想要的装修用品，那接下来我们需要做的就是进行装修了，前面我们说过 Spring Boot 就像一个全能型公司一样，所以我们在他那里购买装修用品之后，<strong>他不仅将装修用品送上门还会帮我们完成装修(自动配置)</strong>，让我们享受一站式的服务，从购买装饰品(起步依赖)到装修完成(自动配置)都不用我们考虑，我们只需要在装修完成之后入住(编写自己的业务逻辑代码)即可。   </p><p>说了这么多，我们还不知道<code>Spring Boot</code>是如何完成自动配置的，接下来我们来分析 Spring Boot 神奇的自动配置！    </p><p>首先我们知道 Spring Boot 启动需要有一个启动引导类，这个类除了是应用的入口之外，还发挥着配置的 Spring Boot 的重要作用。下面是一个简单的启动引导类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class DemoApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们发现有一个名为<code>@SpringBootApplication</code>的注解，点击进去可以发现，这个注解发挥着多个注解的作用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(</span><br><span class="line">    excludeFilters = &#123;@Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), @Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>这里简要的说下<code>@SpringBootConfiguration</code>和<code>@ComponentScan</code>注解。前者实质为<code>@Configuration</code>注解，这个注解相比大家都接触过，也就是起到声明这个类为配置类的作用，而后者起到开启自动扫描组件的作用。     </p><p>这里需要重点分析的是<code>@EnableAutoConfiguration</code>这个注解，这个注解的作用是开启 Spring Boot 的自动配置功能，我们来分析一下它是如何开启的，点击进去可以看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@AutoConfigurationPackage</span><br><span class="line">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="line">public @interface EnableAutoConfiguration &#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() default &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>@EnableAutoConfiguration</code>这个注解同样发挥着多个注解的功能，我们重点分析<code>@Import({AutoConfigurationImportSelector.class})</code>这个注解，我们知道<code>@import</code>的作用是将组件添加到 Spring 容器中，而在这里即是将<code>AutoConfigurationImportSelector</code>这个组件添加到 Spring 容器中。   </p><p>我们进一步分析<code>AutoConfigurationImportSelector</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    if (!this.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        return EMPTY_ENTRY;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        AnnotationAttributes attributes = this.getAttributes(annotationMetadata);</span><br><span class="line">        List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes); </span><br><span class="line">        configurations = this.removeDuplicates(configurations);</span><br><span class="line">        Set&lt;String&gt; exclusions = this.getExclusions(annotationMetadata, attributes);</span><br><span class="line">        this.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">        configurations.removeAll(exclusions);</span><br><span class="line">        configurations = this.filter(configurations, autoConfigurationMetadata);</span><br><span class="line">        this.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">        return new AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);</span><br><span class="line">    return configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有一个名为<code>getAutoConfigurationEntry</code>的方法，这个方法发挥的作用是扫描<code>ClassPath</code>下的所有<code>jar</code>包的<code>spring.factories</code>文件，将<code>spring.factories</code>文件<code>key</code>为<code>EnableAutoConfiguration</code>的所有值取出，然后这些值其实是类的全限定名，<strong>也就是自动配置类的全限定名</strong>，然后 Spring Boot 通过这些全限定名进行类加载(反射)，将这些自动配置类添加到 Spring 容器中。    </p><p>那这些自动配置类有哪些？发挥什么作用呢？我们接着往下看，我们找到一个名为<code>spring-boot-autoconfigure-2.1.4.RELEASE.jar</code>的 jar 包，打开它的<code>spring.factories</code>文件，发现这个文件有<code>key</code>为<code>EnableAutoConfiguration</code>的键值对</p><p><img src="http://wx4.sinaimg.cn/large/e0e01e43gy1g2x8var3huj21br0o645t.jpg" alt="image"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cloud.CloudServiceConnectorsAutoConfiguration,\</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure></p><p>也就是这个<code>jar</code>包有自动配置类，可以发现这些自动配置配都是以<code>xxxAutoConfiguration</code>的命名规则来取名的，这些自动配置类包含我了们常用的框架的自动配置类，比如<code>aop</code>、<code>elasticsearch</code>、<code>redis</code>和<code>web</code>等等，基本能满足我们日常开发的需求。     </p><p>那这些自动配置类又是如何发挥配置作用的呢，我们取一个较为简单的配置类进行分析，名为<code>HttpEncodingAutoConfiguration</code>，它的部分代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Configuration  //声明这个类为配置类</span><br><span class="line">@EnableConfigurationProperties(&#123;HttpProperties.class&#125;)  //开启ConfigurationProperties功能，同时将配置文件和HttpProperties.class绑定起来</span><br><span class="line">@ConditionalOnWebApplication(  //只有在web应用下自动配置类才生效</span><br><span class="line">    type = Type.SERVLET</span><br><span class="line">)</span><br><span class="line">@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;) //只有存在CharacterEncodingFilter.class情况下 自动配置类才生效</span><br><span class="line">@ConditionalOnProperty( //判断配置文件是否存在某个配置spring.http.encoding，如果存在其值为enabled才生效，如果不存在这个配置类也生效。</span><br><span class="line">    prefix = &quot;spring.http.encoding&quot;,</span><br><span class="line">    value = &#123;&quot;enabled&quot;&#125;,</span><br><span class="line">    matchIfMissing = true</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//将字符编码过滤器组件添加到 Spring 容器中</span><br><span class="line">@Bean</span><br><span class="line">@ConditionalOnMissingBean</span><br><span class="line">public CharacterEncodingFilter characterEncodingFilter() &#123;</span><br><span class="line">    CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();</span><br><span class="line">    filter.setEncoding(this.properties.getCharset().name());</span><br><span class="line">    filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST));</span><br><span class="line">    filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE));</span><br><span class="line">    return filter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public HttpEncodingAutoConfiguration.LocaleCharsetMappingsCustomizer localeCharsetMappingsCustomizer() &#123;</span><br><span class="line">    return new HttpEncodingAutoConfiguration.LocaleCharsetMappingsCustomizer(this.properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先它同样有许多注解，我们一个一个分析：</p><ul><li>Configuration：这个注解声明了这个类为配置类(和我们平时写的配置类一样，同样是在类上加这个注解)。</li><li>EnableConfigurationProperties：开启<code>ConfigurationProperties</code>功能，也就是将配置文件和<code>HttpProperties.class</code>这个类绑定起来，将配置文件的相应的值和<code>HttpProperties.class</code>的变量关联起来，可以点击<code>HttpProperties.class</code>进去看看，下面截取了部分代码进行分析：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(</span><br><span class="line">    prefix = &quot;spring.http&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">public static final Charset DEFAULT_CHARSET;</span><br><span class="line">private Charset charset;</span><br><span class="line">private Boolean force;</span><br><span class="line">private Boolean forceRequest;</span><br><span class="line">private Boolean forceResponse;</span><br><span class="line">private Map&lt;Locale, Charset&gt; mapping;</span><br></pre></td></tr></table></figure></li></ul><p>通过<code>ConfigurationProperties</code>指定前缀，将配置文件<code>application.properties</code>前缀为<code>spring.http</code>的值和<code>HttpProperties.class</code>的变量关联起来，通过类的变量可以发现，我们可以设置的属性是<code>charset</code>、<code>force</code>、<code>forceRequest</code>、<code>forceResponse</code>和<code>mapping</code>。也就是我们除了使用 Spring Boot 默认提供的配置信息之外，我们还可以通过配置文件指定配置信息。</p><ul><li>ConditionalOnWebApplication：这个注解的作用是自动配置类在 Web 应用中才生效。</li><li>ConditionalOnClass：只有在存在<code>CharacterEncodingFilter</code>这个类的情况下自动配置类才会生效。</li><li>ConditionalOnProperty：判断配置文件是否存在某个配置 spring.http.encoding ，如果存在其值为 enabled 才生效，如果不存在这个配置类也生效。</li></ul><p>可以发现后面几个注解都是<code>ConditionalXXXX</code>的命名规则，这些注解是 Spring 制定的条件注解，只有在符合条件的情况下自动配置类才会生效。    </p><p>接下来的<code>characterEncodingFilter</code>方法，创建一个<code>CharacterEncodingFilter</code>的对象，也就是字符编码过滤器，同时设置相关属性，然后将对象返回，通过<code>@Bean</code>注解，将返回的对象添加到 Spring 容器中。这样字符编码过滤器组件配置好了，而平时的话，我们需要在 web.xml 进行如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">     &lt;filter-name&gt;springUtf8Encoding&lt;/filter-name&gt;</span><br><span class="line">     &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</span><br><span class="line">     &lt;init-param&gt;</span><br><span class="line">         &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">         &lt;param-value&gt;utf-8&lt;/param-value&gt;</span><br><span class="line">     &lt;/init-param&gt;</span><br><span class="line">     &lt;init-param&gt;</span><br><span class="line">         &lt;param-name&gt;forceEncoding&lt;/param-name&gt;</span><br><span class="line">         &lt;param-value&gt;true&lt;/param-value&gt;</span><br><span class="line">     &lt;/init-param&gt; </span><br><span class="line">  &lt;/filter&gt;</span><br><span class="line">  &lt;filter-mapping&gt;</span><br><span class="line">     &lt;filter-name&gt;springUtf8Encoding&lt;/filter-name&gt;</span><br><span class="line">     &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line"> &lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure></p><p>到这里是不是感受到了 Spring Boot 自动配置带来的好处了？    </p><p>接下来的<code>localeCharsetMappingsCustomizer</code>方法同理，就不分析了。   </p><p>最后我们用一句话总结一下 Spring Boot 的自动配置：Spring Boot 启动的时候，会扫描<code>ClassPath</code>下的所有 jar 包，将其<code>spring.factories</code>文件中<code>key</code>为<code>EnableAutoConfiguration</code>的所有值取出，然后这些值其实是类的全限定名，<strong>也就是自动配置类的全限定名</strong>，然后 Spring Boot 通过这些全限定名进行类加载(反射)，将这些自动配置类添加到 Spring 容器中。这些自动配置类根据不同的条件(@ConditionalXXX)决定自动配置类是否生效，生效的话自动配置类会将相关组件添加到 Spring 容器中，也就不用我们再进行配置!    </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看了网上挺多的文章都说的不是很清楚，所以按照自己的理解写下了这篇总结，有误之处欢迎指出。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://ws4.sinaimg.cn/large/e0e01e43gy1g2x8t9auhqj21g80ys4qr.jpg&quot; alt=&quot;image&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class
      
    
    </summary>
    
      <category term="Spring Boot" scheme="http://ddnd.cn/categories/Spring-Boot/"/>
    
    
      <category term="起步依赖" scheme="http://ddnd.cn/tags/%E8%B5%B7%E6%AD%A5%E4%BE%9D%E8%B5%96/"/>
    
      <category term="自动配置" scheme="http://ddnd.cn/tags/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>从0开始造一个轮子(方的)</title>
    <link href="http://ddnd.cn/2019/04/12/yohttp/"/>
    <id>http://ddnd.cn/2019/04/12/yohttp/</id>
    <published>2019-04-12T05:35:37.000Z</published>
    <updated>2019-04-12T10:33:33.667Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ws1.sinaimg.cn/large/e0e01e43gy1g1zyfrcqm6j20t60jg7wh.jpg" alt="image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>俗话说「不要重复造轮子」，但是我觉得通过研究大神造的轮子，然后自己去尝试造一个简陋版的，对于提升自己的软件构思是很有帮助的。<br>回归正题，最近在做一个作业，和计算机网络相关的，笔者选择了用Java开发一个简陋版的HTTP客户端，于是笔者去拜读了<code>Square</code>公司开源的<code>OkHttp</code>，参照了Okhttp的设计思想，开发了<code>Yohttp</code>。 </p><p>这里给出<code>Github</code>地址:<a href="https://github.com/xue8/yohttp" target="_blank" rel="noopener">YoHttp</a>，欢迎大家一起学习探讨。</p><h2 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h2><p><img src="http://wx3.sinaimg.cn/large/e0e01e43gy1g1zyft6158j21fk0lfmzz.jpg" alt="image"></p><p>笔者将软件大概设计成五大模块：  </p><ol><li><strong>请求信息</strong><br>这部分即对应上图的<code>Request</code>，用于用户构建请求信息，如<code>URL</code>、<code>method</code>、请求头等。这部分是用户可以操作的。</li><li><strong>Yohttp客户端</strong><br>用户创建一个<code>YoHttp</code>，然后将请求信息注入到Yohttp即可以开始使用请求功能，请求包括同步请求和异步请求，其中一个<code>YoHttp</code>包含一个调度中心、一个连接池，所以对于一个项目来说，维护着一个<code>YoHttp</code>客户端就足以。  </li><li><strong>处理链</strong><br>这里是请求的具体实现操作，笔者将一个一个操作封装成一个拦截器，如把获取<code>Socket</code>连接的操作封装成连接拦截器、把<code>Socket</code>流的读写封装成收发拦截器，然后我们请求需要用到哪些操作，即可把这些拦截器一个一个拼接起来组合成一个处理链(Chain)，<strong>一个处理链对应着一个请求</strong>。执行处理链中的一个个拦截器，直到执行完所有的拦截器，也对应着一个请求的完成。这也是为什么我们需要将收发拦截器放在最后，因为一个请求的最后一个操作肯定是进行Socket流的写和读。<br>笔者认为这样将一个一个操作封装成拦截器，然后组合拦截器拼凑成处理链，最后执行处理链即可达到执行操作，极大的解耦了请求过程，同时也提高了扩展性。</li></ol><p><img src="http://wx1.sinaimg.cn/large/e0e01e43gy1g1zyg4vt29j20do072aa3.jpg" alt="image"></p><ol start="4"><li><p><strong>调度中心</strong><br>调度中心在使用异步请求的时候用到，调度中心维护着一个请求队列和一个线程池，请求队列里面存储的是处理链<code>Chain</code>。线程池负责执行队列中的处理链。<br>笔者认为这里使用线程池能提高队列的处理效率，毕竟现在PC都是多核心的，充分利用CPU提高效率还是不错的。</p></li><li><p><strong>连接池</strong><br>每个请求都是去连接池获取<code>Socket</code>连接，如果连接池中存在<code>IP</code>、<code>PORT</code>相同的连接则直接返回，否则创建一个<code>Socket</code>连接存储到连接池然后返回，而连接池中的连接<strong>闲置时间超过最大允许闲置的时间后就会被关闭</strong>。<br>笔者认为通过使用连接池能减少连接创建销毁的开销，在请求较多、请求频率较高的场景下能提高效率。</p></li></ol><p>介绍完了架构，我们看看怎么使用我们的HTTP客户端：   </p><ol><li>同步请求   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Request request = new Request.Builder()</span><br><span class="line">        .url(&quot;www.baidu.com&quot;)</span><br><span class="line">        .get()</span><br><span class="line">        .build();</span><br><span class="line">YoHttpClient httpClient = new YoHttpClient();</span><br><span class="line">Response response = httpClient.SyncCall(request).executor();</span><br><span class="line">System.out.println(response.getBody());</span><br></pre></td></tr></table></figure></li></ol><p>第一步新建个请求信息<code>Request</code>，填写请求的<code>URL</code>、请求方法、请求头等信息。<br>第二步新建个<code>YoHttp</code>客户端，<strong>选择同步请求</strong>并将请求信息注入，执行请求。</p><ol start="2"><li>异步请求  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Request request = new Request.Builder()</span><br><span class="line">        .url(&quot;www.baidu.com&quot;)</span><br><span class="line">        .get()</span><br><span class="line">        .build();</span><br><span class="line">YoHttpClient httpClient = new YoHttpClient();</span><br><span class="line">httpClient.AsyncCall(request).executor(new CallBack() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onResponse(Response response) &#123;</span><br><span class="line">        System.out.println(response.getBody());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>第一步新建个请求信息<code>Request</code>，填写请求的<code>URL</code>、请求方法、请求头等信息。<br>第二步新建个<code>YoHttp</code>客户端，<strong>选择异步请求</strong>并将请求信息注入，执行请求，当请求有响应的时候，会通过回调异步请求的<code>onResponse</code>方法来反馈响应内容。   </p><p>说完了架构还有使用方法，接下来笔者介绍各个模块的具体实现。  </p><h2 id="请求信息"><a href="#请求信息" class="headerlink" title="请求信息"></a>请求信息</h2><p><img src="http://ws3.sinaimg.cn/large/e0e01e43gy1g1zyga9hkij20n50izmye.jpg" alt="image">  </p><p>在实现<code>Request</code>的时候，笔者使用的是<code>Builder</code>模式，即构造者模式，在<code>Request</code>中添加个<strong>静态内部类Builder</strong>，用于构造Request。</p><h2 id="YoHttpClient"><a href="#YoHttpClient" class="headerlink" title="YoHttpClient"></a>YoHttpClient</h2><p><img src="http://ws4.sinaimg.cn/large/e0e01e43gy1g1zyghl3wrj20n50izwfa.jpg" alt="image"></p><p>在YoHttp客户端中有一个调度中心和一个连接池，调度中心是使用异步请求的时候用上的，连接池则是在请求获取<code>Socket</code>连接的时候使用。  </p><ol><li><strong>构造方法</strong><br>笔者设置了两个构造方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public YoHttpClient() &#123;</span><br><span class="line">    this(5, TimeUnit.MINUTES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public YoHttpClient(int keepAliveTime, TimeUnit timeUnit) &#123;</span><br><span class="line">    this.dispatcher = new Dispatcher();</span><br><span class="line">    this.connectionPool = new ConnectionPool(keepAliveTime, timeUnit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>一个是无参构造方法，一个是指定连接池中连接最大闲置时间的构造方法，如果用户使用了无参构造方法，默认设置连接池中的连接最大闲置时间是<code>5</code>分钟。</p><ol start="2"><li><strong>同步请求方法SynchCall</strong>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public SyncCall SyncCall(Request request) &#123;</span><br><span class="line">    return new SyncCall(this, request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// SyncCall.java</span><br><span class="line">@Override</span><br><span class="line">public Response executor() &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (this.executed)</span><br><span class="line">            throw new IllegalStateException(&quot;Call Already Executed&quot;);</span><br><span class="line">        this.executed = true;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.add(new ConnectionInterceptor(yoHttpClient, request));</span><br><span class="line">    interceptors.add(new CallServerInterceptor(request));</span><br><span class="line">    Chain chain = new Chain(interceptors, null);</span><br><span class="line">    Response response = chain.proceed();</span><br><span class="line">    chain = null;</span><br><span class="line">    return response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Chain.java</span><br><span class="line">public Response proceed() &#123;</span><br><span class="line">    Response response = new Response();</span><br><span class="line">    for (int i = 0; i &lt; interceptors.size(); i++) &#123;</span><br><span class="line">        response = interceptors.get(i).proceed(response);</span><br><span class="line">    &#125;</span><br><span class="line">    return response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>创建一个<code>SynchCall</code>同步请求，SynchCall里面有个<code>executor</code>方法，这个方法创建一个存储拦截器<code>Interceptor</code>的List，我们把请求中需要用到的操作(拦截器)存入到List中，例如我们用到了连接拦截器(ConnectionInterceptor)、收发拦截器(CallServerInterceptor)，然后将List封装成一个<strong>处理链(Chain)</strong>，最后调用处理链的<code>proceed</code>方法遍历List中的拦截器并执行，这样即可达到执行一个请求的所有操作，这里是同步请求，所以阻塞到处理链执行完成返回response之后才return。</p><ol start="3"><li><strong>异步请求AsyncCall</strong>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public AsyncCall AsyncCall(Request request) &#123;</span><br><span class="line">    return new AsyncCall(this, request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//AsyncCall.java</span><br><span class="line">public void executor(CallBack callBack) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (this.executed)</span><br><span class="line">            throw new IllegalStateException(&quot;Call Already Executed&quot;);</span><br><span class="line">        this.executed = true;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.add(new ConnectionInterceptor(yoHttpClient, request));</span><br><span class="line">    interceptors.add(new CallServerInterceptor(request));</span><br><span class="line">    Chain chain = new Chain(interceptors, callBack);</span><br><span class="line">    yoHttpClient.getDispatcher().addChain(chain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>异步请求中，同样是在<code>executor</code>方法构造好所需的拦截器，将拦截器封装成处理链，<strong>区别的地方在这里并不是马上调用处理链的<code>proceed</code>方法，而是将处理链添加到调度中心的请求队列中，然后马上返回了</strong>，调度中心的具体实现在后文介绍。</p><h2 id="处理链"><a href="#处理链" class="headerlink" title="处理链"></a>处理链</h2><p>处理链在上文的YoHttpClient介绍的差不多了，这里补充一下拦截器的设计。<br>所有的拦截器都实现<code>Interceptor</code>这个接口，这个接口很简单，只有一个方法<code>proceed</code>，只需要将具体的操作写到这个方法即可。例如连接拦截器<code>ConnectionInterceptor</code>的实现如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Response proceed(Response response) &#123;</span><br><span class="line">    Address address = request.getAddress();</span><br><span class="line">    Connection connection = yoHttpClient.getConnectionPool().getConnection(address);</span><br><span class="line">    request.setConnection(connection);</span><br><span class="line">    return response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第一步是获取请求信息中的<code>IP</code>、<code>PORT</code>(笔者将这两者封装成了Address)<br>第二步是使用这个address去连接池中获取连接。  </p><p>这个proceed方法是提供给处理链中执行的。</p><h2 id="调度中心"><a href="#调度中心" class="headerlink" title="调度中心"></a>调度中心</h2><p><img src="http://ws4.sinaimg.cn/large/e0e01e43gy1g1zygq1zg3j20n50izt9w.jpg" alt="image"></p><p>调度中心在异步请求中使用到，调度中心维护着一个请求队列和一个线程池。笔者采用的是阻塞队列(考虑到并发问题)和可缓存线程池，这个线程池的特点：核心线程数是0，线程数最大是<code>Integer.MAX_VALUE</code>，线程闲置时间最大允许为60秒。<br>调度中心有2个内部类，一个是<code>CallRunnable</code>，这个内部类的作用是将处理链Chain封装成<code>Runnable</code>公线程执行。另一个是<code>ChainQueue</code>，这个内部类维护着一个阻塞队列，控制着请求的入队和出队。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void executor() &#123;</span><br><span class="line">    Thread thread = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                while (chainQueue.size() &gt; 0) &#123;</span><br><span class="line">                    executorService.submit(new CallRunnable(chainQueue.pollChain()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//CallRunnable内部类</span><br><span class="line">private final class CallRunnable implements Runnable &#123;</span><br><span class="line">    private Chain chain;</span><br><span class="line"></span><br><span class="line">    CallRunnable(Chain chain) &#123;</span><br><span class="line">        this.chain = chain;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Response response = chain.proceed();</span><br><span class="line">        chain.getCallBack().onResponse(response);</span><br><span class="line">        chain = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在调度中心开启了一个线程，通过遍历阻塞队列，如果阻塞队列中有请求，则交给线程池去处理</strong>，线程通过调用处理链的proceed方法来遍历处理链中的拦截器，这个和同步请求中的一样的，当执行完后才能通过回调将响应返回给客户端。</p><p><img src="http://ws2.sinaimg.cn/large/e0e01e43gy1g1zygx8qz0j20ls0hhwf5.jpg" alt="image"></p><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p><img src="http://ws3.sinaimg.cn/large/e0e01e43gy1g1zyh29034j20n50izaaw.jpg" alt="image"></p><p>笔者将<code>Socket</code>连接封装成一个<code>Connection</code>，而连接池维护的则是一个存储<code>Connection</code>的HashMap。 </p><ol><li><strong>获取连接</strong>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public Connection getConnection(Address address) &#123;</span><br><span class="line">    return tryAcquire(address);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Connection tryAcquire(Address address) &#123;</span><br><span class="line">    if (connections.containsKey(address)) &#123;</span><br><span class="line">        connections.get(address).setTime(System.currentTimeMillis());</span><br><span class="line">        return connections.get(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (address) &#123;</span><br><span class="line">        cleanUpConnection();</span><br><span class="line">        if (!connections.containsKey(address)) &#123;</span><br><span class="line">            Connection connection = new Connection(address);</span><br><span class="line">            connection.setTime(System.currentTimeMillis());</span><br><span class="line">            connections.put(address, connection);</span><br><span class="line">            return connection;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            connections.get(address).setTime(System.currentTimeMillis());</span><br><span class="line">            return connections.get(address);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>通过调用<code>getConnection</code>方法即可获取到一个连接，而getConnection的实现是通过调用私有方法<code>tryAcquire</code>，获取的流程如下：<br>第一步先判断连接池中是否存在address相同的连接，有则则更新线程的活跃时间然后直接返回，没有则执行第二步。<br>第二步锁住address，目的是防止多个线程同时创建同一个连接，锁住之后再次判断连接池是否存在连接了，没有则进行创建然后返回。</p><ol start="2"><li><strong>清理超过闲置时间的连接</strong>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void cleanUpConnection() &#123;</span><br><span class="line">    for (Map.Entry&lt;Address, Connection&gt; entry: connections.entrySet()) &#123;</span><br><span class="line">        if (System.currentTimeMillis() - entry.getValue().getTime() &lt;= keepAliveTime) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                connections.get(entry.getKey()).getSocket().close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            connections.remove(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这个cleanUpConnection方法在每次获取连接的时候都会执行一次，遍历连接池中的连接，如果连接池中的连接超过允许的闲置时间则关闭这个连接然后将连接移除Map。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>这个项目仅是学习使用，请勿用于生产环境</strong>。<br>目前仅实现了<code>GET</code>、<code>POST</code>、<code>DELETE</code>、<code>PUT</code>方法，希望后面会完善更多功能还有把IO改成NIO提高性能。<br>希望各位前辈看完之后能给点意见或者留下个赞~<br>最后再附上<code>Github</code>地址:<a href="https://github.com/xue8/yohttp" target="_blank" rel="noopener">YoHttp</a>，欢迎大家一起学习探讨。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://ws1.sinaimg.cn/large/e0e01e43gy1g1zyfrcqm6j20t60jg7wh.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="技术杂谈" scheme="http://ddnd.cn/categories/Technique/"/>
    
    
      <category term="YoHttp" scheme="http://ddnd.cn/tags/YoHttp/"/>
    
  </entry>
  
  <entry>
    <title>深入理解ReentrantLock的实现原理</title>
    <link href="http://ddnd.cn/2019/03/24/java-reentrantlock/"/>
    <id>http://ddnd.cn/2019/03/24/java-reentrantlock/</id>
    <published>2019-03-24T04:26:07.000Z</published>
    <updated>2019-03-25T05:47:54.342Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://wx1.sinaimg.cn/large/e0e01e43gy1g1dt0ye152j21g80ythdw.jpg" alt="image" width="100%"></p><h2 id="ReentrantLock简介"><a href="#ReentrantLock简介" class="headerlink" title="ReentrantLock简介"></a>ReentrantLock简介</h2><p><code>ReentrantLock</code>是<code>Java</code>在<code>JDK1.5</code>引入的显式锁，在实现原理和功能上都和内置锁(synchronized)上都有区别，在文章最后我们再比较这两个锁。<br>首先我们要知道<code>ReentrantLock</code>是基于<code>AQS</code>实现的，所以我们得对<code>AQS</code>有所了解才能更好的去学习掌握<code>ReentrantLock</code>，关于<code>AQS</code>的介绍可以参考我之前写的一篇文章<a href="https://ddnd.cn/2019/03/15/java-abstractqueuedsynchronizer/">《一文带你快速掌握AQS》</a>，这里简单回顾下<code>AQS</code>。</p><h3 id="AQS回顾"><a href="#AQS回顾" class="headerlink" title="AQS回顾"></a>AQS回顾</h3><p><code>AQS</code>即<code>AbstractQueuedSynchronizer</code>的缩写，这个是个内部实现了两个队列的抽象类，分别是<strong>同步队列</strong>和<strong>条件队列</strong>。其中<strong>同步队列</strong>是一个双向链表，里面储存的是处于等待状态的线程，正在排队等待唤醒去获取锁，而<strong>条件队列</strong>是一个单向链表，里面储存的也是处于等待状态的线程，只不过这些线程唤醒的结果是加入到了同步队列的队尾，<code>AQS</code>所做的就是管理这两个队列里面线程之间的<strong>等待状态-唤醒</strong>的工作。<br>在同步队列中，还存在<code>2</code>中模式，分别是<strong>独占模式</strong>和<strong>共享模式</strong>，这两种模式的区别就在于<code>AQS</code>在唤醒线程节点的时候是不是传递唤醒，这两种模式分别对应<strong>独占锁</strong>和<strong>共享锁</strong>。<br><code>AQS</code>是一个抽象类，所以不能直接实例化，当我们需要实现一个自定义锁的时候可以去继承<code>AQS</code>然后重写<strong>获取锁的方式</strong>和<strong>释放锁的方式</strong>还有<strong>管理state</strong>，而<code>ReentrantLock</code>就是通过重写了<code>AQS</code>的<code>tryAcquire</code>和<code>tryRelease</code>方法实现的<code>lock</code>和<code>unlock</code>。</p><p><img src="http://ws2.sinaimg.cn/large/e0e01e43gy1g1dsb1u2ekj20a0034t8l.jpg" alt="image"><br><img src="http://ws3.sinaimg.cn/large/e0e01e43gy1g1dsbdk6npj20bs03ba9z.jpg" alt="image"></p><h2 id="ReentrantLock原理"><a href="#ReentrantLock原理" class="headerlink" title="ReentrantLock原理"></a>ReentrantLock原理</h2><p>通过前面的回顾，是不是对<code>ReentrantLock</code>有了一定的了解了，<code>ReentrantLock</code>通过重写<strong>锁获取方式</strong>和<strong>锁释放方式</strong>这两个方法实现了<strong>公平锁</strong>和<strong>非公平锁</strong>，那么<code>ReentrantLock</code>是怎么重写的呢，这也就是本节需要探讨的问题。  </p><h3 id="ReentrantLock结构"><a href="#ReentrantLock结构" class="headerlink" title="ReentrantLock结构"></a>ReentrantLock结构</h3><p><img src="http://wx2.sinaimg.cn/large/e0e01e43gy1g1dsbrlztbj20vx0jqjsh.jpg" alt="image"></p><p>首先<code>ReentrantLock</code>继承自父类<code>Lock</code>，然后有<code>3</code>个内部类，其中<code>Sync</code>内部类继承自<code>AQS</code>，另外的两个内部类继承自<code>Sync</code>，这两个类分别是用来<strong>公平锁和非公平锁</strong>的。<br>通过<code>Sync</code>重写的方法<code>tryAcquire</code>、<code>tryRelease</code>可以知道，<strong><code>ReentrantLock</code>实现的是<code>AQS</code>的独占模式，也就是独占锁，这个锁是悲观锁</strong>。 </p><p><code>ReentrantLock</code>有个重要的成员变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final Sync sync;</span><br></pre></td></tr></table></figure></p><p>这个变量是用来指向<code>Sync</code>的子类的，也就是<code>FairSync</code>或者<code>NonfairSync</code>，这个也就是多态的<strong>父类引用指向子类</strong>，具体<code>Sycn</code>指向哪个子类，看构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync = new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ReentrantLock</code>有两个构造方法，无参构造方法默认是创建<strong>非公平锁</strong>，而传入<code>true</code>为参数的构造方法创建的是<strong>公平锁</strong>。</p><h3 id="非公平锁的实现原理"><a href="#非公平锁的实现原理" class="headerlink" title="非公平锁的实现原理"></a>非公平锁的实现原理</h3><p>当我们使用无参构造方法构造的时候即<code>ReentrantLock lock = new ReentrantLock()</code>，创建的就是非公平锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync = new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//或者传入false参数 创建的也是非公平锁</span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="lock方法获取锁"><a href="#lock方法获取锁" class="headerlink" title="lock方法获取锁"></a>lock方法获取锁</h4><ol><li><code>lock</code>方法调用<code>CAS</code>方法设置<code>state</code>的值，如果<code>state</code>等于期望值<code>0</code>(代表锁没有被占用)，那么就将<code>state</code>更新为<code>1</code>(代表该线程获取锁成功)，然后执行<code>setExclusiveOwnerThread</code>方法直接将该线程设置成锁的所有者。如果<code>CAS</code>设置<code>state</code>的值失败，即<code>state</code>不等于<code>0</code>，代表锁正在被占领着，则执行<code>acquire(1)</code>，即下面的步骤。</li><li><code>nonfairTryAcquire</code>方法首先调用<code>getState</code>方法获取<code>state</code>的值，如果<code>state</code>的值为<code>0</code>(之前占领锁的线程刚好释放了锁)，那么用<code>CAS</code>这是<code>state</code>的值，设置成功则将该线程设置成锁的所有者，并且返回<code>true</code>。如果<code>state</code>的值不为<code>0</code>，那就<strong>调用<code>getExclusiveOwnerThread</code>方法查看占用锁的线程是不是自己</strong>，如果是的话那就直接将<code>state + 1</code>，然后返回<code>true</code>。如果<code>state</code>不为<code>0</code>且锁的所有者又不是自己，那就返回<code>false</code>，<strong>然后线程会进入到同步队列中</strong>。</li></ol><p><img src="http://ws2.sinaimg.cn/large/e0e01e43gy1g1dsbx08f5j20v411wgo6.jpg" alt="image"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    //CAS操作设置state的值</span><br><span class="line">    if (compareAndSetState(0, 1))</span><br><span class="line">        //设置成功 直接将锁的所有者设置为当前线程 流程结束</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    else</span><br><span class="line">        //设置失败 则进行后续的加入同步队列准备</span><br><span class="line">        acquire(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    //调用子类重写的tryAcquire方法 如果tryAcquire方法返回false 那么线程就会进入同步队列</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//子类重写的tryAcquire方法</span><br><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    //调用nonfairTryAcquire方法</span><br><span class="line">    return nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    //如果状态state=0，即在这段时间内 锁的所有者把锁释放了 那么这里state就为0</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        //使用CAS操作设置state的值</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            //操作成功 则将锁的所有者设置成当前线程 且返回true，也就是当前线程不会进入同步</span><br><span class="line">            //队列。</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果状态state不等于0，也就是有线程正在占用锁，那么先检查一下这个线程是不是自己</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        //如果线程就是自己了，那么直接将state+1，返回true，不需要再获取锁 因为锁就在自己</span><br><span class="line">        //身上了。</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0) // overflow</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果state不等于0，且锁的所有者又不是自己，那么线程就会进入到同步队列。</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="tryRelease锁的释放"><a href="#tryRelease锁的释放" class="headerlink" title="tryRelease锁的释放"></a>tryRelease锁的释放</h4><ol><li>判断当前线程是不是锁的所有者，如果是则进行步骤<code>2</code>，如果不是则抛出异常。</li><li>判断此次释放锁后<code>state</code>的值是否为0，如果是则代表<strong>锁有没有重入</strong>，然后将锁的所有者设置成<code>null</code>且返回<code>true</code>，然后执行步骤<code>3</code>，如果不是则<strong>代表锁发生了重入</strong>执行步骤<code>4</code>。</li><li>现在锁已经释放完，即<code>state=0</code>，唤醒同步队列中的后继节点进行锁的获取。</li><li>锁还没有释放完，即<code>state!=0</code>，不唤醒同步队列。</li></ol><p><img src="http://wx1.sinaimg.cn/large/e0e01e43gy1g1dsc2pd21j20qv0mntas.jpg" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    //子类重写的tryRelease方法，需要等锁的state=0，即tryRelease返回true的时候，才会去唤醒其</span><br><span class="line">    //它线程进行尝试获取锁。</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    //状态的state减去releases</span><br><span class="line">    int c = getState() - releases;</span><br><span class="line">    //判断锁的所有者是不是该线程</span><br><span class="line">    if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        //如果所的所有者不是该线程 则抛出异常 也就是锁释放的前提是线程拥有这个锁，</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    boolean free = false;</span><br><span class="line">    //如果该线程释放锁之后 状态state=0，即锁没有重入，那么直接将将锁的所有者设置成null</span><br><span class="line">    //并且返回true，即代表可以唤醒其他线程去获取锁了。如果该线程释放锁之后state不等于0，</span><br><span class="line">    //那么代表锁重入了，返回false，代表锁还未正在释放，不用去唤醒其他线程。</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        free = true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="公平锁的实现原理"><a href="#公平锁的实现原理" class="headerlink" title="公平锁的实现原理"></a>公平锁的实现原理</h3><h4 id="lock方法获取锁-1"><a href="#lock方法获取锁-1" class="headerlink" title="lock方法获取锁"></a>lock方法获取锁</h4><ol><li>获取状态的<code>state</code>的值，如果<code>state=0</code>即代表锁没有被其它线程占用(但是并不代表同步队列没有线程在等待)，执行步骤<code>2</code>。如果<code>state!=0</code>则代表锁正在被其它线程占用，执行步骤<code>3</code>。</li><li><strong>判断同步队列是否存在线程(节点)，如果不存在则直接将锁的所有者设置成当前线程，且更新状态state，然后返回true。</strong></li><li><strong>判断锁的所有者是不是当前线程，如果是则更新状态state的值，然后返回true，如果不是，那么返回false，即线程会被加入到同步队列中</strong></li></ol><p>通过步骤<code>2</code><strong>实现了锁获取的公平性，即锁的获取按照先来先得的顺序，后来的不能抢先获取锁，非公平锁和公平锁也正是通过这个区别来实现了锁的公平性。</strong></p><p><img src="http://wx3.sinaimg.cn/large/e0e01e43gy1g1dscbljm2j20oe0iewgv.jpg" alt="image"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    acquire(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    //同步队列中有线程 且 锁的所有者不是当前线程那么将线程加入到同步队列的尾部，</span><br><span class="line">    //保证了公平性，也就是先来的线程先获得锁，后来的不能抢先获取。</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    //判断状态state是否等于0，等于0代表锁没有被占用，不等于0则代表锁被占用着。</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        //调用hasQueuedPredecessors方法判断同步队列中是否有线程在等待，如果同步队列中没有</span><br><span class="line">        //线程在等待 则当前线程成为锁的所有者，如果同步队列中有线程在等待，则继续往下执行</span><br><span class="line">        //这个机制就是公平锁的机制，也就是先让先来的线程获取锁，后来的不能抢先获取。</span><br><span class="line">        if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //判断当前线程是否为锁的所有者，如果是，那么直接更新状态state，然后返回true。</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果同步队列中有线程存在 且 锁的所有者不是当前线程，则返回false。</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="tryRelease锁的释放-1"><a href="#tryRelease锁的释放-1" class="headerlink" title="tryRelease锁的释放"></a>tryRelease锁的释放</h4><p>公平锁的释放和非公平锁的释放一样，这里就不重复。<br>公平锁和非公平锁的公平性是在<strong>获取锁</strong>的时候体现出来的，释放的时候都是一样释放的。</p><h3 id="lockInterruptibly可中断方式获取锁"><a href="#lockInterruptibly可中断方式获取锁" class="headerlink" title="lockInterruptibly可中断方式获取锁"></a>lockInterruptibly可中断方式获取锁</h3><p><code>ReentrantLock</code>相对于<code>Synchronized</code>拥有一些更方便的特性，比如可以中断的方式去获取锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireInterruptibly(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void acquireInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    //如果当前线程已经中断了，那么抛出异常</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    //如果当前线程仍然未成功获取锁，则调用doAcquireInterruptibly方法，这个方法和</span><br><span class="line">    //acquireQueued方法没什么区别，就是线程在等待状态的过程中，如果线程被中断，线程会</span><br><span class="line">    //抛出异常。</span><br><span class="line">    if (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="tryLock超时等待方式获取锁"><a href="#tryLock超时等待方式获取锁" class="headerlink" title="tryLock超时等待方式获取锁"></a>tryLock超时等待方式获取锁</h3><p><code>ReentrantLock</code>除了能以能中断的方式去获取锁，还可以以超时等待的方式去获取锁，所谓超时等待就是线程如果在超时时间内没有获取到锁，那么就会返回<code>false</code>，而不是一直”死循环”获取。</p><ol><li>判断当前节点是否已经中断，已经被中断过则抛出异常，如果没有被中断过则尝试获取锁，获取失败则调用<code>doAcquireNanos</code>方法使用超时等待的方式获取锁。</li><li>将当前节点封装成独占模式的节点加入到同步队列的队尾中。</li><li>进入到”死循环”中，<strong>但是这个死循环是有个限制的，也就是当线程达到超时时间了仍未获得锁，那么就会返回<code>false</code>，结束循环</strong>。这里调用的是<code>LockSupport.parkNanos</code>方法，在超时时间内没有被中断，那么线程会从<strong>超时等待状态转成了就绪状态</strong>，然后被<code>CPU</code>调度继续执行循环，<strong>而这时候线程已经达到超时等到的时间，返回false</strong>。<blockquote><p><code>LockSuport</code>的方法能响应<code>Thread.interrupt</code>，但是不会抛出异常</p></blockquote></li></ol><p><img src="http://ws4.sinaimg.cn/large/e0e01e43gy1g1dsckzb0qj20pv0odgp4.jpg" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public boolean tryLock(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    return sync.tryAcquireNanos(1, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean tryAcquireNanos(int arg, long nanosTimeout)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    //如果当前线程已经中断了  则抛出异常</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    //再尝试获取一次 如果不成功则调用doAcquireNanos方法进行超时等待获取锁</span><br><span class="line">    return tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean doAcquireNanos(int arg, long nanosTimeout)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (nanosTimeout &lt;= 0L)</span><br><span class="line">        return false;</span><br><span class="line">    //计算超时的时间 即当前虚拟机的时间+设置的超时时间</span><br><span class="line">    final long deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    //调用addWaiter将当前线程封装成独占模式的节点 并且加入到同步队列尾部</span><br><span class="line">    final Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            //如果当前节点的前驱节点为头结点 则让当前节点去尝试获取锁。</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                //当前节点获取锁成功 则将当前节点设置为头结点，然后返回true。</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = null; // help GC</span><br><span class="line">                failed = false;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果当前节点的前驱节点不是头结点 或者 当前节点获取锁失败，</span><br><span class="line">            //则再次判断当前线程是否已经超时。</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            if (nanosTimeout &lt;= 0L)</span><br><span class="line">                return false;</span><br><span class="line">            //调用shouldParkAfterFailedAcquire方法，告诉当前节点的前驱节点 我要进入</span><br><span class="line">            //等待状态了，到我了记得喊我，即做好进入等待状态前的准备。</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                //调用LockSupport.parkNanos方法，将当前线程设置成超时等待的状态。</span><br><span class="line">                LockSupport.parkNanos(this, nanosTimeout);</span><br><span class="line">            if (Thread.interrupted())</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ReentrantLock的等待-通知机制"><a href="#ReentrantLock的等待-通知机制" class="headerlink" title="ReentrantLock的等待/通知机制"></a>ReentrantLock的等待/通知机制</h3><p>我们知道关键字<code>Synchronized</code> + <code>Object</code>的<code>wait</code>和<code>notify</code>、<code>notifyAll</code>方法能实现<strong>等待/通知</strong>机制，那么<code>ReentrantLock</code>是否也能实现这样的等待/通知机制，答案是：可以。<br><code>ReentrantLock</code>通过<code>Condition</code>对象，也就是<strong>条件队列</strong>实现了和<code>wait</code>、<code>notify</code>、<code>notifyAll</code>相同的语义。<br>线程执行<code>condition.await()</code>方法，将节点1从同步队列转移到条件队列中。</p><p><img src="http://ws2.sinaimg.cn/large/e0e01e43gy1g1ezqs6cccj20xm079aba.jpg" alt="image"></p><p>线程执行<code>condition.signal()</code>方法，将节点1从条件队列中转移到同步队列。<br><img src="http://ws2.sinaimg.cn/large/e0e01e43gy1g1ezr0ia5zj20xt067gmn.jpg" alt="image"></p><p>因为只有在同步队列中的线程才能去获取锁，所以通过<code>Condition</code>对象的<code>wait</code>和<code>signal</code>方法能实现等待/通知机制。<br>代码示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = new ReentrantLock();</span><br><span class="line">Condition condition = lock.newCondition();</span><br><span class="line">public void await() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(&quot;线程获取锁----&quot; + Thread.currentThread().getName());</span><br><span class="line">        condition.await(); //调用await()方法 会释放锁，和Object.wait()效果一样。</span><br><span class="line">        System.out.println(&quot;线程被唤醒----&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        System.out.println(&quot;线程释放锁----&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void signal() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(1000);  //休眠1秒钟 等等一个线程先执行</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(&quot;另外一个线程获取到锁----&quot; + Thread.currentThread().getName());</span><br><span class="line">        condition.signal();</span><br><span class="line">        System.out.println(&quot;唤醒线程----&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        System.out.println(&quot;另外一个线程释放锁----&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Test t = new Test();</span><br><span class="line">    Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            t.await();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            t.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程获取锁----Thread-0</span><br><span class="line">另外一个线程获取到锁----Thread-1</span><br><span class="line">唤醒线程----Thread-1</span><br><span class="line">另外一个线程释放锁----Thread-1</span><br><span class="line">线程被唤醒----Thread-0</span><br><span class="line">线程释放锁----Thread-0</span><br></pre></td></tr></table></figure></p><p>执行的流程大概是这样，线程<code>t1</code>先获取到锁，输出了”线程获取锁—-Thread-0”，然后线程<code>t1</code>调用<code>await</code>方法，调用这个方法的结果就是<strong>线程<code>t1</code>释放了锁进入等待状态，等待唤醒</strong>，接下来线程<code>t2</code>获取到锁，然输出了”另外一个线程获取到锁—-Thread-1”，同时线程<code>t2</code>调用<code>signal</code>方法，调用这个方法的结果就是<strong>唤醒一个在条件队列(Condition)的线程，然后线程<code>t1</code>被唤醒，而这个时候线程<code>t2</code>并没有释放锁，线程<code>t1</code>也就没法获得锁，等线程<code>t2</code>继续执行输出”唤醒线程—-Thread-1”之后线程<code>t2</code>释放锁且输出”另外一个线程释放锁—-Thread-1”，这时候线程<code>t1</code>获得锁，继续往下执行输出了<code>线程被唤醒----Thread-0</code>，然后释放锁输出”线程释放锁—-Thread-0”</strong>。    </p><p>如果想单独唤醒部分线程应该怎么做呢？这时就有必要使用多个<code>Condition</code>对象了，因为<code>ReentrantLock</code>支持创建多个<code>Condition</code>对象，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//为了减少篇幅 仅给出伪代码</span><br><span class="line">ReentrantLock lock = new ReentrantLock();</span><br><span class="line">Condition condition = lock.newCondition();</span><br><span class="line">Condition condition1 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">//线程1 调用condition.await() 线程进入到条件队列</span><br><span class="line">condition.await();</span><br><span class="line"></span><br><span class="line">//线程2 调用condition1.await() 线程进入到条件队列</span><br><span class="line">condition1.await();</span><br><span class="line"></span><br><span class="line">//线程32 调用condition.signal() 仅唤醒调用condition中的线程，不会影响到调用condition1。</span><br><span class="line">condition1.await();</span><br></pre></td></tr></table></figure></p><p>这样就实现了部分唤醒的功能。</p><h2 id="ReentrantLock和Synchronized对比"><a href="#ReentrantLock和Synchronized对比" class="headerlink" title="ReentrantLock和Synchronized对比"></a>ReentrantLock和Synchronized对比</h2><p>关于<code>Synchronized</code>的介绍可以看<a href="https://ddnd.cn/2019/03/21/java-synchronized/">《synchronized的使用（一）》</a>、<a href="https://ddnd.cn/2019/03/22/java-synchronized-2/">《深入分析synchronized原理和锁膨胀过程(二)》</a>  </p><table><thead><tr><th></th><th>ReentrantLock</th><th>Synchronized</th></tr></thead><tbody><tr><td>底层实现</td><td>通过<code>AQS</code>实现</td><td>通过<code>JVM</code>实现，其中<code>synchronized</code>又有多个类型的锁，除了重量级锁是通过<code>monitor</code>对象(操作系统mutex互斥原语)实现外，其它类型的通过对象头实现。</td></tr><tr><td>是否可重入</td><td>是</td><td>是</td></tr><tr><td>公平锁</td><td>是</td><td>否</td></tr><tr><td>非公平锁</td><td>是</td><td>是</td></tr><tr><td>锁的类型</td><td>悲观锁、显式锁</td><td>悲观锁、隐式锁(内置锁)</td></tr><tr><td>是否支持中断</td><td>是</td><td>否</td></tr><tr><td>是否支持超时等待</td><td>是</td><td>否</td></tr><tr><td>是否自动获取/释放锁</td><td>否</td><td>是</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Java并发编程的艺术》<br><a href="https://juejin.im/post/5aeb07ab6fb9a07ac36350c8#heading-10" target="_blank" rel="noopener">深入理解AbstractQueuedSynchronizer(AQS)</a><br><a href="https://www.imooc.com/article/28934" target="_blank" rel="noopener">Java 重入锁 ReentrantLock 原理分析)</a>   </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://wx1.sinaimg.cn/large/e0e01e43gy1g1dt0ye152j21g80ythdw.jpg&quot; alt=&quot;image&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;ReentrantLock简介&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="Java编程基础" scheme="http://ddnd.cn/categories/Java-Programming/"/>
    
    
      <category term="多线程" scheme="http://ddnd.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="ReentrantLock" scheme="http://ddnd.cn/tags/ReentrantLock/"/>
    
      <category term="AQS" scheme="http://ddnd.cn/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>深入分析synchronized原理和锁膨胀过程(二)</title>
    <link href="http://ddnd.cn/2019/03/22/java-synchronized-2/"/>
    <id>http://ddnd.cn/2019/03/22/java-synchronized-2/</id>
    <published>2019-03-22T15:10:17.000Z</published>
    <updated>2019-03-23T06:04:09.917Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ws1.sinaimg.cn/large/e0e01e43gy1g1bza8l04cj21g80yte82.jpg" alt="image" width="100%"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章介绍了多线程的概念及<code>synchronized</code>的使用方法<a href="https://ddnd.cn/2019/03/21/java-synchronized/">《synchronized的使用（一）》</a>，但是仅仅会用还是不够的，只有了解其底层实现才能在开发过程中运筹帷幄，所以本篇探讨<code>synchronized</code>的实现原理及锁升级(膨胀)的过程。</p><h2 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h2><p><code>synchronized</code>是依赖于<code>JVM</code>来实现同步的，在同步方法和代码块的原理有点区别。</p><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>我们在代码块加上<code>synchronized</code>关键字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void synSay() &#123;</span><br><span class="line">    synchronized (object) &#123;</span><br><span class="line">        System.out.println(&quot;synSay----&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译之后，我们利用反编译命令<code>javap -v xxx.class</code>查看对应的字节码，这里为了减少篇幅，我就只粘贴对应的方法的字节码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public void synSay();</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=3, locals=3, args_size=1</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: getfield      #2                  // Field object:Ljava/lang/String;</span><br><span class="line">       4: dup</span><br><span class="line">       5: astore_1</span><br><span class="line">       6: monitorenter</span><br><span class="line">       7: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      10: new           #4                  // class java/lang/StringBuilder</span><br><span class="line">      13: dup</span><br><span class="line">      14: invokespecial #5                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">      17: ldc           #6                  // String synSay----</span><br><span class="line">      19: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      22: invokestatic  #8                  // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;</span><br><span class="line">      25: invokevirtual #9                  // Method java/lang/Thread.getName:()Ljava/lang/String;</span><br><span class="line">      28: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      31: invokevirtual #10                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      34: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      37: aload_1</span><br><span class="line">      38: monitorexit</span><br><span class="line">      39: goto          47</span><br><span class="line">      42: astore_2</span><br><span class="line">      43: aload_1</span><br><span class="line">      44: monitorexit</span><br><span class="line">      45: aload_2</span><br><span class="line">      46: athrow</span><br><span class="line">      47: return</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           7    39    42   any</span><br><span class="line">          42    45    42   any</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 21: 0</span><br><span class="line">      line 22: 7</span><br><span class="line">      line 23: 37</span><br><span class="line">      line 24: 47</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          0      48     0  this   Lcn/T1;</span><br><span class="line">    StackMapTable: number_of_entries = 2</span><br><span class="line">      frame_type = 255 /* full_frame */</span><br><span class="line">        offset_delta = 42</span><br><span class="line">        locals = [ class cn/T1, class java/lang/Object ]</span><br><span class="line">        stack = [ class java/lang/Throwable ]</span><br><span class="line">      frame_type = 250 /* chop */</span><br><span class="line">        offset_delta = 4</span><br></pre></td></tr></table></figure></p><p>可以发现<code>synchronized</code>同步代码块是通过加<code>monitorenter</code>和<code>monitorexit</code>指令实现的。<br>每个对象都有个<strong>监视器锁(monitor) </strong>，当<code>monitor</code>被占用的时候就代表对象处于锁定状态，而<code>monitorenter</code>指令的作用就是获取<code>monitor</code>的所有权，<code>monitorexit</code>的作用是释放<code>monitor</code>的所有权，这两者的工作流程如下：<br><strong>monitorenter</strong>：  </p><ol><li>如果<code>monitor</code>的进入数为0，则线程进入到<code>monitor</code>，然后将进入数设置为<code>1</code>，该线程称为<code>monitor</code>的所有者。</li><li>如果是线程已经拥有此<code>monitor</code>(即<code>monitor</code>进入数不为0)，然后该线程又重新进入<code>monitor</code>，则将<code>monitor</code>的进入数<code>+1</code>，这个即为<strong>锁的重入</strong>。</li><li>如果其他线程已经占用了<code>monitor</code>，则该线程进入到<strong>阻塞状态，知道<code>monitor</code>的进入数为0，该线程再去重新尝试获取<code>monitor</code>的所有权</strong>。</li></ol><p><strong>monitorexit</strong>：执行该指令的线程必须是<code>monitor</code>的所有者，指令执行时，<code>monitor</code>进入数<code>-1</code>，如果<code>-1</code>后进入数为<code>0</code>，那么线程退出<code>monitor</code>，不再是这个<code>monitor</code>的所有者。这个时候其它阻塞的线程可以尝试获取<code>monitor</code>的所有权。</p><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>在方法上加上<code>synchronized</code>关键字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized public void synSay() &#123;</span><br><span class="line">    System.out.println(&quot;synSay----&quot; + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译之后，我们利用反编译命令<code>javap -v xxx.class</code>查看对应的字节码，这里为了减少篇幅，我就只粘贴对应的方法的字节码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void synSay();</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">  Code:</span><br><span class="line">    stack=3, locals=1, args_size=1</span><br><span class="line">       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: new           #3                  // class java/lang/StringBuilder</span><br><span class="line">       6: dup</span><br><span class="line">       7: invokespecial #4                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">      10: ldc           #5                  // String synSay----</span><br><span class="line">      12: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      15: invokestatic  #7                  // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;</span><br><span class="line">      18: invokevirtual #8                  // Method java/lang/Thread.getName:()Ljava/lang/String;</span><br><span class="line">      21: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      24: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      27: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      30: return</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 20: 0</span><br><span class="line">      line 21: 30</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          0      31     0  this   Lcn/T1;</span><br></pre></td></tr></table></figure></p><p>从字节码上看，加有<code>synchronized</code>关键字的方法，常量池中比普通的方法多了个<code>ACC_SYNCHRONIZED</code>标识，<code>JVM</code>就是根据这个标识来实现方法的同步。<br>当调用方法的时候，调用指令会检查方法是否有<code>ACC_SYNCHRONIZED</code>标识，有的话<strong>线程需要先获取<code>monitor</code>，获取成功才能继续执行方法，方法执行完毕之后，线程再释放<code>monitor</code>，同一个<code>monitor</code>同一时刻只能被一个线程拥有。</strong></p><h3 id="两种同步方式区别"><a href="#两种同步方式区别" class="headerlink" title="两种同步方式区别"></a>两种同步方式区别</h3><p><code>synchronized</code>同步代码块的时候通过加入字节码<code>monitorenter</code>和<code>monitorexit</code>指令来实现<code>monitor</code>的获取和释放，也就是需要<strong>JVM通过字节码显式的去获取和释放monitor实现同步</strong>，而synchronized同步方法的时候，没有使用这两个指令，而是检查方法的<code>ACC_SYNCHRONIZED</code>标志是否被设置，如果设置了则线程需要先去获取monitor，执行完毕了线程再释放monitor，也就是不需要JVM去显式的实现。<br><strong>这两个同步方式实际都是通过获取monitor和释放monitor来实现同步的，而monitor的实现依赖于底层操作系统的<code>mutex</code>互斥原语，而操作系统实现线程之间的切换的时候需要从用户态转到内核态，这个转成过程开销比较大。</strong><br>线程获取、释放<code>monitor</code>的过程如下：</p><p><img src="http://ws1.sinaimg.cn/large/e0e01e43gy1g1bz6hjdg5j21100b13zn.jpg" alt="image"></p><p>线程尝试获取<code>monitor</code>的所有权，如果获取失败说明<code>monitor</code>被其他线程占用，则将线程加入到的<strong>同步队列</strong>中，等待其他线程释放<code>monitor</code>，<strong>当其他线程释放<code>monitor</code>后，有可能刚好有线程来获取<code>monitor</code>的所有权，那么系统会将<code>monitor</code>的所有权给这个线程，而不会去唤醒同步队列的第一个节点去获取，所以<code>synchronized</code>是非公平锁</strong>。如果线程获取<code>monitor</code>成功则进入到<code>monitor</code>中，并且将其进入数<code>+1</code>。   </p><blockquote><p>关于什么是公平锁、非公平锁可以参考一下美团技术团队写的<a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">《不可不说的Java“锁”事》</a></p></blockquote><p>到这里我们也清楚了<code>synchronized</code>的语义底层是通过一个<code>monitor</code>的对象完成，其实<code>wait</code>、<code>notiyf</code>和<code>notifyAll</code>等方法也是依赖于<code>monitor</code>对象来完成的，<strong>这也就是为什么需要在同步方法或者同步代码块中调用的原因(需要先获取对象的锁，才能执行)，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常</strong></p><h2 id="Java对象的组成"><a href="#Java对象的组成" class="headerlink" title="Java对象的组成"></a>Java对象的组成</h2><p>我们知道了线程要访问同步方法、代码块的时候，首先需要取得锁，在退出或者抛出异常的时候又必须释放锁，那么锁到底是什么？又储存在哪里？<br>为了解开这个疑问，我们需要进入<strong>Java虚拟机(JVM)</strong> 的世界。在<code>HotSpot</code>虚拟机中，<code>Java</code>对象在内存中储存的布局可以分为<code>3</code>块区域：<strong>对象头</strong>、<strong>实例数据</strong>、<strong>对齐填充</strong>。<strong>synchronized使用的锁对象储存在对象头中</strong></p><p><img src="http://wx1.sinaimg.cn/large/e0e01e43gy1g1bz6lmj8hj20tp0jugmz.jpg" alt="image"></p><p><img src="http://wx3.sinaimg.cn/large/e0e01e43gy1g1bz6qoa7wj20u40f6t9u.jpg" alt="image"></p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象头的数据长度在<code>32</code>位和<code>64</code>位(未开启压缩指针)的虚拟机中分别为<code>32bit</code>和<code>64bit</code>。对象头由以下三个部分组成：</p><ul><li>Mark Word：记录了对象和锁的有关信息，储存对象自身的运行时数据，如哈希码(HashCode)、<code>GC</code>分代年龄、锁标志位、线程持有的锁、偏向线程<code>ID</code>、偏向时间戳、对象分代年龄等。<strong>注意这个Mark Word结构并不是固定的，它会随着锁状态标志的变化而变化，而且里面的数据也会随着锁状态标志的变化而变化，这样做的目的是为了节省空间</strong>。</li><li>类型指针：指向对象的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li><li>数组长度：这个属性只有数组对象才有，储存着数组对象的长度。</li></ul><p>在<code>32</code>位虚拟机下，<code>Mark Word</code>的结构和数据可能为以下<code>5</code>种中的一种。</p><p><img src="http://ws4.sinaimg.cn/large/e0e01e43gy1g1bz6v6hlwj20ua09w74v.jpg" alt="image"></p><p>在<code>64</code>位虚拟机下，<code>Mark Word</code>的结构和数据可能为以下<code>2</code>种中的一种。</p><p><img src="http://ws3.sinaimg.cn/large/e0e01e43gy1g1bz70u4nxj215l070wh2.jpg" alt="image"></p><p>这里重点注意<strong>是否偏向锁</strong>和<strong>锁标志位</strong>，这两个标识和<code>synchronized</code>的锁膨胀息息相关。</p><h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>储存着对象的实际数据，也就是我们在程序中定义的各种类型的字段内容。</p><h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p><code>HotSpot</code>虚拟机的对齐方式为<code>8</code>字节对齐，即一个对象必须为<code>8</code>字节的整数倍，如果不是，则通过这个对齐填充来占位填充。</p><h2 id="synchronized锁膨胀过程"><a href="#synchronized锁膨胀过程" class="headerlink" title="synchronized锁膨胀过程"></a>synchronized锁膨胀过程</h2><p>上文介绍的 “<code>synchronized</code>实现原理” 实际是synchronized实现<strong>重量级锁的原理</strong>，那么上文频繁提到<code>monitor</code>对象和对象又存在什么关系呢，或者说<code>monitor</code>对象储存在对象的哪个地方呢？<br><strong>在对象的对象头中，当锁的状态为重量级锁的时候，它的指针即指向<code>monitor</code>对象</strong>，如图：</p><p><img src="http://ws1.sinaimg.cn/large/e0e01e43gy1g1bz7859jqj20ox08mq3x.jpg" alt="image"></p><p><img src="http://wx2.sinaimg.cn/large/e0e01e43gy1g1bz7eiy73j21um0xse1f.jpg" alt="image"></p><p>那锁的状态为其它状态的时候是不是就没用上<code>monitor</code>对象？答案:是的。<br>这也是<code>JVM</code>对<code>synchronized</code>的优化，我们知道重量级锁的实现是基于底层操作系统的<code>mutex</code>互斥原语的，这个开销是很大的。所以<code>JVM</code>对<code>synchronized</code>做了优化，<code>JVM</code>先利用对象头实现锁的功能，如果线程的竞争过大则会将锁升级(膨胀)为重量级锁，也就是使用<code>monitor</code>对象。当然<code>JVM</code>对锁的优化不仅仅只有这个，还有引入适应性自旋、锁消除、锁粗化、轻量级锁、偏向锁等。</p><p>那么锁的是怎么进行膨胀的或者依据什么来膨胀，这也就是本篇需要介绍的重点，首先我们需要了解几个概念。     </p><h3 id="锁的优化"><a href="#锁的优化" class="headerlink" title="锁的优化"></a>锁的优化</h3><h4 id="自旋锁和自适应性自旋锁"><a href="#自旋锁和自适应性自旋锁" class="headerlink" title="自旋锁和自适应性自旋锁"></a>自旋锁和自适应性自旋锁</h4><p><strong>自旋</strong>：当有个线程<code>A</code>去请求某个锁的时候，这个锁正在被其它线程占用，但是线程<code>A</code>并不会马上进入阻塞状态，而是循环请求锁(自旋)。这样做的目的是因为很多时候持有锁的线程会很快释放锁的，线程<code>A</code>可以尝试一直请求锁，没必要被挂起放弃<code>CPU</code>时间片，因为线程被挂起然后到唤醒这个过程开销很大,当然如果线程<code>A</code>自旋指定的时间还没有获得锁，仍然会被挂起。   </p><p><strong>自适应性自旋</strong>：自适应性自旋是自旋的升级、优化，自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定。例如<strong>线程如果自旋成功了，那么下次自旋的次数会增多</strong>，因为<code>JVM</code>认为既然上次成功了，那么这次自旋也很有可能成功，那么它会允许自旋的次数更多。反之，如果<strong>对于某个锁，自旋很少成功</strong>，那么在以后获取这个锁的时候，自旋的次数会变少甚至忽略，避免浪费处理器资源。有了自适应性自旋，随着程序运行和性能监控信息的不断完善，<code>JVM</code>对程序锁的状况预测就会变得越来越准确，<code>JVM</code>也就变得越来越聪明。</p><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>锁消除是指虚拟机即时编译器在运行时，<strong>对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除</strong>。</p><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>在使用锁的时候，需要让同步块的作用范围尽可能小，这样做的目的是<strong>为了使需要同步的操作数量尽可能小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁</strong>。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>所谓<strong>轻量级锁</strong>是相对于使用底层操作系统<code>mutex</code>互斥原语实现同步的<strong>重量级锁</strong>而言的，因为轻量级锁同步的<strong>实现是基于对象头的Mark Word</strong>。那么轻量级锁是怎么使用对象头来实现同步的呢，我们看看具体实现过程。  </p><p><strong>获取锁过程</strong>：  </p><ol><li>在线程进入同步方法、同步块的时候，如果<strong>同步对象锁状态为无锁状态(锁标志位为”01”状态，是否为偏向锁为”0”)</strong>，虚拟机首先将在当前线程的栈帧中<strong>建立一个名为锁记录(Lock Recored)的空间</strong>，用于储存锁对象目前的Mark Word的拷贝(官方把这份拷贝加了个Displaced前缀，即Displaced Mark Word)。</li></ol><p><img src="http://wx3.sinaimg.cn/large/e0e01e43gy1g1bz7ossirj20i5086q40.jpg" alt="image"></p><ol start="2"><li>将对象头的<code>Mark Word</code>拷贝到线程的锁记录(Lock Recored)中。</li><li>拷贝成功后，虚拟机将使用<code>CAS</code>操作<strong>尝试将对象的<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针</strong>。如果这个更新成功了，则执行步骤<code>4</code>，否则执行步骤<code>5</code>。</li><li>更新成功，这个<strong>线程就拥有了该对象的锁，并且对象Mark Word的锁标志位将转变为”00”，即表示此对象处于轻量级锁的状态。</strong>。</li></ol><p><img src="http://ws3.sinaimg.cn/large/e0e01e43gy1g1bz7u2xk8j20en08uab0.jpg" alt="image"></p><ol start="5"><li>更新失败，虚拟机首先会检查对象的<code>Mark Word</code>是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，可以直接进入同步块继续执行，否则说明这个锁对象已经被其其它线程抢占了。<strong>进行自旋执行步骤<code>3</code>，如果自旋结束仍然没有获得锁，轻量级锁就需要膨胀为重量级锁，锁标志位状态值变为”10”，Mark Word中储存就是指向<code>monitor</code>对象的指针，当前线程以及后面等待锁的线程也要进入阻塞状态。</strong></li></ol><p><img src="http://ws2.sinaimg.cn/large/e0e01e43gy1g1bz7zl1axj20fr08hmy4.jpg" alt="image"></p><p><strong>释放锁的过程</strong>：</p><ol><li>使用<code>CAS</code>操作将对象当前的<code>Mark Word</code>和线程中复制的<code>Displaced Mark Word</code>替换回来(依据<code>Mark Word</code>中锁记录指针是否还指向本线程的锁记录)，如果替换成功，则执行步骤<code>2</code>，否则执行步骤<code>3</code>。</li><li>如果替换成功，整个同步过程就完成了，恢复到无锁的状态(01)。</li><li>如果替换失败，说明有其他线程尝试获取该锁(此时锁已膨胀)，那就要在释放锁的同时，唤醒被挂起的线程。</li></ol><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁的目的是消除数据在无竞争情况下的同步原语，<strong>进一步提高程序的运行性能</strong>。如果说轻量级锁是在无竞争的情况下使用<code>CAS</code>操作区消除同步使用的互斥量，那么偏向锁就是在无竞争的情况下把整个同步都消除掉，连<code>CAS</code>操作都不用做了。<strong>偏向锁默认是开启的，也可以关闭</strong>。<br>偏向锁”偏”，就是”偏心”的”偏”，它的意思是这个锁会偏向于第一个获得它的程序，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。  </p><p><strong>获取锁的过程</strong>：</p><ol><li>检查<code>Mark Word</code>是否为<strong>可偏向锁的状态</strong>，即是否偏向锁即为1即表示支持可偏向锁，否则为0表示不支持可偏向锁。</li><li>如果是可偏向锁，则<strong>检查<code>Mark Word</code>储存的线程<code>ID</code>是否为当前线程<code>ID</code></strong>，如果是则执行同步块，否则执行步骤<code>3</code>。</li><li>如果检查到<code>Mark Word</code>的<code>ID</code>不是本线程的<code>ID</code>，则通过<code>CAS</code>操作去修改线程<code>ID</code>修改成本线程的<code>ID</code>，如果修改成功则执行同步代码块，否则执行步骤<code>4</code>。</li><li>当拥有该锁的线程到达安全点之后，挂起这个线程，升级为轻量级锁。</li></ol><p><strong>锁释放的过程</strong>：</p><ol><li>有其他线程来获取这个锁，偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。</li><li>等待全局安全点(在这个是时间点上没有字节码正在执行)。</li><li>暂停拥有偏向锁的线程，检查持有偏向锁的线程是否活着，如果不处于活动状态，则将对象头设置为无锁状态，否则设置为被锁定状态。如果锁对象处于<strong>无锁状态，则恢复到无锁状态(01)</strong>，以允许其他线程竞争，如果<strong>锁对象处于锁定状态</strong>，则挂起持有偏向锁的线程，并将对象头<code>Mark Word</code>的锁记录指针改成当前线程的锁记录，锁<strong>升级为轻量级锁状态(00)</strong>。</li></ol><p><img src="http://wx2.sinaimg.cn/large/e0e01e43gy1g1bz85piqtj20k20fbq3o.jpg" alt="image"></p><h3 id="锁的转换过程"><a href="#锁的转换过程" class="headerlink" title="锁的转换过程"></a>锁的转换过程</h3><p>锁主要存在<code>4</code>种状态，级别从低到高依次是：<strong>无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态</strong>，这几个状态会随着竞争的情况逐渐升级，这几个锁只有重量级锁是需要使用操作系统底层<code>mutex</code>互斥原语来实现，其他的锁都是使用对象头来实现的。<strong>需要注意锁可以升级，但是不可以降级。</strong>    </p><p><img src="http://wx1.sinaimg.cn/large/e0e01e43gy1g1bz8ahlkcj20id0bajtc.jpg" alt="image"></p><p>这里盗个图，这个图总结的挺好的！</p><p><img src="http://wx2.sinaimg.cn/large/e0e01e43gy1g1cozajzz3j22zf1e7u0x.jpg" alt="image"></p><h3 id="三种锁的优缺点比较"><a href="#三种锁的优缺点比较" class="headerlink" title="三种锁的优缺点比较"></a>三种锁的优缺点比较</h3><p><img src="http://ws1.sinaimg.cn/large/e0e01e43gy1g1bz9ltetvj20rw08j42l.jpg" alt="image"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>深入理解Java虚拟机<br><a href="https://blog.csdn.net/lkforce/article/details/81128115#%E4%B8%80%EF%BC%8C%E5%AF%B9%E8%B1%A1%E5%A4%B4" target="_blank" rel="noopener">Java的对象头和对象组成详解</a><br><a href="https://blog.csdn.net/liupeifeng3514/article/details/79111565" target="_blank" rel="noopener">JVM（三）JVM中对象的内存布局详解</a><br><a href="https://www.cnblogs.com/zhengbin/p/6490953.html" target="_blank" rel="noopener">JVM——深入分析对象的内存布局</a><br><a href="https://juejin.im/post/5b4eec7df265da0fa00a118f#heading-16" target="_blank" rel="noopener">啃碎并发（七）：深入分析Synchronized原理</a><br><a href="http://bigdatadecode.club/JavaSynchronizedTheory.html" target="_blank" rel="noopener">Java Synchronized实现原理</a>   </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://ws1.sinaimg.cn/large/e0e01e43gy1g1bza8l04cj21g80yte82.jpg&quot; alt=&quot;image&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class
      
    
    </summary>
    
      <category term="Java编程基础" scheme="http://ddnd.cn/categories/Java-Programming/"/>
    
    
      <category term="多线程" scheme="http://ddnd.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="synchronized" scheme="http://ddnd.cn/tags/synchronized/"/>
    
      <category term="JVM" scheme="http://ddnd.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>synchronized的使用（一）</title>
    <link href="http://ddnd.cn/2019/03/21/java-synchronized/"/>
    <id>http://ddnd.cn/2019/03/21/java-synchronized/</id>
    <published>2019-03-21T10:14:36.000Z</published>
    <updated>2019-03-22T08:14:42.588Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://wx3.sinaimg.cn/large/e0e01e43ly1g1ajyi7wlhj21g80yt1kx.jpg" alt="image" width="100%"></p><h2 id="多线程简介"><a href="#多线程简介" class="headerlink" title="多线程简介"></a>多线程简介</h2><p>在现代计算机中往往存在多个<code>CPU</code>核心，而<code>1</code>个<code>CPU</code>能同时运行一个线程，为了充分利用<code>CPU</code>多核心，提高<code>CPU</code>的效率，多线程就应时而生了。   </p><p>那么多线程就一定比单线程快吗？答案是不一定，因为多线程存在单线程没有的问题</p><ul><li><strong>上下文切换</strong>：线程从<strong>运行状态</strong>切换到<strong>阻塞状态</strong>或者<strong>等待状态</strong>的时候需要将线程的运行状态保存，线程从<strong>阻塞状态</strong>或者<strong>等待状态</strong>切换到<strong>运行状态</strong>的时候需要加载线程上次运行的状态。线程的运行状态从保存到再加载就是一次上下文切换，而上下文切换的开销是非常大的，而我们知道<code>CPU</code>给每个线程分配的时间片很短，通常是几十毫秒(ms)，那么线程的切换就会很频繁。</li><li><strong>死锁</strong>：死锁的一般场景是，线程<code>A</code>和线程<code>B</code>都在互相等待对方释放锁，死锁会造成系统不可用。</li><li><strong>资源限制的挑战</strong>：资源限制指计算机硬件资源或软件资源限制了多线程的运行速度，例如某个资源的下载速度是<code>1Mb/s</code>，资源的服务器带宽只有<code>2Mb/s</code>，那么开<code>10</code>个线程下载资源并不会将下载速度提升到<code>10Mb/s</code>。</li></ul><p>既然多线程存在这些问题，那么我们在开发的过程中有必要使用多线程吗？我们知道任何技术都有它存在的理由，总而言之就是多线程利大于弊，只要我们合理使用多线程就能达到事半功倍的效果。   </p><p>多线程的意思就是多个线程同时工作，那么多线程之间如何协同合作，这也就是我们需要解决的<strong>线程通信</strong>、<strong>线程同步</strong>问题</p><ul><li><strong>线程通信</strong>：线程通信指线程之间以何种机制来交换消息，线程之间的通信机制有两种：<strong>共享内存</strong>和<strong>消息传递</strong>。共享内存即线程通过对共享变量的读写而达到隐式通信，消息传递即线程通过发送消息给对方显示的进行通信。</li><li><strong>线程同步</strong>：线程同步指不同线程对同一个资源进行操作时候线程应该以什么顺序去操作，线程同步依赖于线程通信，以共享内存方式进行线程通信的线程同步是显式的，以消息传递方式进行线程通信的线程同步是隐式的。</li></ul><h2 id="synchronized简介"><a href="#synchronized简介" class="headerlink" title="synchronized简介"></a>synchronized简介</h2><p><code>synchronized</code>是Java的关键字，可用于同步实例方法、类方法(静态方法)、代码块</p><ul><li><strong>同步实例方法</strong>：当<code>synchronized</code>修饰实例方法的时候，同步的范围是当前实例的实例方法。</li><li><strong>同步类方法</strong>：当<code>synchronized</code>修饰类方法的时候，同步的范围是当前类的方法。</li><li><strong>同步代码块</strong>：当<code>synchronized</code>修饰代码块的时候，同步的范围是<code>()</code>中的对象。</li></ul><p><code>&quot;talk is cheap show me the code&quot;</code>让我们分别运行个例子来看看。</p><ol><li><strong>同步实例方法</strong>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">synchronized public void synSay() &#123;</span><br><span class="line">    System.out.println(&quot;synSay----&quot; + Thread.currentThread().getName());</span><br><span class="line">    while (true) &#123; //保证进入该方法的线程 一直占用着该同步方法</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void say() &#123;</span><br><span class="line">    System.out.println(&quot;say----&quot; + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    Test test1 = new Test();</span><br><span class="line">    Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            test1.synSay();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(3000);  //休眠3秒钟 保证线程t1先执行</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            test1.say();</span><br><span class="line">            test1.synSay();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>运行输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">synSay----Thread-0  //线程t1</span><br><span class="line">say----Thread-1  //线程t2</span><br></pre></td></tr></table></figure></p><p>创建<code>t1</code>，<code>t2</code>两个线程，分别执行同一个实例<code>test1</code>的方法，线程<code>t1</code>先执行加了同步关键字的<code>synSay</code>方法，注意方法里面需要加上个<code>while</code>死循环，目的是让线程一直在同步方法里面，然后然线程t1执行之后再让线程t2去执行，此时线程t2并不能成功进入到<code>synSay</code>方法里面，因为此时线程t1正在方法里面，线程2只能在<code>synSay</code>方法外面阻塞，但是线程t2可以进入到没有加同步关键字的<code>say</code>方法。<br>也就是说<strong>关键字<code>synchronized</code>修饰实例方法的时候，锁住的是该实例的加了同步关键字的方法，而没有加同步关键字的方法，线程还是可以正常访问的</strong>。但是不同实例之间同步是不会影响的，因为每个实例都有自己的一个锁，不同实例之间的锁是不一样的。</p><ol start="2"><li><strong>同步类方法</strong>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">synchronized static public void synSay() &#123;</span><br><span class="line">    System.out.println(&quot;static synSay----&quot; + Thread.currentThread().getName());</span><br><span class="line">    while (true) &#123; //保证进入该方法的线程 一直占用着该同步方法</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">synchronized public void synSay1() &#123;</span><br><span class="line">    System.out.println(&quot;synSay1----&quot; + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void say() &#123;</span><br><span class="line">    System.out.println(&quot;say----&quot; + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    Test test1 = new Test();</span><br><span class="line">    Test test2 = new Test();</span><br><span class="line">    Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            test1.synSay();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(3000);  //休眠3秒钟 保证线程t1先执行</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            test1.say();</span><br><span class="line">            test2.say();</span><br><span class="line">            test1.synSay();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>运行输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static synSay----Thread-0 //线程t1 实例test1</span><br><span class="line">say----Thread-1 //线程t2 实例test1</span><br><span class="line">say----Thread-1 //线程t2 实例test2</span><br><span class="line"></span><br><span class="line">static synSay----Thread-0 //线程t1 实例test1</span><br><span class="line">say----Thread-1  //线程t2 实例test1</span><br><span class="line">synSay1----Thread-1 //线程t2 实例test1</span><br><span class="line">say----Thread-1 //线程t2 实例test2</span><br></pre></td></tr></table></figure></p><p>这里和上面的同步实例方法的代码差不多，就是将<code>synSay</code>方法加上了<code>static</code>修饰符，即把方法从实例方法变成类方法了，然后我们再新建个实例<code>test2</code>，先让线程t1调用实例test1的synSay类方法，在让线程t2去调用实例test1的say实例方法、synSay类方法和让线程t2去调用实例test2的say实例方法，发现<strong>在线程t1占用加了同步关键字的<code>synSay</code>类方法的时候，别的线程是不能调用加了锁的类方法的，但是可以调用没有加同步关键字的方法或者加了同步关键字的实例方法</strong>，也就是说每个类有且仅有1<code>1</code>个锁，每个实例有且仅有<code>1</code>个锁，但是每个类可以有一个或者多个实例，类的锁和实例的锁不会相互影响，实例之间的锁也不会相互影响。<strong>需要注意的是，一个类和一个实例有且仅有一个锁，当这个锁被其他线程占用了，那么别的线程就无法获得锁，只有阻塞等待</strong>。</p><p><img src="http://wx3.sinaimg.cn/large/e0e01e43ly1g1ajxlcrxhj20sm0f9q49.jpg" alt="image"></p><ol start="3"><li><strong>同步代码块</strong>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    public void synSay() &#123;</span><br><span class="line">        String x = &quot;&quot;;</span><br><span class="line">        System.out.println(&quot;come in synSay----&quot; + Thread.currentThread().getName());</span><br><span class="line">        synchronized (x) &#123;</span><br><span class="line">            System.out.println(&quot;come in synchronized----&quot; + Thread.currentThread().getName());</span><br><span class="line">            while (true) &#123; //保证进入该方法的线程 一直占用着该同步方法</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">        Test test1 = new Test();</span><br><span class="line">        Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test1.synSay();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(3000);  //休眠3秒钟 保证线程t1先执行</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                test1.synSay();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>运行输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">come in synSay----Thread-0</span><br><span class="line">come in synchronized----Thread-0</span><br><span class="line">come in synSay----Thread-1</span><br></pre></td></tr></table></figure></p><p>可以发现同步代码块和同步实例方法、同步类方法其实差不多，但是同步代码块将同步的范围缩小了，可以同步到指定的对象上，而不像同步实例方法、同步类方法那样同步的是整个方法，所以<strong>同步代码块</strong>在效率上比其他两者都有较大的提升。<br>需要注意的是，当同步代码块的时候，在<strong>类方法</strong>中加入同步代码块且同步的对象是<code>xx.class</code>等类的引用的时候，同步的是该类，如果在<strong>**实例方法</strong>中加入同步代码块且同步的对象是<code>this</code>，那么同步的是该实例，可以看成前者使用的是<strong>类的锁</strong>，后者使用的是<strong>实例的锁</strong>。</p><h2 id="synchronized的特性"><a href="#synchronized的特性" class="headerlink" title="synchronized的特性"></a>synchronized的特性</h2><p>建议把<code>volatile</code>的特性和<code>synchronized</code>的特性进行对比学习，加深理解。<a href="https://ddnd.cn/2019/03/19/java-volatile/">《Java volatile关键字解析》</a></p><h3 id="synchronized与可见性"><a href="#synchronized与可见性" class="headerlink" title="synchronized与可见性"></a>synchronized与可见性</h3><p><code>JMM</code>关于<code>synchronized</code>的两条语义规定了：</p><ul><li>线程加锁前：需要将工作内存清空，从而保证了工作区的变量副本都是从主存中获取的最新值。</li><li>线程解锁前；需要将工作内存的变量副本写回到主存中。</li></ul><p>大概流程：<strong>清空线程的工作内存-&gt;在主存中拷贝变量副本到工作内存-&gt;执行完毕-&gt;将变量副本写回到主存中-&gt;释放锁</strong>。<br>所以<code>synchronized</code>能保证共享变量的<strong>可见性</strong>，而实现这个流程的原理也是通过插入内存屏障，和关键字<code>volatile</code>相似。</p><h3 id="synchronized与有序性"><a href="#synchronized与有序性" class="headerlink" title="synchronized与有序性"></a>synchronized与有序性</h3><p>因为<code>synchronized</code>是给共享变量加锁，即使用阻塞的同步机制，共享变量只能同时被一个线程操作，<strong>所以<code>JMM</code>不用像<code>volatile</code>那样考虑加内存屏障去保证<code>synchronized</code>多线程情况下的有序性，因为<code>CPU</code>在单线程情况下是保证了有序性的</strong>。<br>所以<code>synchronized</code>修饰的代码，是保证了有序性的。</p><h3 id="synchronized与原子性"><a href="#synchronized与原子性" class="headerlink" title="synchronized与原子性"></a>synchronized与原子性</h3><p>同样因为<code>synchronized</code>是给共享变量加锁了，以阻塞的机制去同步，在对共享变量进行读/写操作的时候是原子性的。<br>所以<code>synchronized</code>修饰的代码，是能保证原子性的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Java并发编程的艺术<br><a href="https://blog.csdn.net/guyuealian/article/details/52525724" target="_blank" rel="noopener">内存可见性和原子性：Synchronized和Volatile的比较</a><br><a href="https://langgufu.iteye.com/blog/2152608" target="_blank" rel="noopener">java synchronized类锁，对象锁详解（转载）</a>    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://wx3.sinaimg.cn/large/e0e01e43ly1g1ajyi7wlhj21g80yt1kx.jpg&quot; alt=&quot;image&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;多线程简介&quot;&gt;&lt;a href=&quot;#多线程简介&quot;
      
    
    </summary>
    
      <category term="Java编程基础" scheme="http://ddnd.cn/categories/Java-Programming/"/>
    
    
      <category term="多线程" scheme="http://ddnd.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="synchronized" scheme="http://ddnd.cn/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>Java volatile关键字解析</title>
    <link href="http://ddnd.cn/2019/03/19/java-volatile/"/>
    <id>http://ddnd.cn/2019/03/19/java-volatile/</id>
    <published>2019-03-19T07:21:09.000Z</published>
    <updated>2019-03-20T04:43:47.410Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ws2.sinaimg.cn/large/e0e01e43ly1g186ftl4a0j21g80yt4qt.jpg" alt="image" width="100%"></p><h2 id="volatile简介"><a href="#volatile简介" class="headerlink" title="volatile简介"></a>volatile简介</h2><p><code>volatile</code>被称为<strong>轻量级的synchronized</strong>，运行时开销比<code>synchronized</code>更小，在多线程并发编程中发挥着<strong>同步共享变量</strong>、<strong>禁止处理器重排序</strong>的重要作用。建议在学习<code>volatie</code>之前，先看一下Java内存模型<a href="https://ddnd.cn/2019/03/11/java-memory-model/">《什么是Java内存模型？》</a>，因为<code>volatile</code>和Java内存模型有着莫大的关系。</p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>在学习<code>volatie</code>之前，需要补充下Java内存模型的相关(JMM)知识，我们知道Java线程的所有操作都是在工作区进行的，那么工作区和主存之间的变量是怎么进行交互的呢，可以用下面的图来表示。</p><p><img src="http://wx3.sinaimg.cn/large/e0e01e43ly1g186enjfwfj20k80degmr.jpg" alt="image"><br>Java通过几种原子操作完成<strong>工作区内存</strong>和<strong>主存</strong>的交互</p><ol><li>lock：作用于主存，把变量标识为线程独占状态。</li><li>unlock：作用于主存，解除变量的独占状态。</li><li>read：作用于主存，把一个变量的值通过主存传输到线程的工作区内存。</li><li>load：作用于工作区内存，把<code>read</code>操作传过来的变量值储存到工作区内存的变量副本中。</li><li>use：作用于工作内存，把工作区内存的变量副本传给执行引擎。</li><li>assign：作用于工作区内存，把从执行引擎传过来的值赋值给工作区内存的变量副本。</li><li>store：作用于工作区内存，把工作区内存的变量副本传给主存。</li><li>write：作用于主存，把<code>store</code>操作传过来的值赋值给主存变量。</li></ol><p><strong>这<code>8</code>个操作每个操作都是原子性的，但是几个操作连着一起就不是原子性了！</strong></p><h2 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h2><p>上面介绍了Java模型的<code>8</code>个操作，那么这<code>8</code>个操作和<code>volatile</code>又有着什么关系呢。   </p><h3 id="volatile的可见性"><a href="#volatile的可见性" class="headerlink" title="volatile的可见性"></a>volatile的可见性</h3><p>什么是<strong>可见性</strong>，用一个例子来解释，先看一段代码，加入线程<code>1</code>先执行，线程<code>2</code>再执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//线程1</span><br><span class="line">boolean stop = false;</span><br><span class="line">while (!stop) &#123;</span><br><span class="line">    do();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">//线程2</span><br><span class="line">stop = true;</span><br></pre></td></tr></table></figure></p><p>线程<code>1</code>执行后会进入到一个死循环中，当线程<code>2</code>执行后，线程<code>1</code>的死循环就一定会马上结束吗？答案是不一定，因为线程<code>2</code>执行完<code>stop = true</code>后，并不会马上将变量<code>stop</code>的值<code>true</code>写回主存中，也就是上图中的<code>assign</code>执行完成之后，<code>store</code>和<code>write</code>并不会随着执行，<strong>线程<code>1</code>没有立即将修改后的变量的值更新到主存中</strong>，即使线程<code>2</code>及时将变量<code>stop</code>的值写回主存中了，<strong>线程<code>1</code>也没有了解到变量<code>stop</code>的值已被修改而去主存中重新获取</strong>，也就是线程<code>1</code>的<code>load</code>、<code>read</code>操作并不会马上执行造成线程<code>1</code>的工作区内存中的变量副本不是最新的。这两个原因造成了线程<code>1</code>的死循环也就不会马上结束。<br>那么如何避免上诉的问题呢？我们可以使用<code>volatile</code>关键字修饰变量<code>stop</code>，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//线程1</span><br><span class="line">volatile boolean stop = false;</span><br><span class="line">while (!stop) &#123;</span><br><span class="line">    do();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">//线程2</span><br><span class="line">stop = true;</span><br></pre></td></tr></table></figure></p><p>这样线程<code>1</code>每次读取变量<code>stop</code>的时候都会先去主存中获取变量<code>stop</code>最新的值，线程<code>2</code>每次修改变量<code>stop</code>的值之后都会马上将变量的值写回主存中，这样也就不会出现上述的问题了。    </p><p>那么关键字<code>volatie</code>是如何做到的呢？<code>volatie</code>规定了上述<code>8</code>个操作的规则</p><ol><li>只有当线程对变量执行的<strong>前一个操作</strong>是<code>load</code>时，线程才能对变量执行<code>use</code>操作；只有线程的后一个操作是<code>use</code>时，线程才能对变量执行<code>load</code>操作。即规定了<code>use</code>、<code>load</code>、<code>read</code>三个操作之间的约束关系，<strong>规定这三个操作必须连续的出现，保证了线程每次读取变量的值前都必须去主存获取最新的值</strong>。</li><li>只有当前程对变量执行的<strong>前一个操作</strong>是<code>assign</code>时，线程才能对变量执行<code>store</code>操作；只有线程的后一个操作是<code>store</code>时，线程才能对变量执行<code>assign</code>操作，即规定了<code>assign</code>、<code>store</code>、<code>write</code>三个操作之间的约束关系，<strong>规定了这三个操作必须连续的出现，保证线程每次修改变量后都必须将变量的值写回主存</strong>。</li></ol><p><code>volatile</code>的这两个规则，也正是保证了<strong>共享变量的可见性</strong>。</p><h3 id="volatile的有序性"><a href="#volatile的有序性" class="headerlink" title="volatile的有序性"></a>volatile的有序性</h3><p>有序性即程序执行的顺序按照代码的先后顺序执行，Java内存模型(JMM)允许编译器和处理器对指令进行重排序，但是规定了<code>as-if-serial</code>语义，即保证<strong>单线程</strong>情况下不管怎么重排序，程序的结果不能改变，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double pi = 3.14;  //A</span><br><span class="line">double r = 1;     //B</span><br><span class="line">double s = pi * r * r; //C</span><br></pre></td></tr></table></figure></p><p>上面的代码可能按照<code>A-&gt;B-&gt;C</code>顺序执行，也有可能按照<code>B-&gt;A-&gt;C</code>顺序执行，这两种顺序都不会影响程序的结果。但是不会以<code>C-&gt;A(B)-&gt;B(A)</code>的顺序去执行，因为<code>C</code>语句是依赖于<code>A</code>和<code>B</code>的，如果按照这样的顺序去执行就不能保证结果不变了(违背了<code>as-if-serial</code>)。    </p><p>上面介绍的是单线程的执行，不管指令怎么重排序都不会影响结果，但是在多线程下就会出现问题了。<br>下面看个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">double pi = 3.14;</span><br><span class="line">double r = 0;</span><br><span class="line">double s = 0;</span><br><span class="line">boolean start = false;</span><br><span class="line">//线程1</span><br><span class="line">r = 10; //A</span><br><span class="line">start = true; //B</span><br><span class="line"></span><br><span class="line">//线程2</span><br><span class="line">if (start) &#123;  //C</span><br><span class="line">    s = pi * r * r;  //D</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>线程<code>1</code>和线程<code>2</code>同时执行，线程<code>1</code>的<code>A</code>和<code>B</code>的执行顺序可能是<code>A-&gt;B</code>或者<code>B-&gt;A</code>(因为A和B之间没有依赖关系，可以指令重排序)。如果线程<code>1</code>按照<code>A-&gt;B</code>的顺序执行，那么线程<code>2</code>执行后的结果s就是我们想要的正确结果，如果线程<code>1</code>按照<code>B-&gt;A</code>的顺序执行，那么线程<code>2</code>执行后的结果s可能就不是我们想要的结果了，因为线程<code>1</code>将变量<code>stop</code>的值修改为<code>true</code>后，线程<code>2</code>马上获取到<code>stop</code>为<code>true</code>然后执行<code>C</code>语句，然后执行<code>D</code>语句即<code>s = 3.14 * 0 * 0</code>，然后线程<code>1</code>再执行<code>B</code>语句，那么结果就是有问题了。    </p><p>那么为了解决这个问题，我们可以在变量<code>true</code>加上关键字<code>volatile</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">double pi = 3.14;</span><br><span class="line">double r = 0;</span><br><span class="line">double s = 0;</span><br><span class="line">volatile boolean start = false;</span><br><span class="line">//线程1</span><br><span class="line">r = 10; //A</span><br><span class="line">start = true; //B</span><br><span class="line"></span><br><span class="line">//线程2</span><br><span class="line">if (start) &#123;  //C</span><br><span class="line">    s = pi * r * r;  //D</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样线程<code>1</code>的执行顺序就只能是<code>A-&gt;B</code>了，因为关键字<strong>发挥了禁止处理器指令重排序的作用</strong>，所以线程<code>2</code>的执行结果就不会有问题了。</p><p>那么<code>volatile</code>是怎么实现禁止处理器重排序的呢？<br><strong>编译器会在编译生成字节码的时候，在加有<code>volatile</code>关键字的变量的指令进行插入内存屏障来禁止特定类型的处理器重排序</strong><br>我们先看<strong>内存屏障</strong>有哪些及发挥的作用<br><img src="http://wx1.sinaimg.cn/large/e0e01e43ly1g191y6o3paj21620f5qd7.jpg" alt="image"></p><ol><li><code>StoreStore</code>屏障：禁止屏障上面变量的写和下面所有进行写的变量进行处理器重排序。</li><li><code>StoreLoad</code>屏障：禁止屏障上面变量的写和下面所有进行读的变量进行处理器重排序。</li><li><code>LoadLoad</code>屏障：禁止屏障上面变量的读和下面所有进行读的变量进行处理器重排序。</li><li><code>LoadStore</code>屏障：禁止屏障上面变量的读和下面所有进行写的变量进行处理器重排序。</li></ol><p>再看<code>volatile</code>是怎么插入屏障的</p><ol><li>在每个<code>volatile</code>变量的写<strong>前面</strong>插入一个<code>StoreStore</code>屏障。</li><li>在每个<code>volatile</code>变量的写<strong>后面</strong>插入一个<code>StoreLoad</code>屏障。</li><li>在每个<code>volatile</code>变量的读<strong>后面</strong>插入一个<code>LoadLoad</code>屏障。</li><li>在每个<code>volatile</code>变量的读<strong>后面</strong>插入一个<code>LoadStore</code>屏障。</li></ol><blockquote><p>注意：写操作是在<code>volatile</code><strong>前后</strong>插入一个内存屏障，而读操作是在<strong>后面</strong>插入两个内存屏障。</p></blockquote><p><img src="http://wx4.sinaimg.cn/large/e0e01e43ly1g186ext5z1j20h809vjsv.jpg" alt="image"></p><p><strong><code>volatile</code>变量通过插入内存屏障禁止了处理器重排序，从而解决了多线程环境下处理器重排序的问题</strong>。</p><h3 id="volatile有没有原子性？"><a href="#volatile有没有原子性？" class="headerlink" title="volatile有没有原子性？"></a>volatile有没有原子性？</h3><p>上面分别介绍了<code>volatile</code>的可见性和有序性，那么<code>volatile</code>有原子性吗？我们先看一段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public volatile int inc = 0;</span><br><span class="line">     </span><br><span class="line">    public void increase() &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们开启<code>10</code>个线程对<code>volatile</code>变量进行自增操作，每个线程对<code>volatile</code>变量执行<code>1000</code>次自增操作，那结果变量<code>inc</code>会是<code>10000</code>吗？答案是，变量<code>inc</code>的值基本都是小于<code>10000</code>。<br>可能你会有疑问，<code>volatile</code>变量<code>inc</code>不是保证了共享变量的可见性了吗，每次线程读取到的都是最新的值，是的没错，<strong>但是线程每次将值写回主存的时候并不能保证主存中的值没有被其他的线程修过过</strong>。</p><p><img src="http://ws1.sinaimg.cn/large/e0e01e43ly1g186f6g2hnj20ha09et9t.jpg" alt="image"></p><p>如果所示：线程<code>1</code>在主存中获取了<code>i</code>的最新值(i=1)，线程<code>2</code>也在主存中获取了<code>i</code>的最新值(i=1，注意这时候线程<code>1</code>并未对变量<code>i</code>进行修改，所以<code>i</code>的值还是<code>1</code>)），然后线程<code>2</code>将i自增后写回主存，这时候主存中<code>i=2</code>，到这里还没有问题，然后线程<code>1</code>又对i进行了自增写回了主存，这时候主存中<code>i=2</code>，也就是对i做了2次自增操作，结果i的结果只自增了1，问题就出来了这里。 </p><p>为什么会有这个问题呢，前面我们提到了Java内存模型和主存之间交互的<code>8</code>个操作都是原子性的，但是他们的操作连在一起就不是原子性了，而<code>volatile</code>关键字也只是保证了<code>use</code>、<code>load</code>、<code>read</code>三个操作连在一起时候的原子性，还有<code>assign</code>、<code>store</code>、<code>write</code>这三个操作连在一起时候的原子性，也就是<code>volatile</code>关键字<strong>保证了变量读操作的原子性和写操作的原子性，而变量的自增过程需要对变量进行读和写两个过程，而这两个过程连在一起就不是原子性操作了。</strong></p><p>所以说<code>volatile</code>变量对于变量的单独写操作/读操作是保证了原子性的，而常说的原子性包括读写操作连在一起，所以说对于<code>volatile</code>不保证原子性的。那么如何解决上面程序的问题呢？只能给<code>increase</code>方法加锁，让在多线程情况下只有一个线程能执行<code>increase</code>方法，也就是保证了一个线程对变量的读写是原子性的。<strong>当然还有个更优的方案，就是利用读写都为原子性的<code>CAS</code>，利用<code>CAS</code>对<code>volatile</code>进行操作，既解决了<code>volatile</code>不保证原子性的问题，同时消耗也没加锁的方式大</strong></p><h2 id="volatile和CAS"><a href="#volatile和CAS" class="headerlink" title="volatile和CAS"></a>volatile和CAS</h2><p>学完<code>volatile</code>之后，是不是觉得<code>volatile</code>和<code>CAS</code>有种似曾相识的感觉？那它们之间有什么关系或者区别呢。   </p><ol><li><code>volatile</code>只能保证共享变量的读和写操作单个操作的原子性，而<code>CAS</code>保证了共享变量的读和写两个操作一起的原子性(即CAS是原子性操作的)。</li><li><code>volatile</code>的实现基于<code>JMM</code>，而<code>CAS</code>的实现基于硬件。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">Java并发编程：volatile关键字解析</a><br><a href="https://www.javazhiyin.com/887.html" target="_blank" rel="noopener">JAVA并发六：彻底理解volatile</a><br><a href="https://jiangzhengjun.iteye.com/blog/652532" target="_blank" rel="noopener">Java内存模型与volatile</a><br><a href="http://www.techug.com/post/java-volatile-keyword.html" target="_blank" rel="noopener">Java面试官最爱问的volatile关键字</a>      </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://ws2.sinaimg.cn/large/e0e01e43ly1g186ftl4a0j21g80yt4qt.jpg&quot; alt=&quot;image&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;volatile简介&quot;&gt;&lt;a href=&quot;#v
      
    
    </summary>
    
      <category term="Java编程基础" scheme="http://ddnd.cn/categories/Java-Programming/"/>
    
    
      <category term="多线程" scheme="http://ddnd.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="volatile" scheme="http://ddnd.cn/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>一文带你快速掌握AQS</title>
    <link href="http://ddnd.cn/2019/03/15/java-abstractqueuedsynchronizer/"/>
    <id>http://ddnd.cn/2019/03/15/java-abstractqueuedsynchronizer/</id>
    <published>2019-03-15T13:53:03.000Z</published>
    <updated>2019-03-25T05:52:06.449Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ws1.sinaimg.cn/large/e0e01e43ly1g13rtsdq9xj21c61041ky.jpg" alt="image" width="100%"></p><h2 id="AbstractQueuedSynchronizer简介"><a href="#AbstractQueuedSynchronizer简介" class="headerlink" title="AbstractQueuedSynchronizer简介"></a>AbstractQueuedSynchronizer简介</h2><p><strong><code>AbstractQueuedSynchronizer</code>抽象队列同步器</strong>，简称为<code>AQS</code>，可用于构建<strong>阻塞锁</strong>或者其他相关<strong>同步器</strong>的基础框，是Java并发包的基础工具类。通过<code>AQS</code>这个框架可以对<strong>同步状态原子性管理、线程的阻塞和解除阻塞、队列的管理</strong>进行统一管理。<br><code>AQS</code>是抽象类，并不能直接实例化，当需要使用<code>AQS</code>的时候需要继承<code>AQS</code>抽象类并且重写指定的方法，这些重写方法包括<strong>线程获取资源和释放资源的方式</strong>(如ReentractLock通过分别重写线程获取和释放资源的方式实现了公平锁和非公平锁)，<strong>同时子类还需要负责共享变量state的维护，如当state为0时表示该锁没有被占，大于0时候代表该锁被一个或多个线程占领(重入锁)</strong>，而队列的维护(获取资源失败入队、线程唤醒、线程的状态等)不需要我们考虑，<code>AQS</code>已经帮我们实现好了。<code>AQS</code>的这种设计模式采用的正是<strong>模板方法模式</strong>。<br><strong>总结起来子类的任务有：</strong>   </p><ol><li>通过<code>CAS</code>操作维护共享变量<code>state</code>。</li><li>重写资源的获取方式。</li><li>重写资源释放的方式。<blockquote><p>如果对CAS和Java内存模型还不清楚的，建议先了解这两者之后再食用本文，效果更佳！<a href="https://ddnd.cn/2019/03/13/java-cas/">CAS原理分析及ABA问题详解</a>         <a href="https://ddnd.cn/2019/03/11/java-memory-model/">什么是Java内存模型？</a></p></blockquote></li></ol><p>完成以上三个任务即可实现自己的锁。<br><code>AQS</code>作为<code>J.U.C</code>的工具类，面向的是需要实现<strong>锁的实现者</strong>，而锁面向的是<strong>锁的使用者</strong>，这两者的区别还是需要搞清楚的。</p><h2 id="AQS数据结构"><a href="#AQS数据结构" class="headerlink" title="AQS数据结构"></a>AQS数据结构</h2><p>先看<code>AQS</code>有哪些重要的成员变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的</span><br><span class="line">private transient volatile Node head;</span><br><span class="line"></span><br><span class="line">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span><br><span class="line">private transient volatile Node tail;</span><br><span class="line"></span><br><span class="line">// 这个是最重要的，不过也是最简单的，代表当前锁的状态，0代表没有被占用，大于0代表有线程持有当前锁</span><br><span class="line">// 之所以说大于0，而不是等于1，是因为锁可以重入嘛，每次重入都加上1</span><br><span class="line">private volatile int state;</span><br><span class="line"></span><br><span class="line">// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入</span><br><span class="line">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span><br><span class="line">// if (currentThread == getExclusiveOwnerThread()) &#123;state++&#125;</span><br><span class="line">private transient Thread exclusiveOwnerThread; //继承自AbstractOwnableSynchronizer</span><br></pre></td></tr></table></figure></p><p>然后再看看<code>AQS</code>的内部结构，<code>AQS</code>内部数据结构为一个<strong>双向链表</strong>和一个<strong>单向链表</strong>，双链表为同步队列，队列中的每个节点对应一个<code>Node</code>内部类，<code>AQS</code>通过控制链表的节点而达到阻塞、同步的目的，单链表为条件队列，<strong>可以把同步队列和条件队列理解成储存等待状态的线程的队列</strong>，但是条件队列中的线程并不能直接去获取资源，而要先从条件队列转到同步队列中排队获取，同步队列的唤醒结果是线程去尝试获取锁，而条件队列的唤醒结果是把线程从条件队列移到同步队列中，一个线程要么是在同步队列中，要么是在条件队列中，不可能同时存在这两个队列里面。</p><p><img src="http://wx3.sinaimg.cn/large/e0e01e43ly1g13rma1mnmj20v207ngml.jpg" alt="image"></p><blockquote><p>Java<strong>阻塞状态</strong>和<strong>等待状态</strong>的线程从Linux内核来看，都是阻塞(等待)状态，它们都会让出CPU时间片。Java为了方便管理线程将“阻塞(等待)”状态细分成了阻塞状态和等待状态，这两个状态的区别<strong>在于由谁去唤醒</strong>，是操作系统还是其他线程。Java线程请求某一个资源失败的时候就会进入<strong>阻塞状态</strong>，处于阻塞态的线程会不断请求资源，一旦请求成功，就会进入就绪队列，等待执行。而当线程调用<code>wait</code>、<code>join</code>、<code>pack</code>函数时候会进入<strong>等待状态</strong>，需要其它线程显性的唤醒否则会无限期的处于等待状态。   </p></blockquote><p>Java线程6状态图：<br><img src="http://ws3.sinaimg.cn/large/e0e01e43ly1g13rmm2wtsj21ep0n4b29.jpg" alt="image"></p><p>内部类<code>Node</code>详解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line">    //代表当前节(线程)点是共享模式</span><br><span class="line">    static final Node SHARED = new Node();</span><br><span class="line">    //代表当前节点(线程)是独占模式</span><br><span class="line">    static final Node EXCLUSIVE = null;</span><br><span class="line">    //代表当前节点(线程)已被取消</span><br><span class="line">    static final int CANCELLED =  1;</span><br><span class="line">    //代表当前节点(线程)的后继节点需要被提醒唤醒</span><br><span class="line">    static final int SIGNAL    = -1;</span><br><span class="line">    //代表节点(线程)在 Condition queue中，等待某一条件</span><br><span class="line">    static final int CONDITION = -2;</span><br><span class="line">    //代表当前节点的后继节点(线程)会传传播唤醒的操作，仅在共享模式下才有作用</span><br><span class="line">    static final int PROPAGATE = -3;</span><br><span class="line">    //代表当前节点的状态，它的取值除了以上说的CANCELLED、SIGNAL、CONDITION、PROPAGATE，同时</span><br><span class="line">    //还可能为0，为0的时候代表当前节点在sync队列中，阻塞着排队获取锁。</span><br><span class="line">    volatile int waitStatus;</span><br><span class="line">    //当前节点的前驱节点</span><br><span class="line">    volatile Node prev;</span><br><span class="line">    //当前节点的后继节点</span><br><span class="line">    volatile Node next;</span><br><span class="line">    //当前节点关联的线程</span><br><span class="line">    volatile Thread thread;</span><br><span class="line">    //在condition队列中的后继节点</span><br><span class="line">    Node nextWaiter;</span><br><span class="line">    </span><br><span class="line">    //判断当前节点是否为共享模式</span><br><span class="line">    final boolean isShared() &#123;</span><br><span class="line">        return nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //返回当前节点的前驱节点 没有前驱节点则抛出异常</span><br><span class="line">    final Node predecessor() throws NullPointerException &#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        if (p == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        else</span><br><span class="line">            return p;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每个线程都关联一个节点，节点的状态也代表着线程的状态，<code>AQS</code>通过对同步队列的管理而达到对线程的管理。</p><h2 id="AQS的功能"><a href="#AQS的功能" class="headerlink" title="AQS的功能"></a>AQS的功能</h2><p><code>AQS</code>提供了<code>2</code>大功能，基于双链表的同步队列和基于单链表的条件队列，同步队列维护的是<strong>阻塞状态的线程对应的节点</strong>，这些线程都是阻塞着排队获取锁的，条件队列维护的是<strong>等待状态的线程对应的节点</strong>。</p><h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p><code>AQS</code>提供了两种方式去获取资源，分别是<strong>共享模式</strong>和<strong>独占模式</strong>，但是一般锁只会去继承其中一种模式，不会在一个锁里同时存在<strong>共享模式</strong>和<strong>独占模式</strong>两种模式。     </p><blockquote><p>资源指锁、IO、Socket等</p></blockquote><p>当一个线程以共享模式或独占模式去获取资源的时候，如果获取失败则将该线程封装成<code>Node</code>节点(同时将该节点标识为共享模式或独占模式)<strong>加入到同步队列的尾部</strong>，<code>AQS</code>实时维护着这个同步队列，这个队列以<strong>FIFO(先进先出)来管理节点的排队</strong>，即资源的转移(获取再释放)的顺序是从头结点开始到尾节点。<br><img src="http://ws1.sinaimg.cn/large/e0e01e43ly1g13rmuy8ikj20rm071js5.jpg" alt="image"></p><p>共享模式和独占模式去获取、释放资源都分别对应着一套<code>API</code>，以下分别分析这两套<code>API</code></p><blockquote><p>独占模式即获取资源的<strong>排他锁</strong>，共享模式及获取资源的<strong>共享锁</strong>。</p></blockquote><h4 id="独占模式"><a href="#独占模式" class="headerlink" title="独占模式"></a>独占模式</h4><p>独占模式即一个线程获取到资源后，其他线程不能再对资源进行任何操作，只能阻塞获得资源。</p><h5 id="获取资源"><a href="#获取资源" class="headerlink" title="获取资源"></a>获取资源</h5><ol><li>线程调用子类重写的<code>tryAcquire</code>方法获取资源，如果获取成功，则流程结束，否则继续往下执行。</li><li>调用<code>addWaiter</code>方法(详细过程看下面的源码解析)，将该线<strong>程封装成Node节点</strong>，并添加到队列<strong>队尾</strong>。</li><li>调用<code>acquireQueued</code>方法让节点以”死循环”方式进行获取资源，为什么死循环加了双引号呢？因为循环并不是一直让节点无间断的去获取资源，节点会经历 获取资源-&gt;失败-&gt;线程进入等待状态-&gt;唤醒-&gt;获取资源……，<strong>线程在死循环的过程会不断等待和唤醒</strong>，节点进入到自旋状态(详细过程看下面的源码解析)，<strong>再循环过程中还会将标识为取消的前驱节点移除队列，同时标识前驱节点状态为SIGNAL</strong>。</li><li>线程的等待状态是通过调用<code>LockSupport.lock()</code>方法实现的，这个方法会响应<code>Thread.interrupt</code>，但是不会抛出InterruptedException异常，这点与<code>Thread.sleep</code>、<code>Thread.wait</code>不一样。</li></ol><p><img src="http://ws4.sinaimg.cn/large/e0e01e43ly1g13rn1r0hjj20wc10fgps.jpg" alt="image"></p><p><img src="http://wx2.sinaimg.cn/large/e0e01e43ly1g13rn6zuazj20s709j3zt.jpg" alt="image"></p><p><strong>可以看到节点和节点之间在自旋过程中除了前驱节点会唤醒该节点之外基本不会互相通讯</strong></p><p><strong>源码分析</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    //该线程调用tryAcquire方法尝试以独占模式获取资源，如果获取失败，则调</span><br><span class="line">    //用addWaiter函数，将线程封装到Node节点中，然后再将Node节点加入到同</span><br><span class="line">    //步队列的尾部，然后再调用acquireQueued让线程进入到阻塞状态，如果获</span><br><span class="line">    //取成功则返回true，然后调用selfInterrupt</span><br><span class="line">    //函数。</span><br><span class="line">    //注意的是，tryAcquire函数就是继承AQS的子类所需要去重写的方法。</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE),arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//AQS的tryAcquire函数并没有获取资源的相关实现，需要继承`AQS`的子类去</span><br><span class="line">//重写这个方法。</span><br><span class="line">protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    Node node = new Node(Thread.currentThread(), mode);</span><br><span class="line">    // Try the fast path of enq; backup to full enq on failure</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    //创建新的节点，并将线程和节点关联。</span><br><span class="line">    //将同步队列的尾节点后继节点指向新节点，</span><br><span class="line">    //将新节点的前驱节点指向尾节点，</span><br><span class="line">    //新节点称为同步队列的尾节点。</span><br><span class="line">    if (pred != null) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        //CAS操作将新节点插入到，成功则返回，不成功则继续下面的enq方法，</span><br><span class="line">        //进行死循环CAS插入，直到成功。</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果上面的CAS操作插入不成功，则调用enq方法 死循环插入 直到成功。</span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    //死循环 直到插入成功。</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        //如果尾节点为null，说明同步队列还未初始化，则CAS操作新建头节点</span><br><span class="line">        if (t == null) &#123; // Must initialize</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //通过CAS操作将节点插入到同步队列尾部</span><br><span class="line">            node.prev = t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//节点以“死循环”的方式去获取资源，为什么死循环加了双引号呢？因为循环并不</span><br><span class="line">//是一直让节点无间断的去获取资源，节点会经历 获取资源-&gt;失败-&gt;线程进入等待</span><br><span class="line">//状态-&gt;唤醒-&gt;获取资源......，线程在死循环的过程会不断等待和唤醒，即节点的自旋。</span><br><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            //获取节点的前驱节点</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            //如果前驱节点为头结点，表示资源正在前驱节点的手上，那该节点</span><br><span class="line">            //去尝试获取资源，如果获取成功则将该节点设置为头结点，并且</span><br><span class="line">            //返回。</span><br><span class="line">            //如果该节点的前驱节点并不是头节点或者是前驱节点是头结点但是</span><br><span class="line">            //该节点获取资源失败，继续往下执行。</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = null; // help GC</span><br><span class="line">                failed = false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            //调用shouldParkAfterFailedAcquire函数，将该节点的前驱节点</span><br><span class="line">            //的状态设置为SIGNAL，告诉前驱节点我要去“睡觉”了，当资源排</span><br><span class="line">            //到你的时候，你就通知我一下让我醒来，即节点做进入等待状态</span><br><span class="line">            //的准备。</span><br><span class="line">            //当节点做好了进入等待状态的准备，则调用parkAndCheckInterrupt</span><br><span class="line">            //函数，让该节点进入到等待状态。</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    //获取前驱节点的状态。</span><br><span class="line">    int ws = pred.waitStatus;</span><br><span class="line">    //如果前驱节点的状态已经为SIGNAL了，即已经做好准备了，那直接返回。</span><br><span class="line">    if (ws == Node.SIGNAL)</span><br><span class="line">        /*</span><br><span class="line">         * This node has already set status asking a release</span><br><span class="line">         * to signal it, so it can safely park.</span><br><span class="line">         */</span><br><span class="line">        return true;</span><br><span class="line">    //如果前驱节点的状态为取消状态，则将前驱节点移除队列，循环这个过程</span><br><span class="line">    //直到前驱节点不为取消状态为止。</span><br><span class="line">    if (ws &gt; 0) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">         * indicate retry.</span><br><span class="line">         */</span><br><span class="line">        do &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    //如果前驱节点没有做好准备(标志状态为SIGNAL)、前驱节点也没有被取消，</span><br><span class="line">    //则使用CAS操作将前驱节点的状态更新为SIGNAL，然后返回false，为什么</span><br><span class="line">    //是返回false呢？因为CAS操作并不保证一定能更新成功，返回false的目的</span><br><span class="line">    //是让acquireQueued函数再执行一次for循环，这个循环第一可以让该节点</span><br><span class="line">    //再尝试获取资源(万一成功了呢 是吧)，第二是让acquireQueued函数再调用</span><br><span class="line">    //一次shouldParkAfterFailedAcquire函数(即本函数)判断节点的前驱节点是</span><br><span class="line">    //否已经设置为SIGNAL状态了。</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /*</span><br><span class="line">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="line">         * need a signal, but don&apos;t park yet.  Caller will need to</span><br><span class="line">         * retry to make sure it cannot acquire before parking.</span><br><span class="line">         */</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用LockSupport.park函数将该线程设置为等待状态</span><br><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    LockSupport.park(this);</span><br><span class="line">    //注意LockSupport遇到Thread.interrupt是会立刻返回的，但是不会抛出异常InterruptedExcept</span><br><span class="line">    //ion，这个需要注意和Thread.wait，Thread.sleep的区别，</span><br><span class="line">    //唤醒的时候 会返回该线程是否为中断唤醒的。</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h5><ol><li>线程调用子类重写的<code>tryRelease</code>方法进行释放资源，如果释放成功则继续检查线程(节点)的是否有后继节点，有后继几点则去<strong>唤醒</strong>。</li><li>调用<code>unparkSuccessor</code>方法进行后继节点的唤醒，<strong>如果后继节点为取消状态，则从队列的队尾往前遍历，找到一个离节点最近且不为取消状态的节点进行唤醒，如果后继节点不为取消状态则直接唤醒</strong>。</li></ol><p><img src="http://ws3.sinaimg.cn/large/e0e01e43ly1g13rne0t7dj20qh0pkjt8.jpg" alt="image"><br><strong>源码解析</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    //线程调用tryRelease方法尝试释放资源，如果释放成功则检查该节点是否有后继节点，有的话则</span><br><span class="line">    //调用unpacrkSuccessor()方法去唤醒后继节点。</span><br><span class="line">    //注意的是，tryRelease函数就是继承AQS的子类所需要去重写的方法。</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        //头结点(即释放资源的节点)不为空，头结点的状态不为0，代表有后继节点，需要唤醒。</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    /*</span><br><span class="line">     * If status is negative (i.e., possibly needing signal) try</span><br><span class="line">     * to clear in anticipation of signalling.  It is OK if this</span><br><span class="line">     * fails or if status is changed by waiting thread.</span><br><span class="line">     */</span><br><span class="line">    //获取头结点状态。</span><br><span class="line">    int ws = node.waitStatus;</span><br><span class="line">    //如果状态小于0，即代表有后继节点需要唤醒。</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        //将头结点的状态置为0 因为只需要唤醒一次</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Thread to unpark is held in successor, which is normally</span><br><span class="line">     * just the next node.  But if cancelled or apparently null,</span><br><span class="line">     * traverse backwards from tail to find the actual</span><br><span class="line">     * non-cancelled successor.</span><br><span class="line">     */</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    //如果头结点的后继节点为空 或者 头结点的后继节点处于取消状态，则从尾部开始往前寻找，</span><br><span class="line">    //找到一个离头结点最近 且状态不是取消状态的节点。</span><br><span class="line">    if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s = null;</span><br><span class="line">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            if (t.waitStatus &lt;= 0)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果头结点的后继节点不为取消状态，则直接将后继节点唤醒</span><br><span class="line">    if (s != null)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="共享模式"><a href="#共享模式" class="headerlink" title="共享模式"></a>共享模式</h4><p>共享模式下，线程无论是<strong>获取资源还是释放资源，都可能会唤醒后继节点</strong>。</p><h5 id="获取资源-1"><a href="#获取资源-1" class="headerlink" title="获取资源"></a>获取资源</h5><ol><li>调用子类重写的<code>tryAcquireShared</code>方法进行资源获取，获取失败则调用<code>doAcquireShared</code>将<strong>线程封装Node节点加入到同步队列队尾</strong>。</li><li>调用<code>doAcquireShared</code>方法让节点以”死循环”方式进行获取资源，为什么死循环加了双引号呢？因为循环并不是一直让节点无间断的去获取资源，节点会经历获取资源-&gt;失败-&gt;线程进入等待状态-&gt;唤醒-&gt;获取资源……，线程在死循环的过程会不断等待和唤醒，节点进入到自旋状态(详细过程看下面的源码解析)。<strong>如果线程节点被唤醒后，且获取资源成功，且后继节点为共享模式，那么会唤醒后继节点……唤醒会一直传递下去，直到后继节点不是共享模式，唤醒的节点同样会去获取资源</strong>，这点和独占模式不一样。</li></ol><p><img src="http://ws2.sinaimg.cn/large/e0e01e43ly1g13rnoe29bj213i10f0xf.jpg" alt="image"></p><p><img src="http://wx2.sinaimg.cn/large/e0e01e43ly1g13rntqlntj20yw0a9acj.jpg" alt="image"><br><strong>共享模式资源的获取和独占模式资源的获取流程差不多，就是在获取资源成功后，会唤醒为共享模式的后继节点，然后被唤醒的后继节点也去获取资源</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    //和独占模式的一样，同样是调用子类重写的tryAcquireShared方法以共享模式进行资源获取。</span><br><span class="line">    //如果获取失败，则调用doAcquireShared方法将线程封装成Node节点加入到同步队列的队尾，</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected int tryAcquireShared(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">    //将线程封装到节点中，且将节点加入到队尾中。</span><br><span class="line">    final Node node = addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            //获取线程(节点)的前驱节点。</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            //如果前驱节点为头结点，则该线程尝试获取资源。</span><br><span class="line">            if (p == head) &#123;</span><br><span class="line">                //获取资源。</span><br><span class="line">                int r = tryAcquireShared(arg);</span><br><span class="line">                //获取资源成功则将节点设为头结点。</span><br><span class="line">                if (r &gt;= 0) &#123;</span><br><span class="line">                    //获取成功 对后继SHARED节点持续唤醒</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    if (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //和独占模式的一样。</span><br><span class="line">            //调用shouldParkAfterFailedAcquire函数，将该节点的前驱节点</span><br><span class="line">            //的状态设置为SIGNAL，告诉前驱节点我要去“睡觉”了，当资源排</span><br><span class="line">            //到你的时候，你就通知我一下让我醒来，即节点做进入等待状态的准备。</span><br><span class="line">            //当节点做好了进入等待状态的准备，则调用parkAndCheckInterrupt</span><br><span class="line">            //函数，让该节点进入到等待状态。            </span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">    Node h = head; // Record old head for check below</span><br><span class="line">    setHead(node);</span><br><span class="line">    /*</span><br><span class="line">     * Try to signal next queued node if:</span><br><span class="line">     *   Propagation was indicated by caller,</span><br><span class="line">     *     or was recorded (as h.waitStatus either before</span><br><span class="line">     *     or after setHead) by a previous operation</span><br><span class="line">     *     (note: this uses sign-check of waitStatus because</span><br><span class="line">     *      PROPAGATE status may transition to SIGNAL.)</span><br><span class="line">     * and</span><br><span class="line">     *   The next node is waiting in shared mode,</span><br><span class="line">     *     or we don&apos;t know, because it appears null</span><br><span class="line">     *</span><br><span class="line">     * The conservatism in both of these checks may cause</span><br><span class="line">     * unnecessary wake-ups, but only when there are multiple</span><br><span class="line">     * racing acquires/releases, so most need signals now or soon</span><br><span class="line">     * anyway.</span><br><span class="line">     */</span><br><span class="line">    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||</span><br><span class="line">        (h = head) == null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        //如果节点为共享节点，则调用doReleaseShared函数唤醒后继节点。</span><br><span class="line">        if (s == null || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="释放资源-1"><a href="#释放资源-1" class="headerlink" title="释放资源"></a>释放资源</h5><ol><li>调用子类重写的<code>tryReleaseShared</code>方法释放资源，释放成功则调用<code>doReleaseShared</code>方法进行后继节点的唤醒。</li><li>如果后继节点为共享模式，则持续唤醒。</li></ol><p><img src="http://ws2.sinaimg.cn/large/e0e01e43ly1g13ro03soyj21601cx0yr.jpg" alt="image"></p><p><strong>共享模式下资源释放流程和独占模式下资源释放的流程差不多，就是在释放后唤醒后继为共享模式的节点，且唤醒的动作是传播下去的，直到后继节点出现不是共享模式的，这个唤醒的过程和共享模式的获取资源的唤醒过程一样。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//调用子类重写的tryReleaseShared方法进行以共享模式释放资源，释放失败则调用doReleaseShared。</span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected boolean tryReleaseShared(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">    /*</span><br><span class="line">     * Ensure that a release propagates, even if there are other</span><br><span class="line">     * in-progress acquires/releases.  This proceeds in the usual</span><br><span class="line">     * way of trying to unparkSuccessor of head if it needs</span><br><span class="line">     * signal. But if it does not, status is set to PROPAGATE to</span><br><span class="line">     * ensure that upon release, propagation continues.</span><br><span class="line">     * Additionally, we must loop in case a new node is added</span><br><span class="line">     * while we are doing this. Also, unlike other uses of</span><br><span class="line">     * unparkSuccessor, we need to know if CAS to reset status</span><br><span class="line">     * fails, if so rechecking.</span><br><span class="line">     */</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h != tail) &#123;</span><br><span class="line">            int ws = h.waitStatus;</span><br><span class="line">            //如果节点标识后继节点需要唤醒，则调用unparkSuccessor方法进行唤醒。</span><br><span class="line">            if (ws == Node.SIGNAL) &#123;</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            // loop to recheck cases</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ws == 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                // loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        if (h == head)                   // loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件队列"><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h3><p>条件队列又称等待队列、条件队列等，条件队列的实现是通过<code>ConditionObject</code>的内之类来完成的，，一开始就介绍了同步队列条件队列的去，不过这里再啰嗦一下，<strong>可以把同步队和条件队列理解成储存等待状态的线程的队列</strong>，条件队列中的线程并不能直接去获取资源，而要先从条件队列转到同步队列中排队获取，一个线程要么是在同步队列中，要么是在条件队列中，不可能同时存在这两个队列里面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * 使当前线程进入等待状态，直到以下4种情况任意一个发生：</span><br><span class="line"> * 1.另一个线程调用该对象的signal()，当前线程恰好是被选中的唤醒线程</span><br><span class="line"> * 2.另一个线程调用该对象的signalAll()</span><br><span class="line"> * 3.另一个线程interrupt当前线程（此时会抛出InterruptedException）</span><br><span class="line"> * 4.虚假唤醒（源自操作系统，发生概率低）</span><br><span class="line"> * ConditionObject要求调用时该线程已经拿到了其外部AQS类的排它锁（acquire成功）</span><br><span class="line"> */</span><br><span class="line">void await() throws InterruptedException;</span><br><span class="line">/* </span><br><span class="line"> * 与await()相同，但是不会被interrupt唤醒</span><br><span class="line"> */</span><br><span class="line">void awaitUninterruptibly();</span><br><span class="line">/* </span><br><span class="line"> * 与await()相同，增加了超时时间，超过超时时间也会停止等待</span><br><span class="line"> * 三个方法功能相似，其返回值代表剩余的超时时间，或是否超时</span><br><span class="line"> */</span><br><span class="line">long awaitNanos(long nanosTimeout) throws InterruptedException;</span><br><span class="line">boolean await(long time, TimeUnit unit) throws InterruptedException;</span><br><span class="line">boolean awaitUntil(Date deadline) throws InterruptedException;</span><br><span class="line">/* </span><br><span class="line"> * 唤醒一个正在等待该条件变量对象的线程</span><br><span class="line"> * ConditionObject会选择等待时间最长的线程来唤醒</span><br><span class="line"> * ConditionObject要求调用时该线程已经拿到了其外部AQS类的排它锁（acquire成功）</span><br><span class="line"> */</span><br><span class="line">void signal();</span><br><span class="line">/* </span><br><span class="line"> * 唤醒所有正在等待该条件变量对象的线程</span><br><span class="line"> * ConditionObject要求调用时该线程已经拿到了其外部AQS类的排它锁（acquire成功）</span><br><span class="line"> */</span><br><span class="line">void signalAll();</span><br></pre></td></tr></table></figure></p><p>可以看到，其作用与Object原生的wait()/notify()/notifyAll()很相似，但是增加了更多的功能。下面以awaitUninterruptibly()、signal()为例，阐述一下其内部实现。<br><img src="http://wx4.sinaimg.cn/large/e0e01e43ly1g13rodrehcj20md0hajy9.jpg" alt="image"></p><h3 id="同步队列和条件队列的关系"><a href="#同步队列和条件队列的关系" class="headerlink" title="同步队列和条件队列的关系"></a>同步队列和条件队列的关系</h3><p>线程执行<code>condition.await()</code>方法，将节点1从同步队列转移到条件队列中。</p><p><img src="http://ws2.sinaimg.cn/large/e0e01e43gy1g1ezqs6cccj20xm079aba.jpg" alt="image"></p><p>线程执行<code>condition.signal()</code>方法，将节点1从条件队列中转移到同步队列。<br><img src="http://ws2.sinaimg.cn/large/e0e01e43gy1g1ezr0ia5zj20xt067gmn.jpg" alt="image"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.fanyilun.me/2016/06/13/%E7%AE%80%E8%BF%B0AbstractQueuedSynchronizer/#2-3-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">简述AbstractQueuedSynchronizer</a><br><a href="https://javadoop.com/post/AbstractQueuedSynchronizer" target="_blank" rel="noopener">一行一行源码分析清楚AbstractQueuedSynchronizer</a><br><a href="http://zhanjindong.com/2015/03/15/java-concurrent-package-aqs-AbstractQueuedSynchronizer" target="_blank" rel="noopener">Java并发包源码学习之AQS框架（四）AbstractQueuedSynchronizer源码分析</a><br><a href="http://blog.zhangjikai.com/2017/04/15/%E3%80%90Java-%E5%B9%B6%E5%8F%91%E3%80%91%E8%AF%A6%E8%A7%A3-AbstractQueuedSynchronizer/" target="_blank" rel="noopener">【Java并发】详解 AbstractQueuedSynchronizer</a><br><a href="http://ifeve.com/introduce-abstractqueuedsynchronizer/" target="_blank" rel="noopener">AbstractQueuedSynchronizer的介绍和原理分析</a>     </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://ws1.sinaimg.cn/large/e0e01e43ly1g13rtsdq9xj21c61041ky.jpg&quot; alt=&quot;image&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;AbstractQueuedSynchroni
      
    
    </summary>
    
      <category term="Java编程基础" scheme="http://ddnd.cn/categories/Java-Programming/"/>
    
    
      <category term="多线程" scheme="http://ddnd.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="AQS" scheme="http://ddnd.cn/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>CAS原理分析及ABA问题详解</title>
    <link href="http://ddnd.cn/2019/03/13/java-cas/"/>
    <id>http://ddnd.cn/2019/03/13/java-cas/</id>
    <published>2019-03-13T09:09:33.000Z</published>
    <updated>2019-03-20T04:37:04.357Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><img src="http://ws2.sinaimg.cn/large/e0e01e43ly1g11dcysv30j20t60jh1kx.jpg" alt="image" width="100%"></p><h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><p><code>CAS</code>即<code>Compare And Swap</code>的缩写，翻译成中文就是<strong>比较并交换</strong>，其作用是让CPU比较内存中某个值是否和预期的值相同，如果相同则将这个值更新为新值，不相同则不做更新，也就是CAS是<strong>原子性</strong>的操作(读和写两者同时具有原子性)，其实现方式是通过借助<code>C/C++</code>调用CPU指令完成的，所以效率很高。<br><code>CAS</code>的原理很简单，这里使用一段<code>Java</code>代码来描述<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public boolean compareAndSwap(int value, int expect, int update) &#123;</span><br><span class="line">//        如果内存中的值value和期望值expect一样 则将值更新为新值update</span><br><span class="line">    if (value == expect) &#123;</span><br><span class="line">        value = update;</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>大致过程是将内存中的值、我们的期望值、新值交给CPU进行运算，如果内存中的值和我们的期望值相同则将值更新为新值，否则不做任何操作。这个过程是在CPU中完成的，这里不好描述CPU的工作过程，就拿Java代码来描述了。    </p><h2 id="Unsafe源码分析"><a href="#Unsafe源码分析" class="headerlink" title="Unsafe源码分析"></a>Unsafe源码分析</h2><p>Java是在<code>Unsafe(sun.misc.Unsafe)</code>类实现<code>CAS</code>的操作，而我们知道Java是无法直接访问操作系统底层的API的(原因是Java的跨平台性限制了Java不能和操作系统耦合)，所以Java并没有在<code>Unsafe</code>类直接实现<code>CAS</code>的操作，而是通过<strong>JDI(Java Native Interface)</strong>本地调用<code>C/C++</code>语言来实现<code>CAS</code>操作的。<br><code>Unsafe</code>有很多个<code>CAS</code>操作的相关方法，这里举例几个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);</span><br><span class="line"></span><br><span class="line">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</span><br><span class="line"></span><br><span class="line">public final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6);</span><br></pre></td></tr></table></figure></p><p>我们拿<code>public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</code>进行分析，这个方法是比较内存中的一个值(整型)和我们的期望值(var4)是否一样，如果一样则将内存中的这个值更新为<code>var5</code>，参数中的<code>var1</code>是值所在的对象，<code>var2</code>是值在对象(var1)中的内存偏移量，<strong>参数var1和参数var2是为了定位出值所在内存的地址</strong>。<br><img src="http://wx3.sinaimg.cn/large/e0e01e43ly1g11dbvrjwoj21ay0bujtl.jpg" alt="image"><br><strong>Unsafe.java在这里发挥的作用有：</strong></p><ol><li>将对象引用、值在对象中的偏移量、期望的值和欲更新的新值传递给<code>Unsafe.cpp</code></li><li>如果值更新成功则返回<code>true</code>给开发者，没有更新则返回<code>false</code></li></ol><p><strong>Unsafe.cpp在这里发挥的作用有：</strong></p><ol><li>接受从<code>Unsafe</code>传递过来的对象引用、偏移量、期望的值和欲更新的新值，根据对象引用和偏移量<strong>计算出值的地址</strong>，然后将值的地址、期望的值、欲更新的新值传递给CPU</li><li>如果值更新成功则返回<code>true</code>给<code>Unsafe.java</code>，没有更新则返回<code>false</code></li></ol><p><strong>CPU在这里发挥的作用：</strong></p><ol><li>接受从<code>Unsafe.cpp</code>传递过来的地址、期望的值和欲更新的新值，执行指令<code>cmpxchg</code>，比较地址中的值是否和期望的值一样，一样则将值更新为新的值，不一样则不做任何操作</li><li>将操作结果返回给<code>Unsafe.cpp</code></li></ol><h2 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h2><p><code>CAS</code>虽然高效的实现了原子性操作，但是也存在一些缺点，主要表现在以下三个方面。</p><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>在多线程场景下<code>CAS</code>会出现<code>ABA</code>问题，关于ABA问题这里简单科普下，例如有2个线程同时对同一个值(初始值为A)进行CAS操作，这三个线程如下    </p><ol><li>线程1，期望值为A，欲更新的值为B</li><li>线程2，期望值为A，欲更新的值为B</li></ol><p>线程<code>1</code>抢先获得CPU时间片，而线程<code>2</code>因为其他原因阻塞了，线程<code>1</code>取值与期望的A值比较，发现相等然后将值更新为B，然后这个时候<strong>出现了线程<code>3</code>，期望值为B，欲更新的值为A</strong>，线程3取值与期望的值B比较，发现相等则将值更新为A，此时线程<code>2</code>从阻塞中恢复，并且获得了CPU时间片，这时候线程<code>2</code>取值与期望的值A比较，发现相等则将值更新为B，虽然线程<code>2</code>也完成了操作，但是线程<code>2</code>并不知道值已经经过了<code>A-&gt;B-&gt;A</code>的变化过程。   </p><p><strong><code>ABA</code>问题带来的危害</strong>：<br>小明在提款机，提取了50元，因为提款机问题，有两个线程，同时把余额从100变为50<br>线程1（提款机）：获取当前值100，期望更新为50，<br>线程2（提款机）：获取当前值100，期望更新为50，<br>线程1成功执行，线程2某种原因block了，这时，某人给小明汇款50<br>线程3（默认）：获取当前值50，期望更新为100，<br>这时候线程3成功执行，余额变为100，<br>线程2从Block中恢复，获取到的也是100，compare之后，继续更新余额为50！！！<br>此时可以看到，实际余额应该为100（100-50+50），但是实际上变为了50（100-50+50-50）这就是ABA问题带来的成功提交。</p><p><strong>解决方法</strong>：<br>在变量前面加上版本号，每次变量更新的时候变量的<strong>版本号都<code>+1</code></strong>，即<code>A-&gt;B-&gt;A</code>就变成了<code>1A-&gt;2B-&gt;3A</code>。</p><h3 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h3><p>如果<code>CAS</code>操作失败，就需要循环进行<code>CAS</code>操作(循环同时将期望值更新为最新的)，如果长时间都不成功的话，那么会造成CPU极大的开销。</p><blockquote><p>这种循环也称为自旋</p></blockquote><p><strong>解决方法</strong>：<br>限制自旋次数，防止进入死循环。</p><h3 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h3><p><code>CAS</code>的原子操作只能针对一个共享变量。</p><p><strong>解决方法</strong>：<br>如果需要对多个共享变量进行操作，可以使用加锁方式(悲观锁)保证原子性，或者可以把多个共享变量合并成一个共享变量进行<code>CAS</code>操作。</p><h2 id="CAS的应用"><a href="#CAS的应用" class="headerlink" title="CAS的应用"></a>CAS的应用</h2><p>我们知道<code>CAS</code>操作并不会锁住共享变量，也就是一种<strong>非阻塞</strong>的同步机制，<code>CAS</code>就是乐观锁的实现。</p><ol><li>乐观锁<br><strong>乐观锁</strong>总是假设最好的情况，每次去操作数据都认为不会被别的线程修改数据，<strong>所以在每次操作数据的时候都不会给数据加锁</strong>，即在线程对数据进行操作的时候，<strong>别的线程不会阻塞</strong>仍然可以对数据进行操作，只有在需要更新数据的时候才会去判断数据是否被别的线程修改过，如果数据被修改过则会拒绝操作并且返回错误信息给用户。</li><li>悲观锁<br><strong>悲观锁</strong>总是假设最坏的情况，每次去操作数据时候都认为会被的线程修改数据，<strong>所以在每次操作数据的时候都会给数据加锁</strong>，让别的线程无法操作这个数据，别的线程会一直阻塞直到获取到这个数据的锁。这样的话就会影响效率，比如当有个线程发生一个很耗时的操作的时候，别的线程只是想获取这个数据的值而已都要等待很久。</li></ol><p><code>Java</code>利用<code>CAS</code>的乐观锁、原子性的特性高效解决了多线程的安全性问题，例如JDK1.8中的集合类<code>ConcurrentHashMap</code>、关键字<code>volatile</code>、<code>ReentrantLock</code>等。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zl198751.iteye.com/blog/1848575" target="_blank" rel="noopener">JAVA CAS原理深度分析</a><br><a href="http://objcoding.com/2018/11/29/cas/" target="_blank" rel="noopener">Java并发之CAS原理分析</a><br><a href="https://segmentfault.com/a/1190000014858404#articleHeader3" target="_blank" rel="noopener">Java CAS 原理分析</a><br><a href="https://www.zhihu.com/question/23281499" target="_blank" rel="noopener">什么是ABA问题？</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;http://ws2.sinaimg.cn/large/e0e01e43ly1g11dcysv30j20t60jh1kx.jpg&quot; alt=&quot;image&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是CA
      
    
    </summary>
    
      <category term="Java编程基础" scheme="http://ddnd.cn/categories/Java-Programming/"/>
    
    
      <category term="多线程" scheme="http://ddnd.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="CAS" scheme="http://ddnd.cn/tags/CAS/"/>
    
  </entry>
  
  <entry>
    <title>什么是Java内存模型？</title>
    <link href="http://ddnd.cn/2019/03/11/java-memory-model/"/>
    <id>http://ddnd.cn/2019/03/11/java-memory-model/</id>
    <published>2019-03-11T08:24:28.000Z</published>
    <updated>2019-03-13T12:11:26.706Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><img src="http://ws3.sinaimg.cn/large/e0e01e43ly1g0z8ongt9yj21qi15okjn.jpg" alt="image" width="100%"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>要想深入了解Java并发编程，就要先理解好<strong>Java内存模型</strong>，而要理解Java内存模型又不得不从硬件、计算机内存模型说起，本文从计算机内存模型产生的原因、解决的问题谈起，然后再对Java模型进行介绍，最后对计算机内存模型和Java内存模型进行总结，希望大家看完本文之后有所收获！</p><h2 id="CPU工作过程及出现的问题"><a href="#CPU工作过程及出现的问题" class="headerlink" title="CPU工作过程及出现的问题"></a>CPU工作过程及出现的问题</h2><h3 id="CPU执行过程"><a href="#CPU执行过程" class="headerlink" title="CPU执行过程"></a>CPU执行过程</h3><p>大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道，而计算机上面的临时数据，是储存在<strong>主存</strong>中的。    </p><blockquote><p>计算机内存包括<strong>高速缓存</strong>和<strong>主存</strong>。</p></blockquote><p>我们知道CPU执行指令的速度比从主存读取数据和向主存写入数据快很多，所以为了高效利用CPU，CPU增加了<strong>高速缓存(cache)</strong>来匹配CPU的执行速度，最终程序的执行过程如下</p><ol><li>首先会将数据从主存中复制一份到CPU的高速缓存中</li><li>当CPU执行计算的时候就可以直接从高速缓存中读取数据和写入数据</li><li>当运算结束后，再将高速缓存的数据更新到主存中    </li></ol><h3 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h3><p>上面的执行过程在单线程情况下并没有问题，但是在多线程情况下就会出现问题，<strong>因为CPU如果含有多个核心，则每个核心都有自己独占高速缓存</strong>，如果出现多个线程同时执行同一个操作，那么结果是无法预知。例如<code>2</code>个线程同时执行<code>i++</code>，假设i的初始值是<code>0</code>，那么我们希望<code>2</code>个线程执行完成之后<code>i</code>的值变为<code>2</code>，但是事实会是这样吗？<br><img src="http://wx2.sinaimg.cn/large/e0e01e43ly1g0z8qqzxgmj20p70kjwgk.jpg" alt="image"></p><p>可能出现的情况有：    </p><ol><li>线程1先将<code>i=0</code>从主存中读取到线程1的高速缓存中，然后CPU完成运算，再将<code>i=1</code>写入到主存中，然后线程2开始从主存中读取<code>i=1</code>到线程2的高速缓存中，然后CPU完成运算，再将<code>i=2</code>写入到主存中，那么<code>i=2</code>即为我们想要的结果。</li><li>线程1将<code>i=0</code>从主存中读取到线程1的高速缓存中的同时线程2也从主存中读取<code>i=0</code>到线程2的高速缓存中，然后线程1和线程2完成运算后，也都将<code>i=1</code>写入到主存中，那么结果<code>i=1</code>，结果就不是我们想要的了。出现这个情况，我们称为<strong>缓存不一致问题</strong>。</li></ol><p>那么如何解决CPU出现的<strong>缓存不一致问题</strong>呢？通常使用的解决方法有2种：     </p><ol><li>通过给总线加锁</li><li>使用<strong>缓存一致性协议</strong></li></ol><p><img src="http://ws3.sinaimg.cn/large/e0e01e43ly1g0z8qyxhv7j20qc092757.jpg" alt="image"><br>第<code>1</code>种方法虽然也达到了目的，但是在总线被锁住的期间，其他的CPU也无法访问主存，<strong>效率很低</strong>，所以就出现了缓存一致性协议即第<code>2</code>种方法，其中最出名的就是<code>Intel</code>的MESI协议，MESI协议保证每个CPU高速缓存中的变量都是一致的。它的核心思想是，当CPU写数据时候，如果发现操作的变量是共享变量(即其他CPU上也存在该变量)，就会发出信号通知<strong>其他CPU</strong>将它高速缓存中缓存这个变量的缓存行置为<strong>无效状态</strong>，因此当其他CPU需要读取这个变量时，发现自己高速缓存中缓存该变量的缓存行为无效状态，那么它就会从主存中<strong>重新读取</strong>。<br><img src="http://ws1.sinaimg.cn/large/e0e01e43ly1g0z8r8km5kj20q20bs40h.jpg" alt="image"></p><h3 id="处理器重排序问题"><a href="#处理器重排序问题" class="headerlink" title="处理器重排序问题"></a>处理器重排序问题</h3><p>在多线程场景下，CPU除了会出现缓存一致性问题，还会出现因为<strong>处理器重排序</strong>即<strong>处理器(CPU)为了提高效率可能会对输入的代码进行乱序执行</strong>，而造成多线程的情况下出现问题。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//线程1:</span><br><span class="line">context = loadContext();   //语句1</span><br><span class="line">inited = true;             //语句2</span><br><span class="line"> </span><br><span class="line">//线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure></p><p>线程1由于处理器重排序，先执行性了语句2，那么此时线程2会认为<code>context</code>已经初始化完成，那么跳出循环，去执行<code>doSomethingwithconfig(context)</code>方法，实际上此时context并未初始化(即线程1的语句1还未执行)，而导致程序出错。</p><h2 id="什么是计算机内存模型"><a href="#什么是计算机内存模型" class="headerlink" title="什么是计算机内存模型"></a>什么是计算机内存模型</h2><p>上面提到的<strong>缓存一致性问题</strong>、<strong>处理器重排序问题</strong>都是在多线程情况下CPU可能出现的问题，那我们应该怎么处理这些问题？实际上这些问题并不需要我们考虑，这些问题CPU都会处理好，而CPU处理这些问题的时候是按照特定的<strong>操作规范</strong>，对特定的主存进行访问或告诉CPU高速缓存怎么访问主存，保证了多线程场景下的<strong>原子性、可见性、有序性</strong>，这个操作规范就称为<strong>计算机内存模型</strong>。      </p><blockquote><p>可见性即当一个变量修改后，这个变量会马上更新到主存中，其他线程会收到通知这个变量修改过了，使用这个变量的时候重新去主存获取</p></blockquote><h2 id="什么是Java内存模型"><a href="#什么是Java内存模型" class="headerlink" title="什么是Java内存模型"></a>什么是Java内存模型</h2><p>从前面的介绍了解到计算机内存模型是一种解决多线程场景下的一个主存操作规范，既然是规范，那么不同的编程语言都可以遵循这种操作规范，在多线程场景下访问主存保证原子性、可见性、有序性。<br><strong>Java内存模型(Java Memory Model，JMM)</strong>即是Java语言对这个操作规范的遵循，<code>JMM</code>规定了所有的变量都存储在<strong>主存</strong>中，每个线程都有自己的<strong>工作区</strong>，线程将使用到的变量从主存中<strong>复制</strong>一份到自己的工作区，线程对变量的<strong>所有操作</strong>(读取、赋值等)都必须在工作区，不同的线程也无法直接访问对方工作区，线程之间的消息传递都需要通过主存来完成。<strong>可以把这里主存类比成计算机内存模型中的主存，工作区类比成计算机内存模型中的高速缓存</strong>。</p><p><img src="http://ws2.sinaimg.cn/large/e0e01e43ly1g0z8rfihfkj20qk09ft9l.jpg" alt="image"></p><p>而我们知道<code>JMM</code>其实是工作主存中的，Java内存模型中的工作区也是主存中的一部分，所以可以这样说Java内存模型解决的是<strong>内存一致性问题(主存和主存)</strong>而计算机内存模型解决的是<strong>缓存一致性问题(CPU高速缓存和主存)</strong>，这两个模型类似，但是作用域不一样，Java内存模型保证的是主存和主存之间的原子性、可见性、有序性，而计算机内存模型保证的是CPU高速缓存和主存之间的原子性、可见性、有序性。</p><p><img src="http://ws1.sinaimg.cn/large/e0e01e43ly1g0z8rlifrqj20zb0cbjsz.jpg" alt="image"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文很多观点都是按照笔者自己的理解然后总结出来的，若有偏颇，欢迎指正！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">Java并发编程：volatile关键字解析</a><br><a href="https://blog.csdn.net/u013256816/article/details/51510815" target="_blank" rel="noopener">Java内存模型</a><br><a href="http://developer.51cto.com/art/201807/579744.htm" target="_blank" rel="noopener">【教程】终于有人把Java内存模型说清楚了！</a><br><a href="https://www.zhihu.com/question/268021813" target="_blank" rel="noopener">关于JAVA内存模型与MESI协议？</a><br><a href="https://www.zhihu.com/question/277395220" target="_blank" rel="noopener">有了缓存一致性协议为什么还需要多线程同步？</a>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;http://ws3.sinaimg.cn/large/e0e01e43ly1g0z8ongt9yj21qi15okjn.jpg&quot; alt=&quot;image&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Java编程基础" scheme="http://ddnd.cn/categories/Java-Programming/"/>
    
    
      <category term="Java内存模型" scheme="http://ddnd.cn/tags/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="计算机内存模型" scheme="http://ddnd.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="多线程" scheme="http://ddnd.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>10分钟掌握ConcurrentHashMap 3分钟清楚和HashMap、Hashtable的区别</title>
    <link href="http://ddnd.cn/2019/03/10/jdk1-8-concurrenthashmap/"/>
    <id>http://ddnd.cn/2019/03/10/jdk1-8-concurrenthashmap/</id>
    <published>2019-03-10T14:02:55.000Z</published>
    <updated>2019-03-13T12:11:08.004Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><img src="http://wx3.sinaimg.cn/large/e0e01e43ly1g0y4kkt2k3j21y013bb2b.jpg" alt="image" width="100%"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>ConcurrentHashMap</code>顾名思义就是同步的HashMap，也就是线程安全的HashMap，所以本篇介绍的ConcurrentHashMap和HashMap有着很重要的关系，所以建议之前没有了解过HashMap的可以先看看这篇关于HashMap的原理分析<a href="https://ddnd.cn/2019/03/07/jdk1.8-hashmap/">《HashMap从认识到源码分析》</a>，本篇继续以<code>JDK1.8</code>版本的源码进行分析，最后在介绍完ConcurrentHashMap之后会对ConcurrentHashMap、Hashtable和HashMap做一个比较和总结。</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>我们先看一下<code>ConcurrentHashMap</code>实现了哪些接口、继承了哪些类，对<code>ConcurrentHashMap</code>有一个整体认知。<br><img src="http://wx1.sinaimg.cn/large/e0e01e43ly1g0y4iof3w1j20qp0hvjsa.jpg" alt="image"><br><code>ConcurrentHashMap</code>继承<code>AbstractMap</code>接口，这个和<code>HashMap</code>一样，然后实现了<code>ConcurrentMap</code>接口，这个和<code>HashMap</code>不一样，<code>HashMap</code>是直接实现的<code>Map</code>接口。<br>再细看<code>ConcurrentHashMap</code>的结构，这里列举几个重要的成员变量<code>table</code>、<code>nextTable</code>、<code>baseCount</code>、<code>sizeCtl</code>、<code>transferIndex</code>、<code>cellsBusy</code></p><ul><li><strong>table</strong>：数据类型是Node数组，这里的Node和HashMap的Node一样都是内部类且实现了<code>Map.Entry</code>接口</li><li><strong>nextTable</strong>：哈希表扩容时生成的数据，数组为扩容前的2倍</li><li><strong>sizeCtl</strong>：多个线程的<strong>共享变量</strong>，是操作的控制标识符，它的作用不仅包括<code>threshold</code>的作用，在不同的地方有不同的值也有不同的用途<ul><li><code>-1</code>代表正在<strong>初始化</strong></li><li><code>-N</code>代表有<code>N-1</code>个线程正在进行<strong>扩容</strong>操作</li><li><code>0</code>代表hash表还没有被初始化</li><li>正数表示下一次进行扩容的容量大小</li></ul></li><li><strong>ForwardingNode</strong>：一个特殊的Node节点，Hash地址为-1，存储着nextTable的引用，只有table发生扩用的时候，ForwardingNode才会发挥作用，作为一个占位符放在table中表示当前节点为null或者已被移动<br><img src="http://wx4.sinaimg.cn/large/e0e01e43ly1g0y4j0xa3bj20m20j7gmq.jpg" alt="image"><br><code>ConcurrentHashMap</code>和<code>HashMap</code>一样都是采用<strong>拉链法</strong>处理哈希冲突，且都为了防止单链表过长影响查询效率，所以当链表长度超过某一个值时候将用红黑树代替链表进行存储，采用了<strong>数组+链表+红黑树</strong>的结构<br><img src="http://ws4.sinaimg.cn/large/e0e01e43ly1g0y4j8c72lj20zg0g60u3.jpg" alt="image"><br>所以从结构上看<code>HashMap</code>和<code>ConcurrentHashMap</code>还是很相似的，只是<code>ConcurrentHashMap</code>在某些操作上采用了<code>CAS</code> + <code>synchronized</code>来保证并发情况下的安全。<br>说到<code>ConcurrentHashMap</code>处理并发情况下的线程安全问题，这不得不提到<code>Hashtable</code>，因为<code>Hashtable</code>也是线程安全的，那<code>ConcurrentHashMap</code>和<code>Hashtable</code>有什么区别或者有什么高明之处嘛？以至于官方都推荐使用<code>ConcurrentHashMap</code>来代替<code>Hashtable</code></li><li><strong>线程安全的实现</strong>：<code>Hashtable</code>采用<strong>对象锁</strong>(synchronized修饰对象方法)来保证线程安全，也就是一个<code>Hashtable</code>对象只有一把锁，如果线程1拿了对象A的锁进行有<code>synchronized</code>修饰的<code>put</code>方法，其他线程是无法操作对象A中有<code>synchronized</code>修饰的方法的(如<code>get</code>方法、<code>remove</code>方法等)，竞争激烈所以效率低下。而<code>ConcurrentHashMap</code>采用<code>CAS</code> + <code>synchronized</code>来保证并发安全性，且<code>synchronized</code>关键字不是用在方法上而是用在了具体的对象上，实现了更小粒度的锁，等会源码分析的时候在细说这个SUN大师们的鬼斧神工</li><li>数据结构的实现：<code>Hashtable</code>采用的是<strong>数组 + 链表</strong>，当链表过长会影响查询效率，而<code>ConcurrentHashMap</code>采用<strong>数组 + 链表 + 红黑树</strong>，当链表长度超过某一个值，则将链表转成红黑树，提高查询效率。      </li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><code>ConcurrentHashMap</code>的构造函数有5个，从数量上看就和<code>HashMap</code>、<code>Hashtable</code>(4个)的不同，多出的那个构造函数是<code>public ConcurrentHashMap(int initialCapacity,float loadFactor, int concurrencyLevel)</code>，即除了传入容量大小、负载因子之外还多传入了一个整型的<code>concurrencyLevel</code>，这个整型是我们预先估计的并发量，比如我们估计并发是<code>30</code>，那么就可以传入<code>30</code>。<br>其他的4个构造函数的参数和<code>HashMap</code>的一样，而具体的初始化过程却又不相同，<code>HashMap</code>和<code>Hashtable</code>传入的容量大小和负载因子都是为了计算出<strong>初始阈值</strong>(threshold)，而<code>ConcurrentHashMap</code>传入的容量大小和负载因子是为了计算出<strong>sizeCtl</strong>用于初始化<code>table</code>，这个sizeCtl即table数组的大小，不同的构造函数计算sizeCtl方法都不一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//无参构造函数，什么也不做，table的初始化放在了第一次插入数据时，默认容量大小是16和HashMap的一样，默认sizeCtl为0</span><br><span class="line">public ConcurrentHashMap() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//传入容量大小的构造函数。</span><br><span class="line">public ConcurrentHashMap(int initialCapacity) &#123;</span><br><span class="line">    //如果传入的容量大小小于0 则抛出异常。</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    //如果传入的容量大小大于允许的最大容量值 则cap取允许的容量最大值 否则cap =</span><br><span class="line">    //((传入的容量大小 + 传入的容量大小无符号右移1位 + 1)的结果向上取最近的2幂次方)，</span><br><span class="line">    //即如果传入的容量大小是12 则 cap = 32(12 + (12 &gt;&gt;&gt; 1) + 1=19</span><br><span class="line">    //向上取2的幂次方即32)，这里为啥一定要是2的幂次方，原因和HashMap的threshold一样，都是为</span><br><span class="line">    //了让位运算和取模运算的结果一样。</span><br><span class="line">    //MAXIMUM_CAPACITY即允许的最大容量值 为2^30。</span><br><span class="line">    int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               //tableSizeFor这个函数即实现了将一个整数取2的幂次方。</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1));</span><br><span class="line">    //将上面计算出的cap 赋值给sizeCtl，注意此时sizeCtl为正数，代表进行扩容的容量大小。</span><br><span class="line">    this.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//包含指定Map的构造函数。</span><br><span class="line">//置sizeCtl为默认容量大小 即16。</span><br><span class="line">public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">    this.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//传入容量大小和负载因子的构造函数。</span><br><span class="line">//默认并发数大小是1。</span><br><span class="line">public ConcurrentHashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    this(initialCapacity, loadFactor, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//传入容量大小、负载因子和并发数大小的构造函数</span><br><span class="line">public ConcurrentHashMap(int initialCapacity,</span><br><span class="line">                         float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">    if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    //如果传入的容量大小 小于 传入的并发数大小，</span><br><span class="line">    //则容量大小取并发数大小，这样做的原因是确保每一个Node只会分配给一个线程，而一个线程则</span><br><span class="line">    //可以分配到多个Node，比如当容量大小为64，并发数大</span><br><span class="line">    //小为16时，则每个线程分配到4个Node。</span><br><span class="line">    if (initialCapacity &lt; concurrencyLevel)   // Use at least as many bins</span><br><span class="line">        initialCapacity = concurrencyLevel;   // as estimated threads</span><br><span class="line">    //size = 1.0 + (long)initialCapacity / loadFactor 这里计算方法和上面的构造函数不一样。</span><br><span class="line">    long size = (long)(1.0 + (long)initialCapacity / loadFactor);</span><br><span class="line">    //如果size大于允许的最大容量值则 sizeCtl = 允许的最大容量值 否则 sizeCtl =</span><br><span class="line">    //size取2的幂次方。</span><br><span class="line">    int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((int)size);</span><br><span class="line">    this.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><ol><li>判断键值是否为<code>null</code>，为<code>null</code>抛出异常。</li><li>调用<code>spread()</code>方法计算key的hashCode()获得哈希地址，这个HashMap相似。</li><li>如果当前table为空，则初始化table，需要注意的是这里并没有加<code>synchronized</code>，也就是允许多个线程去<strong>尝试</strong>初始化table，但是在初始化函数里面使用了<code>CAS</code>保证只有一个线程去执行初始化过程。</li><li>使用 <strong>容量大小-1 &amp; 哈希地址</strong> 计算出待插入键值的下标，如果该下标上的bucket为<code>null</code>，则直接调用实现<code>CAS</code>原子性操作的<code>casTabAt()</code>方法将节点插入到table中，如果插入成功则完成put操作，结束返回。插入失败(被别的线程抢先插入了)则继续往下执行。</li><li>如果该下标上的节点(头节点)的哈希地址为-1，代表需要扩容，该线程执行<code>helpTransfer()</code>方法协助扩容。</li><li>如果该下标上的bucket不为空，且又不需要扩容，则进入到bucket中，同时<strong>锁住这个bucket</strong>，注意只是锁住该下标上的bucket而已，其他的bucket并未加锁，其他线程仍然可以操作其他未上锁的bucket，这个就是ConcurrentHashMap为什么高效的原因之一。</li><li>进入到bucket里面，首先判断这个bucket存储的是红黑树(哈希地址小于0，原因后面分析)还是链表。</li><li>如果是<strong>链表</strong>，则遍历链表看看是否有哈希地址和键key相同的节点，有的话则根据传入的参数进行覆盖或者不覆盖，没有找到相同的节点的话则将新增的节点<strong>插入到链表尾部</strong>。如果是<strong>红黑树</strong>，则将节点插入。到这里<strong>结束加锁</strong>。</li><li>最后判断该bucket上的链表长度是否大于<strong>链表转红黑树的阈值(8)</strong>，大于则调用<code>treeifyBin()</code>方法将链表转成红黑树，以免链表过长影响效率。</li><li>调用<code>addCount()</code>方法，作用是将ConcurrentHashMap的键值对数量+1，还有另一个作用是检查ConcurrentHashMap是否需要扩容。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(key, value, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    //不允许键值为null，这点与线程安全的Hashtable保持一致，和HashMap不同。</span><br><span class="line">    if (key == null || value == null) throw new NullPointerException();</span><br><span class="line">    //取键key的hashCode()和HashMap、Hashtable都一样，然后再执行spread()方法计算得到哈希地</span><br><span class="line">    //址，这个spread()方法和HashMap的hash()方法一样，都是将hashCode()做无符号右移16位，只不</span><br><span class="line">    //过spread()加多了 &amp;0x7fffffff，让结果为正数。</span><br><span class="line">    int hash = spread(key.hashCode());</span><br><span class="line">    int binCount = 0;</span><br><span class="line">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">        //如果table数组为空或者长度为0(未初始化)，则调用initTable()初始化table，初始化函数</span><br><span class="line">        //下面介绍。</span><br><span class="line">        if (tab == null || (n = tab.length) == 0)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        //调用实现了CAS原子性操作的tabAt方法</span><br><span class="line">        //tabAt方法的第一个参数是Node数组的引用，第二个参数在Node数组的下标，实现的是在Nod</span><br><span class="line">        //e数组中查找指定下标的Node，如果找到则返回该Node节点(链表头节点)，否则返回null，</span><br><span class="line">        //这里的i = (n - 1)&amp;hash即是计算待插入的节点在table的下标，即table容量-1的结果和哈</span><br><span class="line">        //希地址做与运算，和HashMap的算法一样。</span><br><span class="line">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</span><br><span class="line">            //如果该下标上并没有节点(即链表为空)，则直接调用实现了CAS原子性操作的</span><br><span class="line">            //casTable()方法，</span><br><span class="line">            //casTable()方法的第一个参数是Node数组的引用，第二个参数是待操作的下标，第三</span><br><span class="line">            //个参数是期望值，第四个参数是待操作的Node节点，实现的是将Node数组下标为参数二</span><br><span class="line">            //的节点替换成参数四的节点，如果期望值和实际值不符返回false，否则参数四的节点成</span><br><span class="line">            //功替换上去，返回ture，即插入成功。注意这里：如果插入成功了则跳出for循环，插入</span><br><span class="line">            //失败的话(其他线程抢先插入了)，那么会执行到下面的代码。</span><br><span class="line">            if (casTabAt(tab, i, null,</span><br><span class="line">                         new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                break;                   // no lock when adding to empty bin</span><br><span class="line">        &#125;</span><br><span class="line">        //如果该下标上的节点的哈希地址为-1(即链表的头节点为ForwardingNode节点)，则表示</span><br><span class="line">        //table需要扩容，值得注意的是ConcurrentHashMap初始化和扩容不是用同一个方法，而</span><br><span class="line">        //HashMap和Hashtable都是用同一个方法，当前线程会去协助扩容，扩容过程后面介绍。</span><br><span class="line">        else if ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        //如果该下标上的节点既不是空也不是需要扩容，则表示这个链表可以插入值，将进入到链表</span><br><span class="line">        //中，将新节点插入或者覆盖旧值。</span><br><span class="line">        else &#123;</span><br><span class="line">            V oldVal = null;</span><br><span class="line">            //通过关键字synchroized对该下标上的节点加锁(相当于锁住锁住</span><br><span class="line">            //该下标上的链表)，其他下标上的节点并没有加锁，所以其他线程</span><br><span class="line">            //可以安全的获得其他下标上的链表进行操作，也正是因为这个所</span><br><span class="line">            //以提高了ConcurrentHashMap的效率，提高了并发度。</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    //如果该下标上的节点的哈希地址大于等于0，则表示这是</span><br><span class="line">                    //个链表。</span><br><span class="line">                    if (fh &gt;= 0) &#123;</span><br><span class="line">                        binCount = 1;</span><br><span class="line">                        //遍历链表。</span><br><span class="line">                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            //如果哈希地址、键key相同 或者 键key不为空</span><br><span class="line">                            //且键key相同，则表示存在键key和待插入的键</span><br><span class="line">                            //key相同，则执行更新值value的操作。</span><br><span class="line">                            if (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                if (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            //如果找到了链表的最后一个节点都没有找到相</span><br><span class="line">                            //同键Key的，则是插入操作，将插入的键值新建</span><br><span class="line">                            //个节点并且添加到链表尾部，这个和HashMap一</span><br><span class="line">                            //样都是插入到尾部。</span><br><span class="line">                            if ((e = e.next) == null) &#123;</span><br><span class="line">                                pred.next = new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, null);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //如果该下标上的节点的哈希地址小于0 且为树节点</span><br><span class="line">                    //则将带插入键值新增到红黑树</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = 2;</span><br><span class="line">                        //如果插入的结果不为null，则表示为替换</span><br><span class="line">                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash,</span><br><span class="line">                        key,value)) != null)&#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            if (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //判断链表的长度是否大于等于链表的阈值(8)，大于则将链表转成</span><br><span class="line">            //红黑树，提高效率。这点和HashMap一样。</span><br><span class="line">            if (binCount != 0) &#123;</span><br><span class="line">                if (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                if (oldVal != null)</span><br><span class="line">                    return oldVal;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(1L, binCount);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><ol><li>调用<code>spread()</code>方法计算key的hashCode()获得哈希地址。</li><li>计算出键key所在的下标，算法是(n - 1) &amp; h，如果table不为空，且下标上的bucket不为空，则到bucket中查找。</li><li>如果bucket的头节点的哈希地址小于0，则代表这个bucket存储的是红黑树，否则是链表。</li><li>到红黑树或者链表中查找，找到则返回该键key的值，找不到则返回null。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">    //运用键key的hashCode()计算出哈希地址</span><br><span class="line">    int h = spread(key.hashCode());</span><br><span class="line">    //如果table不为空 且 table长度大于0 且 计算出的下标上bucket不为空，</span><br><span class="line">    //则代表这个bucket存在，进入到bucket中查找，</span><br><span class="line">    //其中(n - 1) &amp; h为计算出键key相对应的数组下标的算法。</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;</span><br><span class="line">        //如果哈希地址、键key相同则表示查找到，返回value，这里查找到的是头节点。</span><br><span class="line">        if ((eh = e.hash) == h) &#123;</span><br><span class="line">            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果bucket头节点的哈希地址小于0，则代表bucket为红黑树，在红黑树中查找。</span><br><span class="line">        else if (eh &lt; 0)</span><br><span class="line">            return (p = e.find(h, key)) != null ? p.val : null;</span><br><span class="line">        //如果bucket头节点的哈希地址不小于0，则代表bucket为链表，遍历链表，在链表中查找。</span><br><span class="line">        while ((e = e.next) != null) &#123;</span><br><span class="line">            if (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><ol><li>调用<code>spread()</code>方法计算出键key的哈希地址。</li><li>计算出键key所在的数组下标，如果table为空或者bucket为空，则返回<code>null</code>。</li><li>判断当前table是否正在扩容，如果在扩容则调用helpTransfer方法协助扩容。</li><li>如果table和bucket都不为空，table也不处于在扩容状态，则<strong>锁住当前bucket</strong>，对bucket进行操作。</li><li>根据bucket的头结点判断bucket是链表还是红黑树。</li><li>在链表或者红黑树中移除哈希地址、键key相同的节点。</li><li>调用<code>addCount</code>方法，将当前table存储的键值对数量-1。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    return replaceNode(key, null, null);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">final V replaceNode(Object key, V value, Object cv) &#123;</span><br><span class="line">    //计算需要移除的键key的哈希地址。</span><br><span class="line">    int hash = spread(key.hashCode());</span><br><span class="line">    //遍历table。</span><br><span class="line">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">        //table为空，或者键key所在的bucket为空，则跳出循环返回。</span><br><span class="line">        if (tab == null || (n = tab.length) == 0 ||</span><br><span class="line">            (f = tabAt(tab, i = (n - 1) &amp; hash)) == null)</span><br><span class="line">            break;</span><br><span class="line">        //如果当前table正在扩容，则调用helpTransfer方法，去协助扩容。</span><br><span class="line">        else if ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        else &#123;</span><br><span class="line">            V oldVal = null;</span><br><span class="line">            boolean validated = false;</span><br><span class="line">            //将键key所在的bucket加锁。</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    //bucket头节点的哈希地址大于等于0，为链表。</span><br><span class="line">                    if (fh &gt;= 0) &#123;</span><br><span class="line">                        validated = true;</span><br><span class="line">                        //遍历链表。</span><br><span class="line">                        for (Node&lt;K,V&gt; e = f, pred = null;;) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            //找到哈希地址、键key相同的节点，进行移除。</span><br><span class="line">                            if (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                V ev = e.val;</span><br><span class="line">                                if (cv == null || cv == ev ||</span><br><span class="line">                                    (ev != null &amp;&amp; cv.equals(ev))) &#123;</span><br><span class="line">                                    oldVal = ev;</span><br><span class="line">                                    if (value != null)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    else if (pred != null)</span><br><span class="line">                                        pred.next = e.next;</span><br><span class="line">                                    else</span><br><span class="line">                                        setTabAt(tab, i, e.next);</span><br><span class="line">                                &#125;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            pred = e;</span><br><span class="line">                            if ((e = e.next) == null)</span><br><span class="line">                                break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //如果bucket的头节点小于0，即为红黑树。</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                        validated = true;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                        //找到节点，并且移除。</span><br><span class="line">                        if ((r = t.root) != null &amp;&amp;</span><br><span class="line">                            (p = r.findTreeNode(hash, key, null)) != null) &#123;</span><br><span class="line">                            V pv = p.val;</span><br><span class="line">                            if (cv == null || cv == pv ||</span><br><span class="line">                                (pv != null &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                                oldVal = pv;</span><br><span class="line">                                if (value != null)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                                else if (t.removeTreeNode(p))</span><br><span class="line">                                    setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //调用addCount方法，将当前ConcurrentHashMap存储的键值对数量-1。</span><br><span class="line">            if (validated) &#123;</span><br><span class="line">                if (oldVal != null) &#123;</span><br><span class="line">                    if (value == null)</span><br><span class="line">                        addCount(-1L, -1);</span><br><span class="line">                    return oldVal;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="initTable初始化方法"><a href="#initTable初始化方法" class="headerlink" title="initTable初始化方法"></a>initTable初始化方法</h3><p><code>table</code>的初始化主要由initTable()方法实现的，initTable()方法初始化一个合适大小的数组，然后设置sizeCtl。     我们知道<code>ConcurrentHashMap</code>是线程安全的，即支持多线程的，那么一开始很多个线程同时执行<code>put()</code>方法，而<code>table</code>又没初始化，那么就会很多个线程会去执行initTable()方法尝试初始化table，而<code>put</code>方法和<code>initTable</code>方法都是没有加锁的(synchronize)，那SUN的大师们是怎么保证线程安全的呢？    通过源码可以看得出，table的初始化只能由一个线程完成，但是每个线程都可以争抢去初始化table。       </p><ol><li>判断table是否为<code>null</code>，即需不需要首次初始化，如果某个线程进到这个方法后，其他线程已经将table初始化好了，那么该线程结束该方法返回。</li><li>如果table为<code>null</code>，进入到while循环，如果<code>sizeCtl</code>小于0(其他线程正在对table初始化)，那么该线程调用<code>Thread.yield()</code>挂起该线程，让出CPU时间，该线程也从运行态转成就绪态，等该线程从就绪态转成运行态的时候，别的线程已经table初始化好了，那么该线程结束while循环，结束初始化方法返回。如果从就绪态转成运行态后，table仍然为<code>null</code>，则继续while循环。</li><li>如果table为<code>null</code>且<code>sizeCtl</code>不小于0，则调用实现<code>CAS</code>原子性操作的<code>compareAndSwap()</code>方法将sizeCtl设置成-1，告诉别的线程我正在初始化table，这样别的线程无法对table进行初始化。如果设置成功，则再次判断table是否为空，不为空则初始化table，容量大小为默认的容量大小(16)，或者为sizeCtl。其中sizeCtl的初始化是在构造函数中进行的，sizeCtl = ((传入的容量大小 + 传入的容量大小无符号右移1位 + 1)的结果向上取最近的2幂次方)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; int sc;</span><br><span class="line">    //如果table为null或者长度为0， //则一直循环试图初始化table(如果某一时刻别的线程将table初始化好了，那table不为null，该//线程就结束while循环)。</span><br><span class="line">    while ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">        //如果sizeCtl小于0，</span><br><span class="line">        //即有其他线程正在初始化或者扩容，执行Thread.yield()将当前线程挂起，让出CPU时间，</span><br><span class="line">        //该线程从运行态转成就绪态。</span><br><span class="line">        //如果该线程从就绪态转成运行态了，此时table可能已被别的线程初始化完成，table不为</span><br><span class="line">        //null，该线程结束while循环。</span><br><span class="line">        if ((sc = sizeCtl) &lt; 0)</span><br><span class="line">            Thread.yield(); // lost initialization race; just spin</span><br><span class="line">        //如果此时sizeCtl不小于0，即没有别的线程在做table初始化和扩容操作，</span><br><span class="line">        //那么该线程就会调用Unsafe的CAS操作compareAndSwapInt尝试将sizeCtl的值修改成</span><br><span class="line">        //-1(sizeCtl=-1表示table正在初始化，别的线程如果也进入了initTable方法则会执行</span><br><span class="line">        //Thread.yield()将它的线程挂起 让出CPU时间)，</span><br><span class="line">        //如果compareAndSwapInt将sizeCtl=-1设置成功 则进入if里面，否则继续while循环。</span><br><span class="line">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //再次确认当前table为null即还未初始化，这个判断不能少。</span><br><span class="line">                if ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">                    //如果sc(sizeCtl)大于0，则n=sc，否则n=默认的容量大</span><br><span class="line">                    小16，</span><br><span class="line">                    //这里的sc=sizeCtl=0，即如果在构造函数没有指定容量</span><br><span class="line">                    大小，</span><br><span class="line">                    //否则使用了有参数的构造函数，sc=sizeCtl=指定的容量大小。</span><br><span class="line">                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                    //创建指定容量的Node数组(table)。</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    //计算阈值，n - (n &gt;&gt;&gt; 2) = 0.75n当ConcurrentHashMap储存的键值对数量</span><br><span class="line">                    //大于这个阈值，就会发生扩容。</span><br><span class="line">                    //这里的0.75相当于HashMap的默认负载因子，可以发现HashMap、Hashtable如果</span><br><span class="line">                    //使用传入了负载因子的构造函数初始化的话，那么每次扩容，新阈值都是=新容</span><br><span class="line">                    //量 * 负载因子，而ConcurrentHashMap不管使用的哪一种构造函数初始化，</span><br><span class="line">                    //新阈值都是=新容量 * 0.75。</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="transfer扩容方法"><a href="#transfer扩容方法" class="headerlink" title="transfer扩容方法"></a>transfer扩容方法</h3><p><code>transfer()</code>方法为<code>ConcurrentHashMap</code>扩容操作的核心方法。由于<code>ConcurrentHashMap</code>支持多线程扩容，而且也没有进行加锁，所以实现会变得有点儿复杂。整个扩容操作分为两步：</p><ol><li>构建一个nextTable，其大小为原来大小的<strong>两倍</strong>，这个步骤是在单线程环境下完成的</li><li>将原来table里面的内容复制到nextTable中，这个步骤是允许<strong>多线程</strong>操作的，所以性能得到提升，减少了扩容的时间消耗。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">//协助扩容方法</span><br><span class="line">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; int sc;</span><br><span class="line">    //如果当前table不为null 且 f为ForwardingNode节点 且 //新的table即nextTable存在的情况下才能协助扩容，该方法的作用是让线程参与扩容的复制。</span><br><span class="line">    if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123;</span><br><span class="line">        int rs = resizeStamp(tab.length);</span><br><span class="line">        while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; 0) &#123;</span><br><span class="line">            if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= 0)</span><br><span class="line">                break;</span><br><span class="line">            //更新sizeCtl的值，+1，代表新增一个线程参与扩容</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    return table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//扩容的方法</span><br><span class="line">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</span><br><span class="line">    int n = tab.length, stride;</span><br><span class="line">    //根据服务器CPU数量来决定每个线程负责的bucket数量，避免因为扩容的线程过多反而影响性能。</span><br><span class="line">    //如果CPU数量为1，则stride=1，否则将需要迁移的bucket数量(table大小)除以CPU数量，平分给</span><br><span class="line">    //各个线程，但是如果每个线程负责的bucket数量小于限制的最小是(16)的话，则强制给每个线程</span><br><span class="line">    //分配16个bucket数。</span><br><span class="line">    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; // subdivide range</span><br><span class="line">    //如果nextTable还未初始化，则初始化nextTable，这个初始化和iniTable初始化一样，只能由</span><br><span class="line">    //一个线程完成。</span><br><span class="line">    if (nextTab == null) &#123;            // initiating</span><br><span class="line">        try &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; catch (Throwable ex) &#123;      // try to cope with OOME</span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    int nextn = nextTab.length;</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    boolean advance = true;</span><br><span class="line">    boolean finishing = false; // to ensure sweep before committing nextTab</span><br><span class="line">    //分配任务和控制当前线程的任务进度，这部分是transfer()的核心逻辑，描述了如何与其他线</span><br><span class="line">    //程协同工作。</span><br><span class="line">    for (int i = 0, bound = 0;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int fh;</span><br><span class="line">        while (advance) &#123;</span><br><span class="line">            int nextIndex, nextBound;</span><br><span class="line">            if (--i &gt;= bound || finishing)</span><br><span class="line">                advance = false;</span><br><span class="line">            else if ((nextIndex = transferIndex) &lt;= 0) &#123;</span><br><span class="line">                i = -1;</span><br><span class="line">                advance = false;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (U.compareAndSwapInt</span><br><span class="line">                     (this, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : 0))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - 1;</span><br><span class="line">                advance = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            int sc;</span><br><span class="line">            if (finishing) &#123;</span><br><span class="line">                nextTable = null;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;</span><br><span class="line">                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    return;</span><br><span class="line">                finishing = advance = true;</span><br><span class="line">                i = n; // recheck before commit</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((f = tabAt(tab, i)) == null)</span><br><span class="line">            advance = casTabAt(tab, i, null, fwd);</span><br><span class="line">        else if ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = true; // already processed</span><br><span class="line">        //迁移过程（对当前指向的bucket），这部分的逻辑与HashMap类似，拿旧数组的容量当做一</span><br><span class="line">        //个掩码，然后与节点的hash进行与操作，可以得出该节点的新增有效位，如果新增有效位为</span><br><span class="line">        //0就放入一个链表A，如果为1就放入另一个链表B，链表A在新数组中的位置不变（跟在旧数</span><br><span class="line">        //组的索引一致），链表B在新数组中的位置为原索引加上旧数组容量。</span><br><span class="line">        else &#123;</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    if (fh &gt;= 0) &#123;</span><br><span class="line">                        int runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;</span><br><span class="line">                            int b = p.hash &amp; n;</span><br><span class="line">                            if (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (runBit == 0) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = null;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = null;</span><br><span class="line">                        &#125;</span><br><span class="line">                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            int ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            if ((ph &amp; n) == 0)</span><br><span class="line">                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            else</span><br><span class="line">                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = null, loTail = null;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;</span><br><span class="line">                        int lc = 0, hc = 0;</span><br><span class="line">                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123;</span><br><span class="line">                            int h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, null, null);</span><br><span class="line">                            if ((h &amp; n) == 0) &#123;</span><br><span class="line">                                if ((p.prev = loTail) == null)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if ((p.prev = hiTail) == null)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="addCount、sumCount方法"><a href="#addCount、sumCount方法" class="headerlink" title="addCount、sumCount方法"></a>addCount、sumCount方法</h3><p><code>addCount()</code>做的工作是更新table的size，也就是table存储的键值对数量，在使用<code>put()</code>和<code>remove()</code>方法的时候都会在执行成功之后调用<code>addCount()</code>来更新table的size。对于<code>ConcurrentHashMap</code>来说，它到底有储存有多少个键值对，谁也不知道，因为他是支持并发的，储存的数量无时无刻都在变化着，所以说<code>ConcurrentHashMap</code>也只是统计一个大概的值，为了统计出这个值也是大费周章才统计出来的。<br><img src="http://wx1.sinaimg.cn/large/e0e01e43ly1g0y4jjmzr3j21640kqwiy.jpg" alt="image"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">private final void addCount(long x, int check) &#123;</span><br><span class="line">    CounterCell[] as; long b, s;</span><br><span class="line">    //如果计算盒子不是空，或者修改baseCount的值+x失败,则放弃对baseCount的修改。</span><br><span class="line">    //这里的大概意思就是首先尝试直接修改baseCount，达到计数的目的，如果修改baseCount失败(</span><br><span class="line">    //多个线程同时修改，则失败)</span><br><span class="line">    //则使用CounterCell数组来达到计数的目的。</span><br><span class="line">    if ((as = counterCells) != null ||</span><br><span class="line">        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; long v; int m;</span><br><span class="line">        boolean uncontended = true;</span><br><span class="line">        //如果计数盒子是空的 或者随机取余一个数组为空 或者修改这个槽位的变量失败，</span><br><span class="line">        //即表示出现了并发，则执行fullAddCount()方法进行死循环插入，同时返回，</span><br><span class="line">        //否则代表修改这个槽位的变量成功了，继续往下执行，不进入if。</span><br><span class="line">        //每个线程都会通过ThreadLocalRandom.getProbe() &amp; m寻址找到属于它的CounterCell，</span><br><span class="line">        //然后进行计数。ThreadLocalRandom是一个线程私有的伪随机数生成器，</span><br><span class="line">        //每个线程的probe都是不同的。CounterCell数组的大小永远是一个2的n次方，初始容量</span><br><span class="line">        //为2，每次扩容的新容量都是之前容量乘以二，处于性能考虑，它的最大容量上限是机器</span><br><span class="line">        //的CPU数量，所以说CounterCell数组的碰撞冲突是很严重的。</span><br><span class="line">        if (as == null || (m = as.length - 1) &lt; 0 ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">             //并发过大，使用CAS修改CounterCell失败时候执行fullAddCount，</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果上面对盒子的赋值成功，且check&lt;=1，则直接返回，否则调用sumConut()方法计算</span><br><span class="line">        if (check &lt;= 1)</span><br><span class="line">            return;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    //如果check&gt;=0，则检查是否需要扩容。</span><br><span class="line">    if (check &gt;= 0) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; int n, sc;</span><br><span class="line">        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            int rs = resizeStamp(n);</span><br><span class="line">            if (sc &lt; 0) &#123;</span><br><span class="line">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||</span><br><span class="line">                    transferIndex &lt;= 0)</span><br><span class="line">                    break;</span><br><span class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (U.compareAndSwapInt(this, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br><span class="line">                transfer(tab, null);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@sun.misc.Contended static final class CounterCell &#123;</span><br><span class="line">    volatile long value;</span><br><span class="line">    CounterCell(long x) &#123; value = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final long sumCount() &#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    long sum = baseCount;</span><br><span class="line">    if (as != null) &#123;</span><br><span class="line">        for (int i = 0; i &lt; as.length; ++i) &#123;</span><br><span class="line">            if ((a = as[i]) != null)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="size、mappingCount方法"><a href="#size、mappingCount方法" class="headerlink" title="size、mappingCount方法"></a>size、mappingCount方法</h3><p><code>size</code>和<code>mappingCount</code>方法都是用来统计table的size的，这两者不同的地方在<code>size</code>返回的是一个<code>int</code>类型，即可以表示size的范围是[-2^31，2^31-1]，超过这个范围就返回int能表示的最大值，<code>mappingCount</code>返回的是一个<code>long</code>类型，即可以表示size的范围是[-2^63，2^63-1]。<br>这两个方法都是调用的sumCount()方法实现统计。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">    long n = sumCount();</span><br><span class="line">    return ((n &lt; 0L) ? 0 :</span><br><span class="line">            (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (int)n);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public long mappingCount() &#123;</span><br><span class="line">    long n = sumCount();</span><br><span class="line">    return (n &lt; 0L) ? 0L : n; // ignore transient negative values</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="HashMap、Hashtable、ConcurrentHashMap三者对比"><a href="#HashMap、Hashtable、ConcurrentHashMap三者对比" class="headerlink" title="HashMap、Hashtable、ConcurrentHashMap三者对比"></a>HashMap、Hashtable、ConcurrentHashMap三者对比</h2><table><thead><tr><th>\</th><th><strong>HashMap</strong></th><th><strong>Hashtable</strong></th><th><strong>ConcurrentHashMap</strong></th></tr></thead><tbody><tr><td>是否线程安全</td><td>否</td><td>是</td><td>是</td></tr><tr><td>线程安全采用的方式</td><td></td><td>采用<code>synchronized</code>类锁，效率低</td><td>采用<code>CAS</code> + <code>synchronized</code>，锁住的只有当前操作的<strong>bucket</strong>，不影响其他线程对其他bucket的操作，效率高</td></tr><tr><td>数据结构</td><td>数组+链表+红黑树(链表长度超过8则转红黑树)</td><td>数组+链表</td><td>数组+链表+红黑树(链表长度超过8则转红黑树)</td></tr><tr><td>是否允许<code>null</code>键值</td><td>是</td><td>否</td><td>否</td></tr><tr><td>哈希地址算法</td><td>(key的hashCode)^(key的hashCode无符号右移16位)</td><td>key的hashCode</td><td>( (key的hashCode)^(key的hashCode无符号右移16位) )&amp;0x7fffffff</td></tr><tr><td>定位算法</td><td>哈希地址&amp;(容量大小-1)</td><td>(哈希地址&amp;0x7fffffff)%容量大小</td><td>哈希地址&amp;(容量大小-1)</td></tr><tr><td>扩容算法</td><td>当键值对数量大于阈值，则容量扩容到原来的2倍</td><td>当键值对数量大于等于阈值，则容量扩容到原来的2倍+1</td><td>当键值对数量大于等于sizeCtl，<strong>单线程创建新哈希表，多线程复制bucket到新哈希表</strong>，容量扩容到原来的2倍</td></tr><tr><td>链表插入</td><td>将新节点插入到链表<strong>尾部</strong></td><td>将新节点插入到链表<strong>头部</strong></td><td>将新节点插入到链表<strong>尾部</strong></td></tr><tr><td>继承的类</td><td>继承<code>abstractMap</code>抽象类</td><td>继承<code>Dictionary</code>抽象类</td><td>继承<code>abstractMap</code>抽象类</td></tr><tr><td>实现的接口</td><td>实现<code>Map</code>接口</td><td>实现<code>Map</code>接口</td><td>实现<code>ConcurrentMap</code>接口</td></tr><tr><td>默认容量大小</td><td>16</td><td>11</td><td>16</td></tr><tr><td>默认负载因子</td><td>0.75</td><td>0.75</td><td>0.75</td></tr><tr><td>统计size方式</td><td>直接返回成员变量<code>size</code></td><td>直接返回成员变量<code>count</code></td><td>遍历<code>CounterCell</code>数组的值进行累加，最后加上<code>baseCount</code>的值即为<code>size</code></td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://cmsblogs.com/?p=2283" target="_blank" rel="noopener">【死磕Java并发】—–J.U.C之Java并发容器：ConcurrentHashMap</a><br><a href="http://www.importnew.com/29832.html" target="_blank" rel="noopener">Map 大家族的那点事儿 ( 7 ) ：ConcurrentHashMap</a><br><a href="http://www.importnew.com/28263.html?tdsourcetag=s_pcqq_aiomsg&amp;replytocom=667559#respond" target="_blank" rel="noopener">Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析</a><br><a href="https://juejin.im/entry/59fc786d518825297f3fa968" target="_blank" rel="noopener">Java 8 ConcurrentHashMap源码分析</a>      </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;http://wx3.sinaimg.cn/large/e0e01e43ly1g0y4kkt2k3j21y013bb2b.jpg&quot; alt=&quot;image&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Java编程基础" scheme="http://ddnd.cn/categories/Java-Programming/"/>
    
    
      <category term="多线程" scheme="http://ddnd.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Hashtable" scheme="http://ddnd.cn/tags/Hashtable/"/>
    
      <category term="HashMap" scheme="http://ddnd.cn/tags/HashMap/"/>
    
      <category term="ConcurrentHashMap" scheme="http://ddnd.cn/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>五分钟看懂Hashtable源码以及与HashMap的区别</title>
    <link href="http://ddnd.cn/2019/03/08/jdk1-8-hashtable/"/>
    <id>http://ddnd.cn/2019/03/08/jdk1-8-hashtable/</id>
    <published>2019-03-08T07:51:16.000Z</published>
    <updated>2019-03-13T12:11:13.218Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><img src="http://ws3.sinaimg.cn/large/e0e01e43ly1g0vnl8sswvj21y013e7wl.jpg" alt="image" width="100%" data-width="2520" data-height="1418"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇<a href="https://ddnd.cn/2019/03/07/jdk1.8-hashmap/">HashMap从认识到源码分析</a>我们认识了什么是<code>Map</code>、<code>Hash</code>，了解了<code>Hash</code>处理哈希冲突的几种常用方法(拉链法、开放定址法)，以及分析了JDK1.8版本的<code>HashMap</code>源码，对Java集合框架有了初步的认识，我们本篇继续分析JDK1.8版本的<code>Hashtable</code>源码，最后比较<code>HashMap</code>和<code>Hashtable</code>的区别。 </p><h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><p>注意是Hashtable不是HashTable(t为小写)，这不是违背了驼峰定理了嘛？这还得从Hashtable的出生说起，Hashtable是在<code>Java1.0</code>的时候创建的，而集合的统一规范命名是在后来的<code>Java2</code>开始约定的，而当时又发布了新的集合代替它，所以这个命名也一直使用到现在，所以Hashtable是一个<strong>过时</strong>的集合了，不推崇大家使用这个类，虽说Hashtable是过时的了，我们还是有必要分析一下它，以便对Java集合框架有一个整体的认知。<br>首先<code>Hashtable</code>采用<strong>拉链法</strong>处理哈希冲突，是<strong>线程安全</strong>的，键值不允许为<code>null</code>，不保证顺序，然后Hashtable继承自Dictionary，实现Map接口，Hashtable有几个重要的成员变量<code>table</code>、<code>count</code>、<code>threshold</code>、<code>loadFactor</code></p><ul><li>table：是一个<code>Entry[]</code>数据类型，而<code>Entry</code>实际是一个单链表</li><li>count：Hashtable的大小，即Hashtable中保存的键值对数量</li><li>threshold：Hashtable的阈值，用于判断是否需要调整Hashtable的容量，threshold = 容量<em>负载因子</em>，threshold=11*0.75 取整即8</li><li>loadFactor：用来实现快速失败机制的<br><img src="http://ws1.sinaimg.cn/large/e0e01e43ly1g0vnltvf4xj20ct07fwei.jpg" alt="image"></li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><code>Hashtable</code>有4个构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//无参构造函数 默认Hashtable容量是11，默认负载因子是0.75</span><br><span class="line">public Hashtable() &#123;</span><br><span class="line">    this(11, 0.75f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//指定Hashtable容量，默认负载因子是0.75</span><br><span class="line">public Hashtable(int initialCapacity) &#123;</span><br><span class="line">    this(initialCapacity, 0.75f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//指定Hashtable的容量和负载因子</span><br><span class="line">public Hashtable(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor);</span><br><span class="line"></span><br><span class="line">    if (initialCapacity==0)</span><br><span class="line">        initialCapacity = 1;</span><br><span class="line">    this.loadFactor = loadFactor;</span><br><span class="line">    //new一个指定容量的Hashtable</span><br><span class="line">    table = new Entry&lt;?,?&gt;[initialCapacity];</span><br><span class="line">    //阈值threshold=容量*负载因子</span><br><span class="line">    threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//包含指定Map的构造函数</span><br><span class="line">public Hashtable(Map&lt;? extends K, ? extends V&gt; t) &#123;</span><br><span class="line">    this(Math.max(2*t.size(), 11), 0.75f);</span><br><span class="line">    putAll(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的Hashtable容量和HashMap的容量就有区别，Hashtable并不要求容量是2的幂次方，而HashMap要求容量是2的幂次方。负载因子则默认都是0.75。</p><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><p><code>put</code>方法是<strong>同步</strong>的，即线程安全的，这点和<code>HashMap</code>不一样，还有具体的<code>put</code>操作和<code>HashMap</code>也存在很大的差别，Hashtable插入的时候是插入到<strong>链表头部</strong>，而HashMap是插入到<strong>链表尾部</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">//synchronized同步锁，所以Hashtable是线程安全的</span><br><span class="line">public synchronized V put(K key, V value) &#123;</span><br><span class="line">    // Make sure the value is not null</span><br><span class="line">    //如果值value为空，则抛出异常 至于为什么官方不允许为空，下面给出分析</span><br><span class="line">    if (value == null) &#123;</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Makes sure the key is not already in the hashtable.</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    //直接取key的hashCode()作为哈希地址，这与HashMap的取hashCode()之后再进行hash()的结果作为哈希地址 不一样</span><br><span class="line">    int hash = key.hashCode();</span><br><span class="line">    //数组下标=(哈希地址 &amp; 0x7FFFFFFF) % Hashtable容量，这与HashMap的数组下标=哈希地址 &amp; (HashMap容量-1)计算数组下标方式不一样，前者是取模运算，后者是位于运算，这也就是为什么HashMap的容量要是2的幂次方的原因，效率上后者的效率更高。</span><br><span class="line">    int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    //遍历Entry链表，如果链表中存在key、哈希地址相同的节点，则将值更新，返回旧值</span><br><span class="line">    for(; entry != null ; entry = entry.next) &#123;</span><br><span class="line">        if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            V old = entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            return old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果为新的节点，则调用addEntry()方法添加新的节点</span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    //插入成功返回null</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void addEntry(int hash, K key, V value, int index) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    //如果当前键值对数量&gt;=阈值，则执行rehash()方法扩容Hashtable的容量</span><br><span class="line">    if (count &gt;= threshold) &#123;</span><br><span class="line">        // Rehash the table if the threshold is exceeded</span><br><span class="line">        rehash();</span><br><span class="line"></span><br><span class="line">        tab = table;</span><br><span class="line">        //获取key的hashCode();</span><br><span class="line">        hash = key.hashCode();</span><br><span class="line">        //重新计算下标，因为Hashtable已经扩容了。</span><br><span class="line">        index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Creates the new entry.</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    //获取当前Entry链表的引用 复赋值给e</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">    //创建新的Entry链表的 将新的节点插入到Entry链表的头部，再指向之前的Entry，即在链表头部插入节点，这个和HashMap在尾部插入不一样。</span><br><span class="line">    tab[index] = new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>hashCode()为什么要&amp; 0x7FFFFFFF呢？因为某些对象的hashCode()可能是负值，&amp; 0x7FFFFFFF保证了进行%运算时候得到的下标是个正数</p></blockquote><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p><code>get</code>方法也是同步的，和<code>HashMap</code>不一样,即线程安全，具体的<code>get</code>操作和<code>HashMap</code>也有区别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//同步</span><br><span class="line">public synchronized V get(Object key) &#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    //和put方法一样 都是直接获取key的hashCode()作为哈希地址</span><br><span class="line">    int hash = key.hashCode();</span><br><span class="line">    //和put方法一样 通过(哈希地址 &amp; 0x7FFFFFFF)与Hashtable容量做%运算 计算出下标</span><br><span class="line">    int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    //遍历Entry链表，如果链表中存在key、哈希地址一样的节点，则找到 返回该节点的值，否者返回null</span><br><span class="line">    for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123;</span><br><span class="line">        if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            return (V)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//同步</span><br><span class="line">public synchronized V remove(Object key) &#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    int hash = key.hashCode();</span><br><span class="line">    int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    //遍历Entry链表，e为当前节点，prev为上一个节点</span><br><span class="line">    for(Entry&lt;K,V&gt; prev = null ; e != null ; prev = e, e = e.next) &#123;</span><br><span class="line">        //找到key、哈希地址一样的节点</span><br><span class="line">        if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            //如果上一个节点不为空(即不是当前节点头结点)，将上一个节点的next指向当前节点的next，即将当前节点移除链表</span><br><span class="line">            if (prev != null) &#123;</span><br><span class="line">                prev.next = e.next;</span><br><span class="line">            &#125; else &#123; //如果上一个节点为空，即当前节点为头结点，将table数组保存的链表头结点地址改成当前节点的下一个节点</span><br><span class="line">                tab[index] = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            //Hashtable的键值对数量-1</span><br><span class="line">            count--;</span><br><span class="line">            //获取被删除节点的值 并且返回</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = null;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rehash方法"><a href="#rehash方法" class="headerlink" title="rehash方法"></a>rehash方法</h3><p>Hashtable的<code>rehash</code>方法和HashMap的<code>resize</code>方法一样，是用来扩容哈希表的，但是扩容的实现又有区别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">protected void rehash() &#123;</span><br><span class="line">    //获取旧的Hashtable的容量</span><br><span class="line">    int oldCapacity = table.length;</span><br><span class="line">    //获取旧的Hashtable引用，为旧哈希表</span><br><span class="line">    Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    //新的Hashtable容量=旧的Hashtable容量 * 2 + 1，这里和HashMap的扩容不一样，HashMap是新的Hashtable容量=旧的Hashtable容量 * 2。</span><br><span class="line">    int newCapacity = (oldCapacity &lt;&lt; 1) + 1;</span><br><span class="line">    //如果新的Hashtable容量大于允许的最大容量值(Integer的最大值 - 8)</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123;</span><br><span class="line">        //如果旧的容量等于允许的最大容量值则返回</span><br><span class="line">        if (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">            // Keep running with MAX_ARRAY_SIZE buckets</span><br><span class="line">            return;</span><br><span class="line">        //新的容量等于允许的最大容量值</span><br><span class="line">        newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    //new一个新的Hashtable 容量为新的容量</span><br><span class="line">    Entry&lt;?,?&gt;[] newMap = new Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    //计算新的阈值</span><br><span class="line">    threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</span><br><span class="line">    table = newMap;</span><br><span class="line">    //扩容后迁移Hashtable的Entry链表到正确的下标上</span><br><span class="line">    for (int i = oldCapacity ; i-- &gt; 0 ;) &#123;</span><br><span class="line">        for (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != null ; ) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = old;</span><br><span class="line">            old = old.next;</span><br><span class="line"></span><br><span class="line">            int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity;</span><br><span class="line">            e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">            newMap[index] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来我们执行以下代码，验证以下数据迁移过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Hashtable hashtable = new Hashtable();</span><br><span class="line">for (int i = 1; i &lt;= 24; i ++) &#123;</span><br><span class="line">    hashtable.put(String.valueOf(i), i);</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 25; i &lt;= 80; i ++) &#123;</span><br><span class="line">    hashtable.put(String.valueOf(i), i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>new</code>一个Hashtable，默认容量是<code>11</code>，负载因子是<code>0.75</code><br>执行第一个<code>for</code>循环后，<code>20</code>保存在下标为<code>0</code>的<code>Entry</code>中，即<code>(hash &amp;0x7FFFFFFF) % 容量 -&gt; (1598 &amp;0x7FFFFFFF) % 11 = 0</code><br><img src="http://wx1.sinaimg.cn/large/e0e01e43ly1g0vnm42jo8j20xd0nx76s.jpg" alt="image"></p><p>执行第二个<code>for</code>循环后，变成了<code>20</code>保存在下标为<code>70</code>的<code>Entry</code>中，因为Hashtable扩容了4次，分别是从容量为默认的11-&gt;23-&gt;47-&gt;95-&gt;191，然后此时容量是191，所以<code>(hash &amp;0x7FFFFFFF) % 容量 -&gt; (1598 &amp;0x7FFFFFFF) % 191 = 70</code><br><img src="http://wx1.sinaimg.cn/large/e0e01e43ly1g0vnmd81wyj20u40of0va.jpg" alt="image"></p><h2 id="HashMap和Hashtable区别"><a href="#HashMap和Hashtable区别" class="headerlink" title="HashMap和Hashtable区别"></a>HashMap和Hashtable区别</h2><p>到这里我们分析了HashMap和Hashtable的原理，现在比较以下他们的区别。  </p><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ul><li><strong>继承的类不一样</strong>：HashMap继承的<code>AbstractMap</code>抽象类，Hashtable继承的<code>Dictionay</code>抽象类</li><li><strong>应对多线程处理方式不一样</strong>：HashMap是非线程安全的，Hashtable是线程安全的，所以Hashtable效率比较低</li><li><strong>定位算法不一样</strong>：HashMap通过<code>key</code>的hashCode()进行hash()得到哈希地址，数组下标=哈希地址 &amp; (容量 - 1)，采用的是与运算，所以<strong>容量需要是2的幂次方结果才和取模运算结果一样</strong>。而Hashtable则是：数组下标=(key的hashCode() &amp; 0x7FFFFFFF ) % 容量，采用的取模运算，所以容量没要求</li><li><strong>键值对规则不一样</strong>：HashMap允许键值为<code>null</code>，而Hashtable不允许键值为<code>null</code></li><li><strong>哈希表扩容算法不一样</strong>：HashMap的容量扩容按照原来的容量*2，而Hashtable的容量扩容按照原来的容量*2+1</li><li><strong>容量(capacity)默认值不一样</strong>：HashMap的容量默认值为16，而Hashtable的默认值是11</li><li><strong>put方法实现不一样</strong>：HashMap是将节点插入到链表的尾部，而Hashtable是将节点插入到链表的头部</li><li><strong>底层结构不一样</strong>：HashMap采用了<strong>数组+链表+红黑树</strong>，而Hashtable采用<strong>数组+链表</strong></li></ul><blockquote><p>为什么HashMap允许<code>null</code>键值呢，而Hashtable不允许<code>null</code>键值呢？这里还得先介绍一下什么是<code>null</code>，我们知道Java语言中有两种类型，一种是<strong>基本类型</strong>还有一种是<strong>引用类型</strong>，其实还有一种特殊的类型就是<code>null</code>类型，它不代表一个对象(Object)也不是一个对象(Object)，然后在HashMap和Hashtable对键的操作中使用到了<strong>Object</strong>类中的<code>equals</code>方法，所以如果在Hashtable中置键值为<code>null</code>的话就可想而知会报错了，但是为什么HashMap可以呢？因为HashMap采用了特殊的方式，将<code>null</code>转为了对象(Object)，具体怎么转的，这里就不深究了。</p></blockquote><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul><li><strong>实现相同的接口</strong>：HashMap和Hashtable均实现了<code>Map</code>接口</li><li><strong>负载因子(loadFactor)默认值一样</strong>：HashMap和Hashtable的负载因子默认都是0.75</li><li><strong>采用相同的方法处理哈希冲突</strong>：都是采用链地址法即拉链法处理哈希冲突</li><li><strong>相同哈希地址可能分配到不同的链表，同一个链表内节点的哈希地址不一定相同</strong>：因为HashMap和Hashtable都会扩容，扩容后容量变化了，相同的哈希地址取到的数组下标也就不一样。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.yuanrengu.com/index.php/2017-01-17.html" target="_blank" rel="noopener">HashMap、HashTable、ConcurrentHashMap的原理与区别</a><br><a href="https://juejin.im/post/5a03b258518825188e515d89" target="_blank" rel="noopener">Java集合之Hashtable源码解析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;http://ws3.sinaimg.cn/large/e0e01e43ly1g0vnl8sswvj21y013e7wl.jpg&quot; alt=&quot;image&quot; width=&quot;100%&quot; data-width=&quot;2520&quot; 
      
    
    </summary>
    
      <category term="Java编程基础" scheme="http://ddnd.cn/categories/Java-Programming/"/>
    
    
      <category term="多线程" scheme="http://ddnd.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Hashtable" scheme="http://ddnd.cn/tags/Hashtable/"/>
    
  </entry>
  
  <entry>
    <title>HashMap从认识到源码分析</title>
    <link href="http://ddnd.cn/2019/03/07/jdk1.8-hashmap/"/>
    <id>http://ddnd.cn/2019/03/07/jdk1.8-hashmap/</id>
    <published>2019-03-07T07:58:20.000Z</published>
    <updated>2019-12-17T13:45:19.935Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><img src="http://wx3.sinaimg.cn/large/e0e01e43ly1g0vf2bq3xgj21g80ytkjm.jpg" alt="image" width="100%"></p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map在开发过程中使用频率很高的数据结构，Map是<code>Key-value</code>键值对映射的抽象<strong>接口</strong>，该映射不包括重复的键，既一个键对应一个值。<code>HashMap</code>、<code>HashTable</code>、<code>ConcurrentHashMap</code>都是Java Collection Framework的重要成员。Map接口提供三种collection视图，允许以键集(keySet())、值集(values())或键-值映射关系集(entrySet())的形式查看某个映射的内容。<br><img src="https://user-gold-cdn.xitu.io/2019/3/7/169575a7d1acb827?w=1018&amp;h=636&amp;f=png&amp;s=48415" alt=""></p><h2 id="HasH表"><a href="#HasH表" class="headerlink" title="HasH表"></a>HasH表</h2><p>我们知道数组的储存方式是在内存上分配固定的连续的空间，寻址速度快（查询速度快），时间复杂度为<code>O(1)</code>，但是在插入、删除元素时候需要移动数组的元素，所以插入、删除时候速度慢，时间复杂度为<code>O(n)</code>。链表的存储方式在内存上是不连续的，每个元素都保存着下个元素的内存地址，通过这个地址找到下个元素，所以链表在查询的时候速度慢，时间复杂度为<code>O(n)</code>，在插入和删除的时候速度快，时间复杂度为<code>O(1)</code>。<br>如果我们想要一个数据结构既查询速度快，插入和删除速度也要快，那我们应该怎么做呢？这时<strong>哈希(Hash)表</strong>就应时而生了，通过<strong>哈希函数</strong>计算出<strong>键</strong>在哈希表中指定的储存位置(注意这里的储存位置是在表中的位置，并不是内存的地址)，称为哈希地址，然后将值储存在这个哈希地址上，然后通过<strong>键</strong>就可以直接操作到<strong>值</strong>，查询、插入、删除等操作时间复杂度都是<code>O(1)</code>。<br>既然是键通过哈希函数计算出储存位置，那么哈希函数的好坏直接影响到哈希表的操作效率，如会出现浪费储存空间、出现大量冲突(即不同的键计算出来的储存位置一样)。     </p><blockquote><p>哈希函数可以将任意长度的输入映射成固定长度的输出，也就是哈希地址<br>哈希冲突是不可避免的，常用的哈希冲突解决办法有以下2种方法。            </p></blockquote><ol><li><strong>链地址法(拉链法)</strong><br>采用数组和链表结合的方法，对哈希表中每个哈希地址建立一个线性表，将哈希地址相同的数据储存在线性表中，并将<strong>链表的头指针保存在数组中</strong>，哈希地址、键、值等信息一般保存在链表节点中。一般通过哈希地址计算出数组的下标，将哈希值相同的保存在下标相同的数组中的。拉链法适合经常进行插入、删除操作的情况。<br><img src="https://user-gold-cdn.xitu.io/2019/3/7/16957dc37460bcb7?w=541&amp;h=336&amp;f=png&amp;s=15864" alt=""></li><li><strong>开放定址法</strong><br>开放定址法也称线性探测法，基本思想是：将哈希表T[0…m-1]看成是个循环向量，若初始探测地址为d，则最长的探测路径为：d，d+i，d+2i，…，m-1。即探测时候从地址d开始，首先探测T[d]，如果T[d]发生哈希冲突则继续探测下一个T[d+1]…直到探测到T[m-1]为止，i为自定义的常数。开放定址法很容易产生<strong>堆聚现象</strong>，所谓堆聚现象就是哈希表中的数据连成一片，在加入新元素的时候就容易产生哈希冲突。</li><li><strong>拉链法和开放定址比较</strong><br>拉链法：处理冲突简单，无堆聚现象，同时链表插入、删除操作简单，所以拉链法适合经常进行插入、删除操作的情况。<br>开放定址法：为了减少冲突，要求<strong>负载因子(装填因子)</strong>较小，当节点规模较大时候会浪费很多空间。且开放定址法在删除节点的时候，不能简单的将节点所在的空间置为空，否则将截断在它之后的节点的查找路径，这是因为各种开放定址法中，<strong>空地址单元都是查找失败的条件</strong>。因此在进行删除节点操作的时候，需要使用逻辑删除，即在被删除的节点上做删除标记。                   </li></ol><blockquote><p>负载因子 = 填入哈希表中的元素个数 / 哈希表的数组长度   </p></blockquote><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><code>HashMap</code>采用上述的<strong>拉链法</strong>解决哈希冲突.HashMap是非线程安全的，允许键、值为<code>null</code>，不保证有序(比如插入的顺序)，也不保证顺序不随时间变化(哈希表加倍扩容后，数据会有迁移)。<br>我们创建个HashMap运行看看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; map = new HashMap();</span><br><span class="line">map.put(&quot;语文&quot;, 1);</span><br><span class="line">map.put(&quot;数学&quot;, 2);</span><br><span class="line">map.put(&quot;英语&quot;, 3);</span><br><span class="line">map.put(&quot;历史&quot;, 4);</span><br><span class="line">map.put(&quot;政治&quot;, 5);</span><br><span class="line">map.put(&quot;地理&quot;, 6);</span><br><span class="line">map.put(&quot;生物&quot;, 7);</span><br><span class="line">map.put(&quot;化学&quot;, 8);</span><br></pre></td></tr></table></figure></p><p><img src="http://ws4.sinaimg.cn/large/e0e01e43ly1g0vezgvmdvj211l0jnq8d.jpg" alt="image"><br>通过图可以看到HashMap并不是按照插入顺序存储的(无序的)。<br>接下来我们看看HashMap的<strong>数据结构</strong><br><img src="http://ws2.sinaimg.cn/large/e0e01e43ly1g0vezylsa5j20he0dhwg2.jpg" alt="image"><br>HashMap有几个重要的成员变量，<code>table</code>，<code>size</code>，<code>threshold</code>，<code>loadFactor</code>，<code>modCount</code>。</p><ul><li>table：是一个<code>Entry[]</code>数组类型，而<code>Entry</code>实际上是一个<strong>单向链表</strong>，哈希表的键值对都是储存在<code>Entry</code>数组中，每个<code>Entry</code>对应一个哈希地址，这里的<code>Entry</code>即常说的桶</li><li>size：是HashMap的大小，为保存的键值对的数量</li><li>DEFAULT_INITIAL_CAPACITY：HashMap默认容量(数组的大小) 默认为16</li><li>MAXIMUM_CAPACITY：HashMap的最大容量(2的30)，如果传入的容量大于这个值，则被最大容量替换</li><li>threshold：是HashMap的阈值，用于判断是否需要调整HashMap的容量。threshold=容量*负载因子，当HashMap中储存的键值对数量到达threshold时，HashMap就会将容量<strong>加倍</strong>的扩容</li><li>loadFactor：即负载因子</li><li>modCount：用来实现<strong>快速失败(fail-fast)机制</strong>的<blockquote><p>快速失败机制：对于<strong>线程不安全</strong>(注意是线程不安全的集合才有这个机制)的集合对象的迭代器，如果在使用迭代器的过程中有其他的线程修改了集合对象的结构或者元素数量，那么迭代立刻结束，迭代器将抛出<code>ConcurrentModificationException</code>。</p></blockquote><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3>HashMap有4个构造函数，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//无参构造函数，负载因子为默认的0.75，HashMap的容量(数组大小)默认容量为16</span><br><span class="line">public HashMap() &#123;</span><br><span class="line">    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//指定HashMap容量大小的构造函数 负载因子为默认的0.75</span><br><span class="line">public HashMap(int initialCapacity) &#123;</span><br><span class="line">    this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//指定HashMap容量大小和负载因子的构造函数</span><br><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    this.loadFactor = loadFactor;</span><br><span class="line">    this.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//包含子Map的构造函数，负载因子为默认的0.75</span><br><span class="line">public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">    this.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>为什么负载因子默认是0.75？按照官方给出的解释是，当负载因子为0.75时候，<code>Entry</code>单链表的长度几乎不可能超过<code>8</code>(到达8的概率是0.00000006)，作用就是让<code>Entry</code>单链表的长度尽量小，让HashMap的查询效率尽可能高。</p></blockquote><p>由于当HashMap的大小(即size)大于初始容量(capacity)时候，HashMap就会扩大一倍，由于很多时候并不需要扩大这么多，所以当我们知道我们的数据的大小的时候，就可以在HashMap初始化的时候指定容量(数组大小)。<br>需要注意的是，我们指定的容量必须是<strong>2的幂次方</strong>，即使我们传入的容量不是2的幂次方，源码中也会将容量转成2的幂次方，比如我们传入的是5，最终的容量是8。</p><blockquote><p>为什么容量一定要是2的幂次方？因为HashMap是数组+单链表的结构，我们希望元素的存放的更均匀，最理想的状态是每个<code>Entry</code>中只存放一个元素，这样在查询的时候效率最高。那怎么才能均匀的存放呢？我们首先想到的是取模运算 哈希地址%容量大小，SUN的大师们的想法和我们的也一样，只不过他们使用位运算来实现这个运算(位运算效率高)，为了使位运算和取模运算结果一样，即<code>hash &amp; (capacity - 1) == hash % capacity</code>，容量(Capacity)的大小就必须为2的幂次方。</p></blockquote><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><p>在JDK1.8之前hashMap的插入是在链表的头部插入的，本文分析的是JDK1.8源码，是在链表的尾部插入的。     </p><ol><li>根据键(key)的<code>hashCode()</code>计算出当前键值对的<strong>哈希地址</strong>，用于定位键值对在HashMap数组中存储的下标</li><li>判断<code>table</code>是否初始化，没有初始化则调用<code>resize()</code>为<code>table</code>初始化容量，以及threshold的值</li><li>根据<strong>table数组长度和哈希地址做&amp;运算(i = (n - 1) &amp; hash)</strong>计算出该key对应的<code>table</code>数组索引，如果对应的数组索引位置没有值，则调用<code>newNode(hash, key, value, null)</code>方法，为该键值对创建节点。<blockquote><p>这里思考个问题，当table数组长度变化后，是不是取到的值就不正确了？后面给出分析。这里简单分析下为什么不是直接按照哈希地址做数组下标，而是用<strong>table数组长度和哈希地址做&amp;运算(i = (n - 1) &amp; hash)</strong>(因为数组的大小是2的幂次方，所以这个运算等效于mod 数组大小的运算)计算数组下标，因为哈希地址可能超过数组大小，还有就是为了让键值对更均匀的分布的在各个桶(链表)中，也因为容量会变所以各个桶(链表)中的节点的哈希地址并不是相同的，相同的哈希地址也可能分到不同的下标。</p></blockquote></li><li>如果根据哈希地址计算出该key对应的<code>table</code>数组索引有节点，且节点的键<code>key</code>和传入的键<code>key</code>相等，哈希地址和传入的哈希地址也相等，<strong>则将对应的节点引用赋值给e</strong>。</li><li>如果根据哈希地址计算出该key对应的<code>table</code>数组索引有节点，且节点的哈希地址和传入的哈希地址一样，但是节点的键<code>key</code>和传入的键<code>key</code>不相等，则遍历链表，如果遍历过程中找到节点的键<code>key</code>和传入的键<code>key</code>相等，哈希地址和传入的哈希地址也相等，则将对应的<code>value</code>值更新。否则调用<code>newNode(hash, key, value, null)</code>方法，为该键值对创建节点添加到链表<strong>尾部</strong>，如果追加节点后的链表长度 &gt;= 8，则转为红黑树</li><li>如果e不为空，且<code>onlyIfAbsent</code>为<code>true</code>则不会覆盖相同<code>key</code>和相同哈希地址的<code>value</code>。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果参数onlyIfAbsent是true，那么不会覆盖相同key的值value。如果evict是false。那么表示是在初始化时调用的</span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    //tab存放 当前的哈希桶， p用作临时链表节点  </span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    //如果当前哈希表是空的，代表是初始化</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        //那么直接去扩容哈希表，并且将扩容后的哈希桶长度赋值给n</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    //如果当前index的节点是空的，表示没有发生哈希碰撞。 直接构建一个新节点Node，挂载在index处即可。</span><br><span class="line">    //这里再啰嗦一下，数组下标index 是利用 哈希地址 &amp; 哈希桶的长度-1，替代模运算</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123;//否则 发生了哈希冲突。</span><br><span class="line">        //e</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        //如果哈希值相等，key也相等，则是覆盖value操作</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;//将当前节点引用赋值给e</span><br><span class="line">        else if (p instanceof TreeNode)//红黑树暂且不谈</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123;//不是覆盖操作，则插入一个普通链表节点</span><br><span class="line">            //遍历链表</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                if ((e = p.next) == null) &#123;//遍历到尾部，追加新节点到尾部</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    //如果追加节点后，链表数量》=8，则转化为红黑树</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //如果找到了要覆盖的节点</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果e不是null，说明有需要覆盖的节点，</span><br><span class="line">        if (e != null) &#123; // existing mapping for key</span><br><span class="line">            //则覆盖节点值，并返回原oldValue</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            //这是一个空实现的函数，用作LinkedHashMap重写使用。</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果执行到了这里，说明插入了一个新的节点，所以会修改modCount，以及返回null。</span><br><span class="line"></span><br><span class="line">    //修改modCount</span><br><span class="line">    ++modCount;</span><br><span class="line">    //更新size，并判断是否需要扩容。</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    //这是一个空实现的函数，用作LinkedHashMap重写使用。</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>hashCode()是Object类的一个方法，hashCode()方法返回对象的hash code，这个方法是为了更好的支持hash表，比如Set、HashTable、HashMap等。hashCode()的作用：如果用equals去比较的话，如果存在1000个元素，你new一个新的元素出来，需要去调用1000次equals去逐个和它们比较是否是同一个对象，这样会大大降低效率。ashcode实际上是返回对象的存储地址，如果这个位置上没有元素，就把元素直接存储在上面，如果这个位置上已经存在元素，这个时候才去调用equal方法与新元素进行比较，相同的话就不存了，散列到其他地址上。</p></blockquote><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><ol><li><code>table</code>不为空，且<code>table</code>的长度大于0，且根据键<code>key</code>的<code>hashCode()</code>计算出<strong>哈希地址</strong>，再<strong>根据桶的数量-1和哈希地址做&amp;运算</strong>计算出数组的下标，该下标下不为空(即存有链表头指针)则继续往下进行，否则返回<code>null</code>。</li><li>如果和第一个节点的哈希地址、键<code>key</code>都相同，则返回第一个节点。</li><li>如果第一个节点的下个节点不为空，则继续，如果第一个节点为树的节点，则执行<code>getTreeNode(hash, key)</code>，在树中寻找节点，并且返回。否则遍历链表，找到键<code>key</code>、哈希地址一样的则返回此节点。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        if (first.hash == hash &amp;&amp; // 如果索引到的第一个Node，key 和 hash值都和传递进来的参数相等，则返回该Node</span><br><span class="line">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        if ((e = first.next) != null) &#123; //如果索引到的第一个Node 不符合要求，循环变量它的下一个节点。</span><br><span class="line">            if (first instanceof TreeNode) // 在树中get</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            do &#123;// 在链表中get</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><ol><li><code>table</code>不为空，且<code>table</code>的长度大于0，且根据键<code>key</code>的<code>hashCode()</code>计算出<strong>哈希地址</strong>，再根据哈希地址计算出数组的下标，该下标下不为空(即存有链表头指针)则继续往下进行，否则执行6`。</li><li>如果哈希地址、键<code>key</code>一样，<strong>则将对应的节点引用赋值给node</strong>，然后执行4。否则执行3。</li><li>如果为树，则执行<code>getTreeNode(hash, key)</code>在树中寻找节点并且返回，否则遍历链表，找到键<code>key</code>、哈希地址一样的节点然后<strong>将对应的节点引用赋值给node</strong>，然后执行4，否则执行6。</li><li>如果节点<code>node</code>不为空(即查询到键<code>key</code>对应的节点)，且当<code>matchValue</code>为<code>false</code>的时候或者<code>value</code>也相等的时候，则执行5，否则执行6。</li><li>如果节点为树，则调用<code>removeTreeNode(this, tab, movable)</code>移除相应的节点。否则在链表中移除相应的节点，</li><li>返回<code>null</code>。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = removeNode(hash(key), key, null, false, true)) == null ?</span><br><span class="line">        null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,</span><br><span class="line">                           boolean matchValue, boolean movable) &#123;</span><br><span class="line">    // p 是待删除节点的前置节点</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;</span><br><span class="line">    //如果哈希表不为空，则根据hash值算出的index下 有节点的话。</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        //node是待删除节点</span><br><span class="line">        Node&lt;K,V&gt; node = null, e; K k; V v;</span><br><span class="line">        //如果链表头的就是需要删除的节点</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;//将待删除节点引用赋给node</span><br><span class="line">        else if ((e = p.next) != null) &#123;//否则循环遍历 找到待删除节点，赋值给node</span><br><span class="line">            if (p instanceof TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            else &#123;</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; while ((e = e.next) != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果有待删除节点node，  且 matchValue为false，或者值也相等</span><br><span class="line">        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != null &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            if (node instanceof TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);</span><br><span class="line">            else if (node == p)//如果node ==  p，说明是链表头是待删除节点</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            else//否则待删除节点在表中间</span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;//修改modCount</span><br><span class="line">            --size;//修改size</span><br><span class="line">            afterNodeRemoval(node);//LinkedHashMap回调函数</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="containsKey方法"><a href="#containsKey方法" class="headerlink" title="containsKey方法"></a>containsKey方法</h3><p>如果存在指定的键<code>key</code>，返回true，否则返回false。<br>containsKey方法调用的get调用的方法一样的方法，参考get方法的解析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean containsKey(Object key) &#123;</span><br><span class="line">    return getNode(hash(key), key) != null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="哈希表的初始化和加倍扩容resize方法"><a href="#哈希表的初始化和加倍扩容resize方法" class="headerlink" title="哈希表的初始化和加倍扩容resize方法"></a>哈希表的初始化和加倍扩容resize方法</h3><p>分析resize方法，我们就可以知道为什么哈希表的容量变化后，仍然能取到正确的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    //如果哈希表是空的 则将旧容量置为0，否则置为旧哈希表的容量</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    //旧的哈希表的阈值</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    //新的哈希表的容量和阈值 都置为0</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    //如果旧的容量大于0 即不是第一次初始化 是扩容操作</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        //旧的容量是否大于2的30次幂方(容量的最大值)</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            //阈值设置为Integer的最大值</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            //返回旧的哈希表(旧的哈希表已经到最大的容量了，不能继续扩容 所以返回)</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        //新的哈希表容量的=旧的容量&lt;&lt;1，即新的容量=旧的2倍，如果新的容量小于2的30次幂方(容量的最大值) 且 旧的容量大于等于默认的容量(16)</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            //新的哈希表的阈值=旧的哈希表的阈值&lt;&lt;1，既即新的阈值=旧的2倍 扩容table</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    //第一次初始化，如果旧的阈值&gt;0 即HashMap是以传入容量大小或者传入容量大小、负载因子的构造函数进行初始化的，阈值threshlod已经在构造函数初始化过了，所以阈值在这里大于0</span><br><span class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">        //新的容量=旧的阈值</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    //如果是以无参构造函数进行初始化的，则 新的容量大小=默认的容量大小，新的阈值=默认的负载因子*默认的容量大小</span><br><span class="line">    else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    //新的阈值=0，即执行的是上面的else if (oldThr &gt; 0)(使用带参数的构造函数初始化)，是使用带参数的构造函数进行的初始化，并且计算出新的阈值</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">    //创建新的哈希表，容量为新的容量</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    //重点看这部分，如果旧的哈希表不为空</span><br><span class="line">    if (oldTab != null) &#123;</span><br><span class="line">        //遍历旧的哈希表，</span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            //如果旧的哈希表的节点不为空</span><br><span class="line">            if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                oldTab[j] = null;</span><br><span class="line">                //如果节点没有下个节点了(即只有一个节点)，则直接放到新的哈希表中</span><br><span class="line">                if (e.next == null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                else &#123; // preserve order</span><br><span class="line">                    //将旧的哈希表的节点全部重新定位，比如旧的哈希表容量是16，有一个值a放在数组下标为0上，现在新的哈希表容量是32，重新定位后值a就被重新定位到下标为32上，即新的哈希表的下标为32储存值a，简单来说就是 新的下标=旧的哈希表的下标+旧的哈希表的容量，正是因为这个节点的迁移，所以我们在hashMap put get操作的时候，在哈希表容量变化后仍让取到正确的值，但是也因为这个迁移操作，</span><br><span class="line">                    会消耗很多资源，所以尽量在创建HashMap的时候就估计哈希表的容量，尽量不要让他加倍扩容。这里的迁移也都是运用的位运算，所以在初始化的时候，桶的数量必须是2</span><br><span class="line">                    幂次方，才能保证位运算和取模运算结果一样。</span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                            if (loTail == null)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail == null)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e = next) != null);</span><br><span class="line">                    if (loTail != null) &#123;</span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (hiTail != null) &#123;</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以运行个例子，调试看看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; map = new HashMap();</span><br><span class="line">for (int i = 1; i &lt;= 24; i ++) &#123;</span><br><span class="line">    map.put(String.valueOf(i), i);</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 25; i &lt;= 80; i ++) &#123;</span><br><span class="line">    map.put(String.valueOf(i), i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们以无参构造函数(即哈希表容量默认是16，负载因子默认是0.75)<code>new</code>一个HashMap，然后调试看看</p><p><img src="http://ws4.sinaimg.cn/large/e0e01e43ly1g0vf07q9plj20vt0ldacm.jpg" alt="image"><br>运行第一个<code>for</code>循环，看到<code>11</code>保存的下标为0，<code>12</code>保存的下标是1<br>在继续运行第二个<code>for</code>，发现下标为0的变成了44，下标为1的变成了45<br><img src="http://wx4.sinaimg.cn/large/e0e01e43ly1g0vf0g8sq8j20q10netbf.jpg" alt="image"><br>那我们的11和12保存在哪了？可以发现11和12到了下标为32、33上，即当执行第二个<code>for</code>的时候哈希表发生了扩容，然后节点都迁移了，新的下标=旧的下标+旧的哈希表的容量<br><img src="http://ws2.sinaimg.cn/large/e0e01e43ly1g0vf0lbaphj20fo0b0ab8.jpg" alt="image"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://user-gold-cdn.xitu.io/2019/3/8/1695c2ad3c842d8a" target="_blank" rel="noopener">Java HashMap工作原理及实现</a><br><a href="https://blog.csdn.net/justloveyou_/article/details/62893086" target="_blank" rel="noopener">Map 综述（一）：彻头彻尾理解 HashMap</a>      </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;http://wx3.sinaimg.cn/large/e0e01e43ly1g0vf2bq3xgj21g80ytkjm.jpg&quot; alt=&quot;image&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Map&quot;&gt;
      
    
    </summary>
    
      <category term="Java编程基础" scheme="http://ddnd.cn/categories/Java-Programming/"/>
    
    
      <category term="HashMap" scheme="http://ddnd.cn/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>计算机如何储存数字和字符</title>
    <link href="http://ddnd.cn/2019/02/16/byte-hex-ascii/"/>
    <id>http://ddnd.cn/2019/02/16/byte-hex-ascii/</id>
    <published>2019-02-16T03:46:40.000Z</published>
    <updated>2019-03-13T11:11:13.336Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><img src="http://ws3.sinaimg.cn/large/e0e01e43gy1g08660xgavj20sg0lc43a.jpg" alt="image" width="100%"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在学习中涉及到计算机储存、传输数字和字符等操作，由于对字节、<code>2</code>进制、<code>10</code>进制、<code>16</code>进制、ASCII码的概念以及它们之间的关系和转换理解的不够透彻，导致在通讯、<code>MD5</code>消息摘要算法等时候出现问题，是因为<strong>数据</strong>转成<strong>计算机认识的01</strong>的这个环节出现问题。由于这个问题并不是那么容易发现，所以我也算是花了挺多时间才解决了这个问题，记录下解决过程，顺便也当复习一下计算机组成原理。</p><h2 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h2><p>在计算机中，所有的数据在存储和运算时都要使用<strong>二进制数</strong>表示（因为计算机用高电平和低电平分别表示1和0），例如，像a、b、c、d这样的52个字母（包括大写）以及0、1等数字还有一些常用的符号（例如*、#、@等）在计算机中存储时也要使用二进制数来表示，而具体用哪些二进制数字表示哪个符号，当然每个人都可以约定自己的一套（这就叫编码），而大家如果要想互相通信而不造成混乱，那么大家就必须使用相同的编码规则，于是美国有关的标准化组织就出台了ASCII编码，统一规定了上述常用符号用哪些二进制数来表示。<br>ASCII 码一共规定了<code>128</code>个字符（<code>0000 0000</code>-<code>0111 1111</code>）的编码，比如空格<code>SPACE</code>是32（二进制<code>0010 0000</code>），大写的字母<code>A</code>是65（二进制<code>0100 0001</code> ）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位（低7位），最前面的一位（高1位）统一规定为<code>0</code>(不要和数字的符号位搞混)。<br>当然除了ASCII码，还有UTF-8、GBK等。</p><h2 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h2><p>字节(Byte)普通计算机系统能读取和定位到最小信息单位，即我们通过计算机储存和传输数据的时候都是先把数据转成字节。<br>字节即<code>Byte</code>，一个字节代表<code>8</code>个比特（Bit），字节通常缩写为B，比特通常缩写为b。字节的大小是<code>8</code>Bit，即字节的范围是<code>0000 0000</code> - <code>1111 1111</code>，对于<strong>无符号型</strong>，它表示的十进制范围是[0,255]，对于<strong>有符号型</strong>，高一位表示符号位，它表示的十进制范围是[-128,127]。</p><h2 id="计算机若何储存数据"><a href="#计算机若何储存数据" class="headerlink" title="计算机若何储存数据"></a>计算机若何储存数据</h2><p>计算机只认识<code>0</code>和<code>1</code>（因为计算机只有高低电平两个状态），数据要想通过计算机储存或者传输，首先是要把数据转成计算机能认识的格式即01数据。<br>我们举个例子，以储存十进制数字<code>28</code>和<code>-28</code>为例，首先将十进制数转成二进制。    </p><blockquote><p><strong>需要注意的是：</strong> 数字在计算机中储存的是补码，而字符是在计算机中储存的是字符对应的编码（不要和数字的补码搞混）。</p></blockquote><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>储存十进制数字<code>28</code>和<code>-28</code>为例，首先将十进制数转成二进制，高<code>1</code>位为<code>0</code>代表正数，为<code>1</code>代表负数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">28(10) = 0001 1100(2)(原码)            </span><br><span class="line">-28(10) = 1001 1100(2)(原码)</span><br></pre></td></tr></table></figure></p><p>然后计算机将二进制数字进行补码运算，运算结果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">28(10) = 0001 1100(2)(原码) =  0001 1100(2)(补码)       </span><br><span class="line">-28(10) = 1001 1100(2)(原码) = 1110 0100(2)(补码)</span><br></pre></td></tr></table></figure></p><p>然后计算机保存的就是<strong>补码</strong>，当要取出数据的时候，就将补码逆运算一下，即可求出原码，再将原码转换一下就可以得到真实的数据了。<br>下面以Java语言演示这个过程，首先我们要清楚Java的byte、short、int、long都是有符号的(signed)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) throws NoSuchAlgorithmException &#123;</span><br><span class="line">        int a1 = 28;</span><br><span class="line">        int a2 = -28;</span><br><span class="line"></span><br><span class="line">//        转成二进制表示</span><br><span class="line">        String b1 = Integer.toBinaryString(a1);</span><br><span class="line">        String b2 = Integer.toBinaryString(a2);</span><br><span class="line">//        转成无无符号表示</span><br><span class="line">        String b3 = Integer.toUnsignedString(a1);</span><br><span class="line">        String b4 = Integer.toUnsignedString(a2);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;28储存到计算机后为：&quot; + b1);</span><br><span class="line">        System.out.println(&quot;-28储存到计算机后为：&quot; + b2);</span><br><span class="line">        System.out.println(&quot;取出储存的28 以无符号表示：&quot; + b3);</span><br><span class="line">        System.out.println(&quot;取出储存的-28 以无符号表示：&quot; + b4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">28储存到计算机后为：11100</span><br><span class="line">-28储存到计算机后为：11111111111111111111111111100100</span><br><span class="line">取出储存的28 以无符号表示：28</span><br><span class="line">取出储存的-28 以无符号表示：4294967268</span><br></pre></td></tr></table></figure></p><p>我们验证一下结果，验证了计算机确实是以补码的方式储存数字。这里有个小问题，就是我们知道<code>int</code>型有<code>4</code>个字节即<code>32</code>个比特，但是28却输出了<code>11100</code>5个比特而已，是因为<code>toBinaryString()</code>方法把<code>11100</code>前面的<code>0</code>给忽略了。<br>取出的时候，我们以无符号的标准去处理，导致取出存入的<code>-28</code>结果是<code>4294967268</code>和我们存入的不一样，这是因为<code>-28</code>是负数，负数的补码和原码不一样，而用无符号处理的话就是直接将<code>11111111111111111111111111100100</code>转成结果了。而为什么<code>28</code>用有无符号处理结果都一样是因为正数的原码和补码一样，这样验证了Java的数据类型都是有符号的。   </p><p><strong>至于计算机为什么用补码来储存数字，而不是原码，原因是：</strong><br>拿单字节整数来说，无符号型，其表示范围是[0,255]，总共表示了<code>256</code>个数据。有符号型，其表示范围是[-128,127]。<br>先看无符号，原码和补码都一样，<code>0</code>表示为<code>0000 0000</code>，<code>255</code>表示为<code>1111 1111</code>，刚好满足了要求，可以表示<code>256</code>个数据。<br>再看有符号的，若是用<strong>原码</strong>表示，<code>0</code>表示为<code>0000 000</code>。因为咱们有符号，所以应该也有个<strong>负0</strong>（虽然它还是0）<code>1000 0000</code>。这样的话那就有2个0，也就是只能表示<code>255</code>个数据，不能够满足我们的要求。而用补码则很好的解决了这个问题。    </p><h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><p>在计算机中，对<strong>非数值</strong>的字符进行处理时，要对字符进行数字化，即用二进制编码来表示字符。其中西文字符最常用到的编码方案有ASCII编码和EBCDIC编码。对于汉字，我国也制定的相应的编码方案，比如 GBK，GB2312等。<br>比如字符<code>a</code>的<code>ASCII</code>码十进制值为<code>97</code>，在计算机中用二进制表示就是 01100001。下面同样用Java来演示计算机是如何储存字符的。  </p><ol><li>采用UTF-8和GBK两种编码储存汉字</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) throws NoSuchAlgorithmException &#123;</span><br><span class="line">        String a1 = &quot;中&quot;;</span><br><span class="line">//        采用两种不同的编码储存&quot;中&quot;这个汉字 比较两种编码</span><br><span class="line">        byte[] b1 = a1.getBytes(&quot;GBK&quot;);</span><br><span class="line">        byte[] b2 = a1.getBytes(&quot;UTF-8&quot;);</span><br><span class="line">        String c1 = binary(b1,2);</span><br><span class="line">        String c2= binary(b2,2);</span><br><span class="line">        System.out.println(&quot;GBK储存对应的二进制：&quot; + c1);</span><br><span class="line">        System.out.println(&quot;UTF-8储存对应的二进制：&quot; +c2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 将byte[]转为各种进制的字符串</span><br><span class="line">     * @param bytes byte[]</span><br><span class="line">     * @param radix 基数可以转换进制的范围，从Character.MIN_RADIX到Character.MAX_RADIX，超出范围后变为10进制</span><br><span class="line">     * @return 转换后的字符串</span><br><span class="line">     */</span><br><span class="line">    public static String binary(byte[] bytes, int radix)&#123;</span><br><span class="line">        return new BigInteger(1, bytes).toString(radix);// 这里的1代表正数</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ws4.sinaimg.cn/large/e0e01e43gy1g08enhtsx1j213s0jjtby.jpg" alt="image"><br>我们调试看看，发现GBK编码采用<code>2</code>个字节储存，储存的数据分别是<code>10</code>进制的<code>-42</code>和<code>-48</code>对应的二进制分别是<code>11010110</code>和<code>11010000</code>(补码)，即汉字<code>中</code>对应的二进制为<code>1101011011010000</code>，即16进制的<code>D6D0</code>，查看GBK对照表，发现16进制编码<code>D6D0</code>对应的汉字确实是<code>中</code><br><img src="http://wx4.sinaimg.cn/large/e0e01e43gy1g08f28qjz1j214b0gbgni.jpg" alt="image"></p><p>而UTF-8编码采用<code>3</code>个字节储存，同理将对应的二进制<code>111001001011100010101101</code>转成16进制，为E4B8AD，通过UTF-8编码查询，发现汉字<code>中</code>对应的16进制编码确实是<code>E4B8AD</code><br><img src="http://wx2.sinaimg.cn/large/e0e01e43gy1g08f7puifrj21910af3z7.jpg" alt="image"></p><ol start="2"><li>储存字符</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) throws NoSuchAlgorithmException &#123;</span><br><span class="line">        String a1 = &quot;EF&quot;;</span><br><span class="line">//        将字符串转成字节数组</span><br><span class="line">        byte[] b1 = a1.getBytes();</span><br><span class="line">        String c1 = binary(b1,2);</span><br><span class="line">        System.out.println(&quot;对应的二进制：&quot; + c1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 将byte[]转为各种进制的字符串</span><br><span class="line">     * @param bytes byte[]</span><br><span class="line">     * @param radix 基数可以转换进制的范围，从Character.MIN_RADIX到Character.MAX_RADIX，超出范围后变为10进制</span><br><span class="line">     * @return 转换后的字符串</span><br><span class="line">     */</span><br><span class="line">    public static String binary(byte[] bytes, int radix)&#123;</span><br><span class="line">        return new BigInteger(1, bytes).toString(radix);// 这里的1代表正数</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ws2.sinaimg.cn/large/e0e01e43gy1g08fxhd6efj214r0i3tau.jpg" alt="image"><br>调试看看，字符串<code>EF</code>有<code>E</code>和<code>F</code>两个字符，它们对应的十进制ASCII码分别是<code>69</code>和<code>70</code><br><img src="http://ws2.sinaimg.cn/large/e0e01e43gy1g08g0ta24uj20fq0c10tg.jpg" alt="image"></p><p>我们发现Java的<code>getBytes()</code>方法是将字符串的每一个字符都储存到一个字节的，如果我们想把<code>EF</code>储存在一个字节里面，即<code>EF</code>是一个整体的，一个字节，不能拆分，那我们可以把<code>EF</code>放在一个字节里面<code>(byte)(0xEF)</code>，声明它是一个字节，不是字符，不用再将它转成字符对应的编码。<br>下面说说我在进行<code>MD5</code>消息摘要算法时候遇到的坑，我要对QQ号对应的Hex进行<code>MD5</code>算法散列，这里我举例QQ号的<code>10</code>进制为<code>12345678</code>，对应的<code>16</code>进制为<code>00BC614E</code>(因为QQ号固定长度4个字节，所以前面补了2个0)，一开始我是以下面的方式进行<code>MD5</code>算法的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) throws NoSuchAlgorithmException &#123;</span><br><span class="line">        String qq = &quot;00BC614E&quot;;</span><br><span class="line">//        将字符串转成字节数组</span><br><span class="line">        byte[] b1 = qq.getBytes();</span><br><span class="line"></span><br><span class="line">        MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);</span><br><span class="line">        md.update(b1);</span><br><span class="line">//        得到MD5后的哈希值</span><br><span class="line">        byte[] hash = md.digest();</span><br><span class="line">//        将结构转成16进制</span><br><span class="line">        String c1 = binary(hash,16);</span><br><span class="line">        System.out.println(&quot;对应的16进制：&quot; + c1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 将byte[]转为各种进制的字符串</span><br><span class="line">     * @param bytes byte[]</span><br><span class="line">     * @param radix 基数可以转换进制的范围，从Character.MIN_RADIX到Character.MAX_RADIX，超出范围后变为10进制</span><br><span class="line">     * @return 转换后的字符串</span><br><span class="line">     */</span><br><span class="line">    public static String binary(byte[] bytes, int radix)&#123;</span><br><span class="line">        return new BigInteger(1, bytes).toString(radix);// 这里的1代表正数</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://ws4.sinaimg.cn/large/e0e01e43gy1g08izqbof9j213w0npjva.jpg" alt="image"><br>调试可以看到上面的代码其实是将字符串<code>00BC614E</code>转成了<code>8</code>个字节，然后再对这8个字节进行散列，这也是基于<strong>字符串</strong>进行的<code>MD5</code>散列，和通过网上一些网站散列得到的值是一样的<br><img src="http://wx3.sinaimg.cn/large/e0e01e43gy1g08j73hvayj21g40jgn3x.jpg" alt="image"></p><p>但是这个哈希值和预想的结果不一致，后来才知道预想的结果是基于<strong>字节</strong>进行的<code>MD5</code>散列，也就是<code>00BC614E</code>应该分成<code>4</code>个字节（00、BC、61、4E）而不是<code>8</code>个字节（0、0、B、C、6、1、4、E），然后通过修改代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) throws NoSuchAlgorithmException &#123;</span><br><span class="line">//        String qq = &quot;00BC614E&quot;;</span><br><span class="line">//        将字符串转成字节数组</span><br><span class="line">//        byte[] b1 = qq.getBytes();</span><br><span class="line">        byte[] b1 = &#123;(byte)(0x00),(byte)(0xBC),(byte)(0x61),(byte)(0x4E)&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);</span><br><span class="line">        md.update(b1);</span><br><span class="line">//        得到MD5后的哈希值</span><br><span class="line">        byte[] hash = md.digest();</span><br><span class="line">//        将结构转成16进制</span><br><span class="line">        String c1 = binary(hash,16);</span><br><span class="line">        System.out.println(&quot;对应的16进制：&quot; + c1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 将byte[]转为各种进制的字符串</span><br><span class="line">     * @param bytes byte[]</span><br><span class="line">     * @param radix 基数可以转换进制的范围，从Character.MIN_RADIX到Character.MAX_RADIX，超出范围后变为10进制</span><br><span class="line">     * @return 转换后的字符串</span><br><span class="line">     */</span><br><span class="line">    public static String binary(byte[] bytes, int radix)&#123;</span><br><span class="line">        return new BigInteger(1, bytes).toString(radix);// 这里的1代表正数</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://ws1.sinaimg.cn/large/e0e01e43gy1g08jiea66vj213d0njadu.jpg" alt="image"><br>使用<code>(byte)</code>声明是一个字节，不是字符，不用再将它转成字符对应的编码。00、BC、61、4E分别是一个字节，当然因为字节为<code>8</code>个比特，能表示256个数字，因为Java的数据类型是有符号的，所以<code>8</code>个比特能表示的<code>10</code>进制范围是[-128,127]，所以(byte)(x) x不能小于<code>-128</code>和不能大于<code>127</code>，否则会溢出，溢出的部分数据会丢失。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;http://ws3.sinaimg.cn/large/e0e01e43gy1g08660xgavj20sg0lc43a.jpg&quot; alt=&quot;image&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="计算机基础" scheme="http://ddnd.cn/categories/Computer-Foundation/"/>
    
    
  </entry>
  
  <entry>
    <title>第三章 Redis 客户端的使用 Java版【Redis入门教程】</title>
    <link href="http://ddnd.cn/2019/02/15/redis-chapter-3/"/>
    <id>http://ddnd.cn/2019/02/15/redis-chapter-3/</id>
    <published>2019-02-15T04:35:11.000Z</published>
    <updated>2019-03-13T11:12:57.668Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><img src="http://ws1.sinaimg.cn/large/e0e01e43gy1fzz559f0n2j21d80gf3zh.jpg" alt="image" width="100%"></p><p><strong>Redis入门教程目录</strong>：<a href="https://ddnd.cn/categories/Redis/">【Redis入门教程目录】</a></p><h2 id="Redis客户端"><a href="#Redis客户端" class="headerlink" title="Redis客户端"></a>Redis客户端</h2><p>我们知道Redis是<code>C</code>语言开发的，如果想用别的语言操作Redis，那就需要用到别的语言的客户端。我们前面介绍过Redis的其中一个特性就是客户端多，几乎所有语言都有Redis的客户端，比如<code>Java</code>语言的<code>Jedis</code>；<code>Python</code>语言的<code>redis-py</code>；<code>PHP</code>语言的<code>Predis</code>；<code>Go</code>语言的<code>Redigo</code>等等。这些客户端也都是遵循了Redis给的协议，然后按照协议去开发出对应语言的客户端。如Redis官方提供的<code>redis-cli</code>客户端其实就是一个Shell客户端<br><img src="http://ws2.sinaimg.cn/large/e0e01e43gy1g070fepeo1j20vm0ccgqg.jpg" alt="image">  </p><h2 id="Jedis的使用"><a href="#Jedis的使用" class="headerlink" title="Jedis的使用"></a>Jedis的使用</h2><p>本篇我就讲<code>Java</code>语言的客户端<code>Jedis</code>，使用其他语言的读者可以阅读相关客户端的文档。要使用Jedis，首先确保我们已经添加了Jedis的依赖，这里我使用Maven配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.0.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><h3 id="Jedis的直连"><a href="#Jedis的直连" class="headerlink" title="Jedis的直连"></a>Jedis的直连</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line"> </span><br><span class="line">public class RedisJava &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //连接本地的 Redis 服务</span><br><span class="line">        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;,6379);</span><br><span class="line">        jedis.set(&quot;name&quot;, &quot;redis&quot;);</span><br><span class="line">        System.out.println(&quot;redis 存储的字符串为: &quot;+ jedis.get(&quot;name&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上Java程序，输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 存储的字符串为: redis</span><br></pre></td></tr></table></figure></p><h3 id="Jedis的连接池"><a href="#Jedis的连接池" class="headerlink" title="Jedis的连接池"></a>Jedis的连接池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line"> </span><br><span class="line">public class RedisPool &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //初始化连接池</span><br><span class="line">        JedisPoolConfig config=new JedisPoolConfig();</span><br><span class="line">        JedisPool jedisPool=new JedisPool(config,&quot;127.0.0.1&quot;,6379);</span><br><span class="line">        </span><br><span class="line">        Jedis jedis=null;</span><br><span class="line">        try&#123;</span><br><span class="line">            jedis=jedisPool.getResource(); // 获取连接</span><br><span class="line">            jedis.set(&quot;name&quot;, &quot;redis&quot;); // 设置值</span><br><span class="line">            String value=jedis.get(&quot;name&quot;); // 获取值</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            if(jedis!=null)&#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">            if(jedisPool!=null)&#123;</span><br><span class="line">                jedisPool.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上Java程序，输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis</span><br></pre></td></tr></table></figure></p><h2 id="Spring-data-redis的使用"><a href="#Spring-data-redis的使用" class="headerlink" title="Spring-data-redis的使用"></a>Spring-data-redis的使用</h2><p>前面我们使用了<code>Jedis</code>实现对Redis的操作，这里再介绍使用基于Spring的<code>Spring-data-redis</code>操作Redis，<code>Spring</code>就不用我过多介绍了，相信学Java的都认识它。<br><strong>Jedis与Spring-data-redis的区别和关系：</strong>  </p><ul><li>Jedis：Jedis是Redis的Java客户端，通过它可以对Redis进行操作，与之功能相似的还包括Lettuce等。</li><li>Spring-data-redis：Spring-data-redis对Redis的操作依赖Jedis或Lettuce，实际上是对Jedis、Lettuce这些客户端的封装，提供一套与客户端无关的api供应用使用，从而你在从一个redis客户端切换为另一个客户端，不需要修改业务代码。  </li></ul><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>在使用<code>Spring-data-redis</code>前首先确保我们已经添加了相关依赖，这里我使用Maven配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-web --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context-support --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--MySQL连接驱动--&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;8.0.13&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.0.1&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Redis客户端jedis依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- spring-data-redis依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.5.0.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><h3 id="Spring和Spring-data-redis整合"><a href="#Spring和Spring-data-redis整合" class="headerlink" title="Spring和Spring-data-redis整合"></a>Spring和Spring-data-redis整合</h3><p>通过<code>XML</code>配置文件将<code>Spring-data-redis</code>的<strong>连接池</strong>、<strong>Redis模板</strong>注入到Spring容器中。Redis模板有<code>2</code>个，分别是<code>RedisTemplate</code>、<code>StringRedisTemplate</code>，这两个模板的区别是采用的序列化策略不一样，前者采用的是Java<strong>原生的序列化</strong>后者采用的是<strong>String序列化</strong>。模板的好处是为Redis的交互提供了高级抽象，用户无需关注Redis的连接管理、序列化等问题，把更多注意力放在业务上。<br><strong>redis.properties：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#ip地址</span><br><span class="line">redis.host.ip=192.168.174.129</span><br><span class="line">#端口号</span><br><span class="line">redis.port=6379</span><br><span class="line">#如果有密码</span><br><span class="line">redis.password=</span><br><span class="line">#客户端超时时间单位是毫秒 默认是2000</span><br><span class="line">redis.timeout=3000</span><br><span class="line"></span><br><span class="line">#最大空闲数</span><br><span class="line">redis.maxIdle=6</span><br><span class="line">#连接池的最大数据库连接数。设为0表示无限制,如果是jedis 2.4以后用redis.maxTotal</span><br><span class="line">#redis.maxActive=600maxIdle</span><br><span class="line">#控制一个pool可分配多少个jedis实例,用来替换上面的redis.maxActive,如果是jedis 2.4以后用该属性</span><br><span class="line">redis.maxTotal=20</span><br><span class="line">#最大建立连接等待时间。如果超过此时间将接到异常。设为-1表示无限制。</span><br><span class="line">redis.maxWaitMillis=3000</span><br><span class="line">#连接的最小空闲时间 默认1800000毫秒(30分钟)</span><br><span class="line">redis.minEvictableIdleTimeMillis=300000</span><br><span class="line">#每次释放连接的最大数目,默认3</span><br><span class="line">redis.numTestsPerEvictionRun=4</span><br><span class="line">#逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1</span><br><span class="line">redis.timeBetweenEvictionRunsMillis=30000</span><br></pre></td></tr></table></figure></p><p><strong>spring-redis.xml：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--加载配置文件--&gt;</span><br><span class="line">&lt;bean:property-placeholder location=&quot;classpath:redis.properties&quot; ignore-unresolvable=&quot;true&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--redis连接池配置--&gt;</span><br><span class="line">&lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;</span><br><span class="line">    &lt;!--最大空闲数 --&gt;</span><br><span class="line">    &lt;property name=&quot;maxIdle&quot; value=&quot;$&#123;redis.maxIdle&#125;&quot; /&gt;</span><br><span class="line">    &lt;!--连接池的最大数据库连接数 --&gt;</span><br><span class="line">    &lt;property name=&quot;maxTotal&quot; value=&quot;$&#123;redis.maxTotal&#125;&quot; /&gt;</span><br><span class="line">    &lt;!--最大建立连接等待时间 --&gt;</span><br><span class="line">    &lt;property name=&quot;maxWaitMillis&quot; value=&quot;$&#123;redis.maxWaitMillis&#125;&quot; /&gt;</span><br><span class="line">    &lt;!--逐出连接的最小空闲时间 默认1800000毫秒(30分钟) --&gt;</span><br><span class="line">    &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;$&#123;redis.minEvictableIdleTimeMillis&#125;&quot; /&gt;</span><br><span class="line">    &lt;!--每次逐出检查时 逐出的最大数目 如果为负数就是 : 1/abs(n), 默认3 --&gt;</span><br><span class="line">    &lt;property name=&quot;numTestsPerEvictionRun&quot; value=&quot;$&#123;redis.numTestsPerEvictionRun&#125;&quot; /&gt;</span><br><span class="line">    &lt;!--逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1 --&gt;</span><br><span class="line">    &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;$&#123;redis.timeBetweenEvictionRunsMillis&#125;&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--redis连接工厂--&gt;</span><br><span class="line">&lt;bean id=&quot;connectionFactory&quot; class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;&gt;</span><br><span class="line">    &lt;!--连接池配置--&gt;</span><br><span class="line">    &lt;property name=&quot;poolConfig&quot; ref=&quot;jedisPoolConfig&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--redis地址--&gt;</span><br><span class="line">    &lt;property name=&quot;hostName&quot; value=&quot;$&#123;redis.host.ip&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--redis密码--&gt;</span><br><span class="line">    &lt;!--&lt;property name=&quot;password&quot; value=&quot;$&#123;redis.password&#125;&quot;&gt;&lt;/property&gt;--&gt;</span><br><span class="line">    &lt;!--redis端口--&gt;</span><br><span class="line">    &lt;property name=&quot;port&quot; value=&quot;$&#123;redis.port&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--超时时间 毫秒--&gt;</span><br><span class="line">    &lt;property name=&quot;timeout&quot; value=&quot;$&#123;redis.timeout&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 注入redis操作模板为Bean  自动装配--&gt;</span><br><span class="line">&lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.RedisTemplate&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot; /&gt;</span><br><span class="line">    &lt;!-- 指定redis中key-value的序列化方式（此处省略） --&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 注入redis操作模板为Bean  自动装配--&gt;</span><br><span class="line">&lt;bean id=&quot;stringRedisTemplate&quot; class=&quot;org.springframework.data.redis.core.StringRedisTemplate&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>将<code>Spring</code>和<code>Spring-data-redis</code>整合完成之后，一般为了方便使用模板，我们会将模板进一步封装成自己的Dao工具类，这里我仅封装几个操作，如下<br><strong>RedisDaoImpl.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public class RedisDaoImpl implements RedisDao &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    public void setString(Object redisKey, Object redisValue) &#123;</span><br><span class="line">        ValueOperations valueOperations = stringRedisTemplate.opsForValue();</span><br><span class="line">        valueOperations.set(redisKey, redisValue);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getString(Object redisKey) &#123;</span><br><span class="line">        ValueOperations valueOperations = stringRedisTemplate.opsForValue();</span><br><span class="line">        return valueOperations.get(redisKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @description: 通过redisKey 批量(map)设置redisValue(hash)</span><br><span class="line">     * @param: [redisKey, redisValue]</span><br><span class="line">     * @return: void</span><br><span class="line">     * @author: Xue 8</span><br><span class="line">     * @date: 2019/2/14</span><br><span class="line">     */</span><br><span class="line">    public void setHashAll(Object redisKey, Map&lt;String,Object&gt; redisValue)&#123;</span><br><span class="line">        HashOperations hashOperations = stringRedisTemplate.opsForHash();</span><br><span class="line">        hashOperations.putAll(redisKey, redisValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @description: 通过redisKey、hashKey、hashValue设置单个redisValue(hash)</span><br><span class="line">     * @param: [redisKey, hashKey, hashValue]</span><br><span class="line">     * @return: void</span><br><span class="line">     * @author: Xue 8</span><br><span class="line">     * @date: 2019/2/14</span><br><span class="line">     */</span><br><span class="line">    public void setHash(Object redisKey, Object hashKey, Object hashValue)&#123;</span><br><span class="line">        HashOperations hashOperations = stringRedisTemplate.opsForHash();</span><br><span class="line">        hashOperations.put(redisKey, hashKey, hashValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @description: 通过redisValue、hashKey获取hashValue</span><br><span class="line">     * @param: [redisKey, hashKey]</span><br><span class="line">     * @return: java.lang.Object</span><br><span class="line">     * @author: Xue 8</span><br><span class="line">     * @date: 2019/2/14</span><br><span class="line">     */</span><br><span class="line">    public Object getHashValue(Object redisKey, Object hashKey)&#123;</span><br><span class="line">        HashOperations hashOperations = stringRedisTemplate.opsForHash();</span><br><span class="line">        return hashOperations.get(redisKey, hashKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @description: 通过redisKey获取hash</span><br><span class="line">     * @param: [redisKey]</span><br><span class="line">     * @return: java.util.Map&lt;java.lang.String,java.lang.Object&gt;</span><br><span class="line">     * @author: Xue 8</span><br><span class="line">     * @date: 2019/2/14</span><br><span class="line">     */</span><br><span class="line">    public Map&lt;String,Object&gt; getHash(Object redisKey)&#123;</span><br><span class="line">        HashOperations hashOperations = stringRedisTemplate.opsForHash();</span><br><span class="line">        return hashOperations.entries(redisKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @description: 通过redisKey设置redisValue(List)</span><br><span class="line">     * @param: [redisKey, redisValue]</span><br><span class="line">     * @return: void</span><br><span class="line">     * @author: Xue 8</span><br><span class="line">     * @date: 2019/2/14</span><br><span class="line">     */</span><br><span class="line">    public void setList(Object redisKey, List&lt;Object&gt; redisValue)&#123;</span><br><span class="line">        ListOperations listOperations = stringRedisTemplate.opsForList();</span><br><span class="line">        listOperations.leftPushAll(redisKey, redisValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之后在需要操作到Redis的地方，直接调用RedisDaoImpl即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;http://ws1.sinaimg.cn/large/e0e01e43gy1fzz559f0n2j21d80gf3zh.jpg&quot; alt=&quot;image&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Re
      
    
    </summary>
    
      <category term="Redis" scheme="http://ddnd.cn/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>第二章 Redis API的使用 单线程介绍【Redis入门教程】</title>
    <link href="http://ddnd.cn/2019/02/13/redis-chapter-2/"/>
    <id>http://ddnd.cn/2019/02/13/redis-chapter-2/</id>
    <published>2019-02-13T10:12:33.000Z</published>
    <updated>2019-03-13T11:12:51.721Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><img src="http://ws1.sinaimg.cn/large/e0e01e43gy1fzz559f0n2j21d80gf3zh.jpg" alt="image" width="100%"></p><p><strong>Redis入门教程目录</strong>：<a href="https://ddnd.cn/categories/Redis/">【Redis入门教程目录】</a></p><h2 id="数据结构和内部编码"><a href="#数据结构和内部编码" class="headerlink" title="数据结构和内部编码"></a>数据结构和内部编码</h2><p>通过这部分让大家对Redis的五种数据结构有初步的认识，对于Redis来说，每一种数据结构都有着自己的内部编码，而且是多种实现的，这样Redis会在合适的场景选择合适的内部编码，通过<code>OBJECT ENCODING [key]</code>可以参看指定<code>key</code>的内部编码。<br><strong>这样做的好处：</strong><br>a. 改进内部编码，对外的数据结构和命令没有影响，对用户提供黑箱模型。<br>b. 多种内部编码可在不同场景下发挥各自的优势。如：<code>ziplist</code>比较节约内存，但是元素比较多的时候，性能会有所下降，此时Redis会将编码自动转换为<code>linkedlist</code>，性能会有所改善。<br><img src="http://wx3.sinaimg.cn/large/e0e01e43gy1g040kix74jj20q00lqwmc.jpg" alt="image"></p><h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p>了解Redis的单线程架构，有助于大家对Redis的进一步学习和排解问题。<br><img src="http://ws2.sinaimg.cn/large/e0e01e43gy1g0431ewwgbj216g0k479d.jpg" alt="image"><br>Redis处理网络请时候的求单线程可以抽象成这样，通向Redis的路只有一条，且这条路是个单车道，只容的下一辆车同时使用，而我们使用的Redis命令即为这些车辆，当我们执行多个命令的时候，只有等第一个命令执行完成了后面的命令才会执行，否则会一直处于等待状态。<br><img src="http://ws3.sinaimg.cn/large/e0e01e43gy1g00j4nk245j21b40ecq6e.jpg" alt="image"><br>Redis单线程的架构需要我们注意几点<br>a. 一次只运行一条命令<br>b. 拒绝长（慢）命令（keys、flushall、flushdb、slow lua script、mutil/exec、operate、big value）<br>至于为什么单线程还这么快，这里有个原因，Redis客户端的到Redis服务器的网络请求采用了<strong>多路I/O复用模型（非阻塞I/O）</strong>，利用<code>select</code>、<code>poll</code>、<code>epoll</code>可以<strong>同时监听多个流的I/O(客户端到服务器的网络请求)事件的能力</strong>，在空闲的时候，会把当前线程阻塞掉，当有一个或者多个流有<code>I/O</code>事件时，就从阻塞态中唤醒，<strong>轮训一遍所有的流</strong>并且依次处理就绪的流。这样就算出现有的流的<code>I/O</code>因为网络原因很慢，也不会影响别的流的<code>I/O</code>（非阻塞），因为是轮训所有的流的<code>I/O</code>。这里的“多路”指的是多个网络连接，“复用”指的是复用同一个线程。<br><img src="https://upload-images.jianshu.io/upload_images/8753960-fb5c8f0a4f37d3f7.gif?imageMogr2/auto-orient/"></p><h2 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h2><p>Redis一些通用命令，比如删除一个键、计算数据库的大小、设置键的过期时间等，这些命令有很多，这里主要介绍<code>7</code>个，完整的命令大家可以参考官方文档。<br>1.KEYS [pattern]<br>时间复杂度为<strong>O(N)</strong>，<code>N</code>为数据库中<code>Key</code>的数量。 这个命令由于时间复杂度为O(N)所以一般生产环境不使用，如果需要遍历全部数据，可以使用Scan命令，时间复杂度为O(1)。<br>查找所有符合给定模式<code>pattern</code>的<code>key</code>，比如说：    </p><ul><li><code>KEYS *</code>匹配数据库中所有的<code>key</code>。  </li><li><code>KEYS h?llo</code>匹配<code>hello</code>、<code>hallo</code>等<code>key</code>。  </li><li><code>KEYS h*llo</code>匹配<code>hllo</code>和<code>haaaaaallo</code>等<code>key</code>。  </li><li><code>KEYS h[abe]llo</code>匹配<code>hallo</code>、<code>hbllo</code>和<code>hello</code>。<br><strong>返回值：</strong> 符合给定模式的<code>key</code>列表。     </li></ul><p>2.DBSIZE<br>时间复杂度为<strong>O(1)</strong>，计算的时候不是扫描整个表，因为Redis有个计数器，实时更新Key总数。<br>查找返回当前数据库的<code>key</code>的数量。<br><strong>返回值：</strong> 返回当前数据库的<code>key</code>的数量。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DBSIZE</span><br><span class="line">(integer) 5</span><br><span class="line"></span><br><span class="line">redis&gt; SET new_key &quot;hello_moto&quot;     #增加一个 key 试试</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DBSIZE</span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure></p><p>3.EXISTS key<br>时间复杂度为<strong>O(1)</strong>。<br>检查给定<code>key</code>是否存在。<br><strong>返回值：</strong> 若<code>key</code>存在，返回<code>1</code>，不存在返回<code>0</code>。  </p><p>4.DEL key [key …]<br>时间复杂度为<strong>O(N)</strong>，<code>N</code>为被删除的<code>key</code>的数量，其中删除单个字符串类型的<code>key</code>，时间复杂度为<code>O(1)</code>；删除单个列表、集合、有序集合或哈希表类型的<code>key</code>，时间复杂度为<code>O(M)</code>，<code>M</code>为以上数据结构内的元素数量。<br>删除指定的一个或者多个<code>key</code>，不存在的<code>key</code>会被忽略。<br><strong>返回值：</strong> 被删除的<code>key</code>的数量。   </p><p>5.EXPIRE key seconds<br>时间复杂度为<strong>O(1)</strong>。<br>为给定的<code>key</code>设置生存时间，当<code>key</code>过期时，它会被自动<strong>删除</strong>。<br><strong>返回值：</strong> 设置成功返回<code>1</code>，当<code>key</code>不存在或者设置失败的时候返回<code>0</code>。    </p><p>6.PERSIST key<br>时间复杂度为<strong>O(1)</strong>。<br>移除给定<code>key</code>的生存时间，将这个<code>key</code>转换成持久的。<br><strong>返回值：</strong> 当生存时间移除成功时，返回<code>1</code>，如果<code>key</code>不存在或者没有设置生存时间，返回<code>0</code>。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey &quot;Hello&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; EXPIRE mykey 10  #为 key 设置生存时间</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL mykey</span><br><span class="line">(integer) 10</span><br><span class="line"></span><br><span class="line">redis&gt; PERSIST mykey    #移除 key 的生存时间</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL mykey</span><br><span class="line">(integer) -1</span><br></pre></td></tr></table></figure></p><p>7.TTL key<br>时间复杂度<strong>O(1)</strong>。<br>以秒为单位，返回给定<code>key</code>的剩余生存时间（TTL，time to live）。<br><strong>返回值：</strong> 当<code>key</code>不存在时，返回<code>-2</code>，当<code>key</code>存在但是没有设置生存时间时，返回<code>-1</code>，否则返回<code>key</code>的剩余生存时间。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 不存在的 key</span><br><span class="line"></span><br><span class="line">redis&gt; FLUSHDB</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; TTL key</span><br><span class="line">(integer) -2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#key 存在，但没有设置剩余生存时间</span><br><span class="line"></span><br><span class="line">redis&gt; SET key value</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; TTL key</span><br><span class="line">(integer) -1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#有剩余生存时间的 key</span><br><span class="line"></span><br><span class="line">redis&gt; EXPIRE key 10086</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL key</span><br><span class="line">(integer) 10084</span><br></pre></td></tr></table></figure></p><h2 id="五种数据结构"><a href="#五种数据结构" class="headerlink" title="五种数据结构"></a>五种数据结构</h2><p>这里介绍Redis的五种数据结构String（字符串）、Hash（哈希）、List（列表）、Set（集合）、Zset（即Sorted Set有序集合）的结构和一些命令。  </p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串是Redis中最基础的数据结构。</p><h4 id="键值结构"><a href="#键值结构" class="headerlink" title="键值结构"></a>键值结构</h4><p>字符串的值虽然是字符串但是可以保存很多种类型的数据，如：简单的字符串、JSON、XML、数字、二进制等。需要注意一点的是，Redis中字符串类型的值最大能保存512MB。<br><img src="http://ws1.sinaimg.cn/large/e0e01e43gy1g043ib11xqj20fa096mxd.jpg" alt="image"></p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>1.SET key value [EX seconds] [PX milliseconds] [NX|XX]<br>时间复杂度<strong>O(1)</strong>。<br>将字符串值<code>value</code>关联到<code>key</code>，如果<code>key</code>已经持有其他值，<code>SET</code>就覆写旧值，无视类型，当<code>SET</code>命令对一个带有生存时间（TTL）的键进行设置之后，该键原有的TTL将被清除。<br><strong>可选参数：</strong></p><ul><li><code>EX seconds</code>：将键的过期时间设置为<code>seconds</code>秒。 执行<code>SET key value EX seconds</code>的效果等同于执行<code>SETEX key seconds value</code>。       </li><li><code>PX milliseconds</code>：将键的过期时间设置为<code>milliseconds</code>毫秒。执行<code>SET key value PX milliseconds</code>的效果等同于执行<code>PSETEX key milliseconds value</code>。     </li><li><code>NX</code>：只在键不存在时，才对键进行设置操作。执行<code>SET key value NX</code>的效果等同于执行<code>SETNX key value</code>。   </li><li><code>XX</code>：只在键已经存在时，才对键进行设置操作。   <blockquote><p>因为<code>SET</code>命令可以通过参数来实现<code>SETNX</code>、<code>SETEX</code>以及<code>PSETEX</code>命令的效果，所以<code>Redis</code>将来的版本可能会移除并废弃<code>SETNX</code>、<code>SETEX</code>和<code>PSETEX</code>这三个命令。</p></blockquote></li></ul><p><strong>返回值：</strong><br>在Redis 2.6.12版本以前，<code>SET</code>命令总是返回<code>OK</code>。<br>从Redis 2.6.12版本开始，<code>SET</code>命令只在设置操作成功完成时才返回<code>OK</code>；如果命令使用了<code>NX</code>或者<code>XX</code>选项， 但是因为条件没达到而造成设置操作未执行， 那么命令将返回空批量回复（NULL Bulk Reply）。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#使用 EX 选项</span><br><span class="line">redis&gt; SET key-with-expire-time &quot;hello&quot; EX 10086</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET key-with-expire-time</span><br><span class="line">&quot;hello&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; TTL key-with-expire-time</span><br><span class="line">(integer) 10069</span><br></pre></td></tr></table></figure></p><p>2.GET key<br>时间复杂度<strong>O(1)</strong>。<br>获取与键<code>key</code>相关联的字符串值。<br><strong>返回值：</strong><br>如果键<code>key</code>不存在，那么返回特殊值<code>nil</code>；否则，返回键<code>key</code>的值。<br>如果键<code>key</code>的值并非字符串类型，那么返回一个错误，因为<code>GET</code>命令只能用于字符串值。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GET db</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">redis&gt; SET db redis</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET db</span><br><span class="line">&quot;redis&quot;</span><br></pre></td></tr></table></figure></p><p>3.DEL key [key …]<br>时间复杂度为<strong>O(N)</strong>，<code>N</code>为被删除的<code>key</code>的数量，其中删除单个字符串类型的<code>key</code>，时间复杂度为<code>O(1)</code>；删除单个列表、集合、有序集合或哈希表类型的<code>key</code>，时间复杂度为<code>O(M)</code>，<code>M</code>为以上数据结构内的元素数量。<br>删除指定的一个或者多个<code>key</code>，不存在的<code>key</code>会被忽略。<br><strong>返回值：</strong> 被删除的<code>key</code>的数量。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#同时删除多个 key</span><br><span class="line"></span><br><span class="line">redis&gt; SET name &quot;redis&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET type &quot;key-value store&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET website &quot;redis.com&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DEL name type website</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></p><p>4.MSET key value [key value …]<br>时间复杂度<strong>O(N)</strong>，其中<code>N</code>为被设置的键数量。<br>同时为多个键设置值。如果某个给定键已经存在，那么<code>MSET</code>将使用新值去覆盖旧值，如果这不是你所希望的效果，请考虑使用<code>MSETNX</code>命令，这个命令只会在所有给定键都不存在的情况下进行设置。<code>MSET</code>是一个<strong>原子性(atomic)</strong> 操作，所有给定键都会在同一时间内被设置，不会出现某些键被设置了但是另一些键没有被设置的情况。<br><strong>返回值：</strong> <code>MSET</code>命令总是返回<code>OK</code>。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MSET date &quot;2012.3.30&quot; time &quot;11:00 a.m.&quot; weather &quot;sunny&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MGET date time weather</span><br><span class="line">1) &quot;2012.3.30&quot;</span><br><span class="line">2) &quot;11:00 a.m.&quot;</span><br><span class="line">3) &quot;sunny&quot;</span><br></pre></td></tr></table></figure></p><p>5.MSETNX key value [key value …]<br>时间复杂度<strong>O(N)</strong>，其中<code>N</code>为被设置的键数量。<br>当且仅当所有给定键都<strong><em>不存在</em></strong>时,为所有给定键设置值。即使只有一个给定键已经存在，<code>MSETNX</code>命令也会拒绝执行对所有键的设置操作。<code>MSETNX</code>是一个<strong>原子性(atomic)</strong> 操作，所有给定键要么就全部都被设置，要么就全部都不设置，不可能出现第三种状态。<br><strong>返回值：</strong> 当所有给定键都设置成功时，命令返回<code>1</code>；如果因为某个给定键已经存在而导致设置未能成功执行，那么命令返回<code>0</code>。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MSETNX rmdbs &quot;MySQL&quot; nosql &quot;MongoDB&quot; key-value-store &quot;redis&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; MGET rmdbs nosql key-value-store</span><br><span class="line">1) &quot;MySQL&quot;</span><br><span class="line">2) &quot;MongoDB&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br></pre></td></tr></table></figure></p><p>6.MGET key [key …]<br>时间复杂度<strong>O(N)</strong>，其中<code>N</code>为给定键的数量。<br>返回给定的一个或多个字符串键的值。如果给定的字符串键里面，有某个键不存在，那么这个键的值将以特殊值<code>nil</code>表示。<br><strong>返回值：</strong> <code>MGET</code>命令将返回一个列表，列表中包含了所有给定键的值。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET redis redis.com</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET mongodb mongodb.org</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MGET redis mongodb</span><br><span class="line">1) &quot;redis.com&quot;</span><br><span class="line">2) &quot;mongodb.org&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; MGET redis mongodb mysql     #不存在的 mysql 返回 nil</span><br><span class="line">1) &quot;redis.com&quot;</span><br><span class="line">2) &quot;mongodb.org&quot;</span><br><span class="line">3) (nil)</span><br></pre></td></tr></table></figure></p><p>7.N次GET和一次MGET对比<br>总所周知，Redis采用的是客户端-服务器方式，即在一次round trip中，客户端发送一条命令，服务器解析命令并执行，然后向客户端返回结果，如果执行<code>N</code>条命令，就是<code>N</code>个请求<code>N</code>次执行<code>N</code>个返回<br><img src="http://wx4.sinaimg.cn/large/e0e01e43gy1g04rgjoxjwj211t0nmqcm.jpg" alt="image"><br>如果我们把<code>N</code>条命令都放在一个请求中，一次请求多个执行一个返回，那么就可以大大的降低网络时间的开销，这个也就是Redis的pipline<br><img src="http://ws3.sinaimg.cn/large/e0e01e43gy1g04rk1afstj214t0pstgn.jpg" alt="image"></p><p>8.N次SET和一次MSET对比<br>同7</p><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><p>Redis的哈希是键值对的集合，是字符串字段和字符串值之间的映射。</p><h4 id="键值结构-1"><a href="#键值结构-1" class="headerlink" title="键值结构"></a>键值结构</h4><p><code>Hash</code>数据结构即数据存储为<code>field</code>、<code>value</code>的格式存储<br><img src="http://wx2.sinaimg.cn/large/e0e01e43gy1g04saqqy8ij20x00bj41k.jpg" alt="image"><br>可以将<code>field</code>、<code>value</code>看成一对键值对结构<br><img src="http://wx1.sinaimg.cn/large/e0e01e43gy1g04s578nymj20um09uwer.jpg" alt="image"></p><h4 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h4><p>1.HSET key field value<br>时间复杂度<strong>O(1)</strong>。<br>将哈希表<code>key</code>中域<code>field</code>的值设置为<code>value</code>，如果给定的哈希表不存在，那么一个新的哈希表将被创建并执行<code>HSET</code>操作，如果域<code>field</code>已存在于哈希表中，那么它的旧值将被新值<code>value</code>覆盖。<br><strong>返回值：</strong> 当<code>HSET</code>命令在哈希表中新创建<code>field</code>域并成功为它设置值时,命令返回<code>1</code>；如果域<code>field</code>已经存在于哈希表，并且<code>HSET</code>命令成功使用新值覆盖了它的旧值，那么命令返回<code>0</code>。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET website google &quot;www.g.cn&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HGET website google</span><br><span class="line">&quot;www.g.cn&quot;</span><br></pre></td></tr></table></figure></p><p>2.HGET key field<br>时间复杂度<strong>O(1)</strong>。<br>返回哈希表中给定域的值。<br><strong>返回值：</strong> <code>HGET</code>命令在默认情况下返回给定域的值，如果给定域不存在于哈希表中，又或者给定的哈希表并不存在，那么命令返回<code>nil</code>。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET homepage redis redis.com</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HGET homepage redis</span><br><span class="line">&quot;redis.com&quot;</span><br></pre></td></tr></table></figure></p><p>3.HGETALL key<br>时间复杂度<strong>O(N)</strong>，<code>N</code>为哈希表的大小，谨慎用。<br>返回哈希表的所有的域和值，在返回值里，紧跟每个域(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。<br><strong>返回值：</strong> 以列表形式返回哈希表的域和域的值，若<code>key</code>不存在，返回空列表。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET people jack &quot;Jack Sparrow&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HSET people gump &quot;Forrest Gump&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HGETALL people</span><br><span class="line">1) &quot;jack&quot;          #域</span><br><span class="line">2) &quot;Jack Sparrow&quot;  #值</span><br><span class="line">3) &quot;gump&quot;</span><br><span class="line">4) &quot;Forrest Gump&quot;</span><br></pre></td></tr></table></figure></p><p>4.HDEL key field [field …]<br>时间复杂度<strong>O(N)</strong>，<code>N</code>为要删除的域的数量。<br>删除哈希表<code>key</code>中的一个或多个指定域，不存在的域将被忽略。<br><strong>返回值：</strong> 被成功移除的域的数量，不包括被忽略的域。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#测试数据</span><br><span class="line"></span><br><span class="line">redis&gt; HGETALL abbr</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;banana&quot;</span><br><span class="line">5) &quot;c&quot;</span><br><span class="line">6) &quot;cat&quot;</span><br><span class="line">7) &quot;d&quot;</span><br><span class="line">8) &quot;dog&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#删除单个域</span><br><span class="line"></span><br><span class="line">redis&gt; HDEL abbr a</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#删除不存在的域</span><br><span class="line"></span><br><span class="line">redis&gt; HDEL abbr not-exists-field</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#删除多个域</span><br><span class="line"></span><br><span class="line">redis&gt; HDEL abbr b c</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; HGETALL abbr</span><br><span class="line">1) &quot;d&quot;</span><br><span class="line">2) &quot;dog&quot;</span><br></pre></td></tr></table></figure></p><p>5.HMSET key field value [field value …]<br>时间复杂度<strong>O(N)</strong>，<code>N</code>为<code>field-value</code>对的数量。<br>同时将多个<code>field-value</code>(域-值)对设置到哈希表<code>key</code>中，此命令会覆盖哈希表中已存在的域，如果<code>key</code>不存在，一个空哈希表被创建并执行<code>HMSET</code>操作。<br><strong>返回值：</strong> 如果命令执行成功，返回<code>OK</code>，当<code>key</code>不是哈希表(hash)类型时，返回一个错误。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HMSET website google www.google.com yahoo www.yahoo.com</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; HGET website google</span><br><span class="line">&quot;www.google.com&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; HGET website yahoo</span><br><span class="line">&quot;www.yahoo.com&quot;</span><br></pre></td></tr></table></figure></p><p>6.HMGET key field [field …]<br>时间复杂度<strong>O(N)</strong>，<code>N</code>为给定域的数量。<br>返回哈希表<code>key</code>中，一个或多个给定域的值，如果给定的域不存在于哈希表，那么返回一个<code>nil</code>值，因为不存在的<code>key</code>被当作一个空哈希表来处理，所以对一个不存在的<code>key</code>进行<code>HMGET</code>操作将返回一个只带有<code>nil</code>值的表。<br><strong>返回值：</strong> 一个包含多个给定域的关联值的表，表值的排列顺序和给定域参数的请求顺序一样。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HMSET pet dog &quot;doudou&quot; cat &quot;nounou&quot;    #一次设置多个域</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; HMGET pet dog cat fake_pet             #返回值的顺序和传入参数的顺序一样</span><br><span class="line">1) &quot;doudou&quot;</span><br><span class="line">2) &quot;nounou&quot;</span><br><span class="line">3) (nil)                                      #不存在的域返回nil值</span><br></pre></td></tr></table></figure></p><p>7.N次HGET和一次HMGET对比<br>参考字符串的<code>N</code>次<code>GET</code>和一次<code>MGET</code>对比，大概相同</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表用于储存多个有序的字符串，列表是一种比较灵活的数据结构，可以充当<strong>栈</strong>和<strong>队列</strong>的角色。</p><h4 id="键值结构-2"><a href="#键值结构-2" class="headerlink" title="键值结构"></a>键值结构</h4><p>列表的<code>value</code>其实是一个双向链表，可以在链表的两头插入或者删除元素<br><img src="http://wx3.sinaimg.cn/large/e0e01e43gy1g04u9xkllmj21bs0ijq7t.jpg" alt="image"></p><h4 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h4><p>1.LPUSH key value [value …]<br>时间复杂度<strong>O(1)</strong>。<br>将一个或多个值<code>value</code>插入到列表<code>key</code>的表头，如果有多个<code>value</code>值，那么各个<code>value</code>值按从左到右的顺序依次插入到表头：比如说，对空列表<code>mylist</code>执行命令<code>LPUSH mylist a b c</code>，列表的值将是<code>c b a</code>，这等同于原子性地执行<code>LPUSH mylist a</code>、<code>LPUSH mylist b</code>和<code>LPUSH mylist c</code>三个命令，如果<code>key</code>不存在，一个空列表会被创建并执行<code>LPUSH</code>操作，当<code>key</code>存在但不是列表类型时，返回一个错误。<br><strong>返回值：</strong> 执行<code>LPUSH</code>命令后，列表的长度。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#加入单个元素</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH languages python</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#加入重复元素</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH languages python</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE languages 0 -1     #列表允许重复元素</span><br><span class="line">1) &quot;python&quot;</span><br><span class="line">2) &quot;python&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#加入多个元素</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH mylist a b c</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;a&quot;</span><br></pre></td></tr></table></figure></p><p>2.RPUSH key value [value …]<br>时间复杂度<strong>O(1)</strong>。<br>将一个或多个值<code>value</code>插入到列表<code>key</code>的表尾（最右边），如果有多个<code>value</code>值，那么各个<code>value</code>值按从左到右的顺序依次插入到表尾：比如说，对空列表<code>mylist</code>执行命令<code>RPUSH mylist a b c</code>，列表的值将是<code>c b a</code>，这等同于原子性地执行<code>RPUSH mylist a</code>、<code>RPUSH mylist b</code>和<code>RPUSH mylist c</code>三个命令，如果<code>key</code>不存在，一个空列表会被创建并执行<code>RPUSH</code>操作，当<code>key</code>存在但不是列表类型时，返回一个错误。<br><strong>返回值：</strong> 执行<code>RPUSH</code>命令后，列表的长度。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#添加单个元素</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH languages c</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#添加重复元素</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH languages c</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE languages 0 -1 #列表允许重复元素</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#添加多个元素</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH mylist a b c</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;c&quot;</span><br></pre></td></tr></table></figure></p><p>3.LPOP key<br>时间复杂度<strong>O(1)</strong>。<br>移除头元素并返回列表<code>key</code>新的头元素。<br><strong>返回值：</strong> 列表的头元素。当<code>key</code>不存在时，返回<code>nil</code>。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#加入单个元素</span><br><span class="line">redis&gt; LLEN course</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH course algorithm001</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH course c++101</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LPOP course  #移除头元素</span><br><span class="line">&quot;algorithm001&quot;</span><br></pre></td></tr></table></figure></p><p>4.RPOP key<br>时间复杂度<strong>O(1)</strong>。<br>移除尾元素并返回列表<code>key</code>新的尾元素。<br><strong>返回值：</strong> 列表的尾元素。当<code>key</code>不存在时，返回<code>nil</code>。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH mylist &quot;one&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH mylist &quot;two&quot;</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH mylist &quot;three&quot;</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; RPOP mylist           #返回被弹出的元素</span><br><span class="line">&quot;three&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE mylist 0 -1    #列表剩下的元素</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;two&quot;</span><br></pre></td></tr></table></figure></p><p>5.LINDEX key index<br>时间复杂度<strong>O(N)</strong>，<code>N</code>为到达下标<code>index</code>过程中经过的元素数量。因此，对列表的头元素和尾元素执行<code>LINDEX</code>命令，复杂度为O(1)。<br>返回列表<code>key</code>中，下标为<code>index</code>的元素，下标(index)参数<code>start</code>和<code>stop</code>都以<code>0</code>为底，也就是说，以<code>0</code>表示列表的第一个元素，以<code>1</code>表示列表的第二个元素，以此类推，你也可以使用负数下标，以<code>-1</code>表示列表的最后一个元素，<code>-2</code>表示列表的倒数第二个元素，以此类推，如果<code>key</code>不是列表类型，返回一个错误。<br><strong>返回值：</strong> 列表中下标为<code>index</code>的元素。如果<code>index</code>参数的值不在列表的区间范围内(out of range)，返回<code>nil</code>。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LPUSH mylist &quot;World&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH mylist &quot;Hello&quot;</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LINDEX mylist 0</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; LINDEX mylist -1</span><br><span class="line">&quot;World&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; LINDEX mylist 3        #index不在 mylist 的区间范围内</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></p><p>6.LINSERT key BEFORE|AFTER pivot value<br>时间复杂度<strong>O(N)</strong>，<code>N</code>为寻找<code>pivot</code>过程中经过的元素数量。<br>将值<code>value</code>插入到列表<code>key</code>当中，位于值<code>pivot</code>之前或之后，当<code>pivot</code>不存在于列表<code>key</code>时，不执行任何操作，当<code>key</code>不存在时，<code>key</code>被视为空列表，不执行任何操作，如果<code>key</code>不是列表类型，返回一个错误。<br><strong>返回值：</strong> 如果命令执行成功，返回插入操作完成之后，列表的长度。如果没有找到<code>pivot</code>，返回<code>-1</code>。如果<code>key</code>不存在或为空列表，返回<code>0</code>。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH mylist &quot;Hello&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH mylist &quot;World&quot;</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LINSERT mylist BEFORE &quot;World&quot; &quot;There&quot;</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) &quot;Hello&quot;</span><br><span class="line">2) &quot;There&quot;</span><br><span class="line">3) &quot;World&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#对一个非空列表插入，查找一个不存在的 pivot</span><br><span class="line"></span><br><span class="line">redis&gt; LINSERT mylist BEFORE &quot;go&quot; &quot;let&apos;s&quot;</span><br><span class="line">(integer) -1                                    #失败</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#对一个空列表执行 LINSERT 命令</span><br><span class="line"></span><br><span class="line">redis&gt; EXISTS fake_list</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">redis&gt; LINSERT fake_list BEFORE &quot;nono&quot; &quot;gogogog&quot;</span><br><span class="line">(integer) 0                                      #失败</span><br></pre></td></tr></table></figure></p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>Redis的<code>Set</code>是<code>String</code>类型的无序集合，这里的集合也就是我们小学都接触到的集合，可以求交集、并集、差集等。集合成员是唯一的，这就意味着集合中不能出现重复的数据。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。   </p><h4 id="键值结构-3"><a href="#键值结构-3" class="headerlink" title="键值结构"></a>键值结构</h4><p>左边为<code>key</code>,是字符串类型。右边为<code>value</code>,可以将一些字符串进行一些组合，是集合类型。Redis中的集合类型还支持集合之间的操作，这与Redis中的其他数据结构是不同的，Redis可以对两个集合进行操作，取两个集合的交集，并集，差集以及对称差集等。<br><img src="http://ws1.sinaimg.cn/large/e0e01e43gy1g04woe8h2dj20je093myh.jpg" alt="image"></p><h4 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h4><p>1.SADD key member [member …]<br>时间复杂度<strong>O(N)</strong>，<code>N</code>为被添加的元素的数量。<br>将一个或多个<code>member</code>元素加入到集合<code>key</code>当中，已经存在于集合的<code>member</code>元素将被忽略，假如<code>key</code>不存在，则创建一个只包含<code>member</code>元素作成员的集合，当<code>key</code>不是集合类型时，返回一个错误。<br><strong>返回值：</strong> 被添加到集合中的新元素的数量，不包括被忽略的元素。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#添加单个元素</span><br><span class="line"></span><br><span class="line">redis&gt; SADD bbs &quot;discuz.net&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#添加重复元素</span><br><span class="line"></span><br><span class="line">redis&gt; SADD bbs &quot;discuz.net&quot;</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#添加多个元素</span><br><span class="line"></span><br><span class="line">redis&gt; SADD bbs &quot;tianya.cn&quot; &quot;groups.google.com&quot;</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS bbs</span><br><span class="line">1) &quot;discuz.net&quot;</span><br><span class="line">2) &quot;groups.google.com&quot;</span><br><span class="line">3) &quot;tianya.cn&quot;</span><br></pre></td></tr></table></figure></p><p>2.SPOP key [count]<br>时间复杂度<strong>O(1)</strong>。<br>随机移除<code>count</code>个元素并返回被移除的元素。<br><strong>返回值：</strong> 被移除的随机元素。当<code>key</code>不存在或<code>key</code>是空集时，返回<code>nil</code>。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS db</span><br><span class="line">1) &quot;MySQL&quot;</span><br><span class="line">2) &quot;MongoDB&quot;</span><br><span class="line">3) &quot;Redis&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; SPOP db</span><br><span class="line">&quot;Redis&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS db</span><br><span class="line">1) &quot;MySQL&quot;</span><br><span class="line">2) &quot;MongoDB&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; SPOP db</span><br><span class="line">&quot;MySQL&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS db</span><br><span class="line">1) &quot;MongoDB&quot;</span><br></pre></td></tr></table></figure></p><p>3.SREM key member [member …]<br>时间复杂度<strong>O(N)</strong>，<code>N</code>为给定<code>member</code>元素的个数。<br>移除集合<code>key</code>中的一个或多个<code>member</code>元素，不存在的<code>member</code>元素会被忽略，当<code>key</code>不是集合类型，返回一个错误。<br><strong>返回值：</strong> 被成功移除的元素的个数，不包括被忽略的元素。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#测试数据</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS languages</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;lisp&quot;</span><br><span class="line">3) &quot;python&quot;</span><br><span class="line">4) &quot;ruby&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#移除单个元素</span><br><span class="line"></span><br><span class="line">redis&gt; SREM languages ruby</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#移除不存在元素</span><br><span class="line"></span><br><span class="line">redis&gt; SREM languages non-exists-language</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#移除多个元素</span><br><span class="line"></span><br><span class="line">redis&gt; SREM languages lisp python c</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS languages</span><br><span class="line">(empty list or set)</span><br></pre></td></tr></table></figure></p><p>4.SMEMBERS key<br>时间复杂度<strong>O(N)</strong>，<code>N</code>为集合的基数。<br>返回集合<code>key</code>中的所有成员，不存在的<code>key</code>被视为空集合。<br><strong>返回值：</strong> 集合中的所有成员。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#key 不存在或集合为空</span><br><span class="line"></span><br><span class="line">redis&gt; EXISTS not_exists_key</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS not_exists_key</span><br><span class="line">(empty list or set)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#非空集合</span><br><span class="line"></span><br><span class="line">redis&gt; SADD language Ruby Python Clojure</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS language</span><br><span class="line">1) &quot;Python&quot;</span><br><span class="line">2) &quot;Ruby&quot;</span><br><span class="line">3) &quot;Clojure&quot;</span><br></pre></td></tr></table></figure></p><h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><p>Redis有序集合和集合一样也是<code>String</code>类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个<code>double</code>类型的分数。Redis正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p><h4 id="键值结构-4"><a href="#键值结构-4" class="headerlink" title="键值结构"></a>键值结构</h4><p>有序集合的<code>value</code>包括<code>score</code>和<code>value</code>两部分，其中<code>score</code>表示分值用来排序的<br><img src="http://wx3.sinaimg.cn/large/e0e01e43gy1g04y9o37y7j21810j644t.jpg" alt="image"></p><h4 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h4><p>1.ZADD key [NX|XX] [CH] [INCR] score member [score member …]<br>时间复杂度<strong>O(M*log(N))</strong>，<code>N</code>是有序集的基数，<code>M</code>为成功添加的新成员的数量。<br>将一个或多个<code>member</code>元素及其<code>score</code>值加入到有序集<code>key</code>当中。如果某个<code>member</code>已经是有序集的成员，那么更新这个<code>member</code>的<code>score</code>值，并通过重新插入这个<code>member</code>元素，来保证该<code>member</code>在正确的位置上。<code>score</code>值可以是整数值或双精度浮点数。如果<code>key</code>不存在，则创建一个空的有序集并执行<code>ZADD</code>操作。当<code>key</code>存在但不是有序集类型时，返回一个错误。<br>Redis 3.0.2 为<code>ZADD</code>命令添加了<code>NX</code>、<code>XX</code>、<code>CH</code>、<code>INCR</code> 四个选项：</p><ul><li><code>NX</code>：<code>member</code>必须不存在，才可以设置成功，用于添加。   </li><li><code>XX</code>：<code>member</code>必须存在，才可以设置成功，用于更新。  </li><li><code>CH</code>：返回此次操作后，有序集合元素和分数发生变化的个数。    </li><li><code>INCR</code>：对<code>score</code>做增加，相当于<code>ZINCRBY</code>。<br><strong>返回值：</strong> 被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。<br><strong>代码演示：</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> redis&gt; ZADD ztest 100 java 99 python 80 go 120 kotlin</span><br><span class="line">(integer) 4</span><br><span class="line">#查看有序集合内所有元素并且按分数排序</span><br><span class="line"> coderknock&gt; ZRANGE ztest 0 -1 WITHSCORES</span><br><span class="line">1) &quot;go&quot;</span><br><span class="line">2) &quot;80&quot;</span><br><span class="line">3) &quot;python&quot;</span><br><span class="line">4) &quot;99&quot;</span><br><span class="line">5) &quot;java&quot;</span><br><span class="line">6) &quot;100&quot;</span><br><span class="line">7) &quot;kotlin&quot;</span><br><span class="line">8) &quot;120&quot;</span><br><span class="line">#选项填写在 key 后面，位置不能错误</span><br><span class="line"> redis&gt; ZADD ztest 100 java 99 python 80 go 120 kotlin CH</span><br><span class="line">(error) ERR syntax error</span><br><span class="line"> redis&gt; ZADD CH ztest 100 java 99 python 80 go 120 kotlin</span><br><span class="line">(error) ERR syntax error</span><br><span class="line">#下面两个语句进行了对比，如果不加 CH 显示的数量不包括更新和已经存在的。</span><br><span class="line"> redis&gt;  ZADD ztest CH 100 java 99 python 80 go 121 kotlin</span><br><span class="line">(integer) 1</span><br><span class="line"> redis&gt;  ZADD ztest 100 java 99 python 80 go 120 kotlin</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></li></ul><p>2.ZREM key member [member …]<br>时间复杂度<strong>O(M*log(N))</strong>，<code>N</code>是有序集的基数，<code>M</code>为成功移除的成员的数量。<br>移除有序集<code>key</code>中的一个或多个成员，不存在的成员将被忽略，当<code>key</code>存在但不是有序集类型时，返回一个错误。<br><strong>返回值：</strong> 被成功移除的成员的数量，不包括被忽略的成员。<br><strong>代码演示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#测试数据</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</span><br><span class="line">1) &quot;bing.com&quot;</span><br><span class="line">2) &quot;8&quot;</span><br><span class="line">3) &quot;baidu.com&quot;</span><br><span class="line">4) &quot;9&quot;</span><br><span class="line">5) &quot;google.com&quot;</span><br><span class="line">6) &quot;10&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#移除单个元素</span><br><span class="line"></span><br><span class="line">redis&gt; ZREM page_rank google.com</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</span><br><span class="line">1) &quot;bing.com&quot;</span><br><span class="line">2) &quot;8&quot;</span><br><span class="line">3) &quot;baidu.com&quot;</span><br><span class="line">4) &quot;9&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#移除多个元素</span><br><span class="line"></span><br><span class="line">redis&gt; ZREM page_rank baidu.com bing.com</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</span><br><span class="line">(empty list or set)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#移除不存在元素</span><br><span class="line"></span><br><span class="line">redis&gt; ZREM page_rank non-exists-element</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;http://ws1.sinaimg.cn/large/e0e01e43gy1fzz559f0n2j21d80gf3zh.jpg&quot; alt=&quot;image&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Re
      
    
    </summary>
    
      <category term="Redis" scheme="http://ddnd.cn/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>第一章 认识Redis 【Redis入门教程】</title>
    <link href="http://ddnd.cn/2019/02/08/redis-chapter-1/"/>
    <id>http://ddnd.cn/2019/02/08/redis-chapter-1/</id>
    <published>2019-02-08T09:19:29.000Z</published>
    <updated>2019-03-13T11:12:44.120Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><img src="http://ws1.sinaimg.cn/large/e0e01e43gy1fzz559f0n2j21d80gf3zh.jpg" alt="image" width="100%"></p><p><strong>Redis入门教程目录</strong>：<a href="https://ddnd.cn/categories/Redis/">【Redis入门教程目录】</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>Redis</strong>是由C语言编写的开源、基于内存、支持多种数据结构、高性能的<strong>Key-Value</strong>数据库。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="速度快"><a href="#速度快" class="headerlink" title="速度快"></a>速度快</h3><p><strong>首先</strong>Redis是将数据储存在内存中的，通常情况下每秒读写次数达到<strong>千万级别</strong>。<strong>其次</strong>Redis使用<code>ANSI C</code>编写，因为C语言接近操作系统，所以Redis的执行效率很高。<strong>最后</strong>Redis的处理网络请求部分采用的是<strong>单线程</strong>，如果想充分利用CPU资源的话，可以多开几个Redis实例来达到目的，为什么单线程还是速度快的原因呢？我们知道Redis的读写都是基于内存的，读写速度都是非常快的，不会出现需要等待很长时间，所以瓶颈并不会出现在请求读写上，所以没必要使用多线程来利用CPU，如果使用多线程的话（<strong>线程数&gt;CPU数情况下</strong>），多线程的创建、销毁、线程切换、线程竞争等开销所需要的时间会比执行读写所损耗的时间还多，那就南辕北辙了，当然这是在数据量小的时候才会这样，如果数据量到达一定量级了，那肯定是多线程比单线程快（<strong>线程数&lt;=CPU数情况下</strong>）。<br><img src="http://wx4.sinaimg.cn/large/e0e01e43gy1fzzbt51xfuj20w30cvag3.jpg" alt="image"></p><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>Redis可以通过<code>RDB</code>和<code>AOF</code>两种方式将数据持久化到磁盘上，其中这两种方式的区别如下：</p><ul><li><strong>RDB</strong>：是在指定的时间间隔内将内存中的数据通过<strong>异步</strong>生成数据快照并且保存到磁盘中。</li><li><strong>AOF</strong>：相对于<code>RDB</code>方式，<code>AOF</code>方式的持久化更细粒度，把每次数据变化（写、删除操作）都记录<strong>AOF文件</strong>中，其中AOF又可以配置为<code>always</code>即实时将记录写到AOF文件中，<code>everysec</code>每隔一秒将记录写到AOF文件中，<code>no</code>由系统决定何时将记录写到AOF文件中。<h3 id="多种数据结构"><a href="#多种数据结构" class="headerlink" title="多种数据结构"></a>多种数据结构</h3>Redis支持五种基本的数据结构，分别是String（字符串），Hash（哈希），List（列表），Set（集合），Zset（即Sorted Set有序集合）,这些数据结构类型和我们使用的开发语言的数据结构类型其实是相对应的。<br><img src="http://wx2.sinaimg.cn/large/e0e01e43gy1fzzfhx264oj20oc0awq52.jpg" alt="image"><h3 id="多语言客户端"><a href="#多语言客户端" class="headerlink" title="多语言客户端"></a>多语言客户端</h3>Redis支持多种语言，诸如Ruby,Python, Twisted Python, PHP, Erlang, Tcl, Perl, Lua, Java, Scala, Clojure等。<h3 id="功能丰富"><a href="#功能丰富" class="headerlink" title="功能丰富"></a>功能丰富</h3>Redis支持发布订阅、Lua脚本、事务、Pipeline等功能。<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3>在Redis中，用户可以通过执行SLAVEOF命令或者SLAVEOF选项，让从服务器去复制主服务器，为<strong>高可用</strong>和<strong>分布式</strong>提供了基础。<br><img src="http://wx2.sinaimg.cn/large/e0e01e43gy1fzzgkys41kj20pc0hrq7u.jpg" alt="image"><h3 id="高可用和集群"><a href="#高可用和集群" class="headerlink" title="高可用和集群"></a>高可用和集群</h3></li></ul><ol><li>高可用<br>有了主从复制之后的实现之后，如果想对服务器进行监控，那么在<code>Redis2.6</code>以后提供了一个<code>Sentinel</code>（哨兵机制）。顾名思义，哨兵的含义就是监控Redis系统的运行状态，可以启动多个哨兵，去监控Redis数据库的运行状态。其功能有以下两点：<br>a.监控所有节点数据库是否正常运行<br>b.<strong>主数据库</strong>出现故障时，可以通过自动投票机制，在<strong>从数据库</strong>选举出新的主数据库，实现将从数据库转为主数据库的自动切换。</li><li>集群<br>Redis在3.0版本正式引入了<code>Redis-Cluster</code>集群这个特征。Redis-Cluster采用无中心架构，每个节点保存完整的数据和整个集群的状态，每个节点都和其他所有节点连接。<br><img src="http://ws1.sinaimg.cn/large/e0e01e43gy1fzzymliocdj20dr0fun32.jpg" alt="image"></li></ol><h2 id="安装和启动"><a href="#安装和启动" class="headerlink" title="安装和启动"></a>安装和启动</h2><p>使用<code>wget</code>命令下载Redis<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-5.0.3.tar.gz</span><br></pre></td></tr></table></figure></p><p>解压Redis压缩包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xzf redis-5.0.3.tar.gz</span><br></pre></td></tr></table></figure></p><p>进入到Redis的文件夹<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd redis-5.0.3</span><br></pre></td></tr></table></figure></p><p>编译Redis<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></p><p>这样我们的Redis就编译好了，为了能全局使用Redis的命令，我们还需要执行安装命令，将可执行文件安装到环境变量中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure></p><p>这样Redis的安装就完成了，我们来启动Redis，其中Redis的启动有三种方式</p><ol><li>直接启动<br>直接执行<code>redis-server</code>即可启动Redis，这个方式启动实际上就是读取Redis的默认配置启动。</li><li>动态参数启动<br>执行<code>redis-server --port 6380</code>即可指定端口号启动Redis，更多参数可以参考官方的文档。</li><li>配置文件启动<br>执行<code>redis-server config.conf</code>即可指定名为<code>config.conf</code>的配置文件进行启动Redis。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;http://ws1.sinaimg.cn/large/e0e01e43gy1fzz559f0n2j21d80gf3zh.jpg&quot; alt=&quot;image&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Re
      
    
    </summary>
    
      <category term="Redis" scheme="http://ddnd.cn/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>QQ TEA加密算法 JAVA实现</title>
    <link href="http://ddnd.cn/2019/02/07/qq-tea-algorithm/"/>
    <id>http://ddnd.cn/2019/02/07/qq-tea-algorithm/</id>
    <published>2019-02-07T07:04:45.000Z</published>
    <updated>2019-03-13T11:12:35.011Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><img src="http://wx1.sinaimg.cn/large/e0e01e43gy1fzxvlxiq8nj20zf0kzqv5.jpg" alt="image" width="100%"></p><p><strong>TeaUtil.java：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 加密解密QQ消息的工具类. QQ消息的加密算法是一个16次的迭代过程，并且是反馈的，每一个加密单元是8字节，输出也是8字节，密钥是16字节</span><br><span class="line"> * 我们以prePlain表示前一个明文块，plain表示当前明文块，crypt表示当前明文块加密得到的密文块，preCrypt表示前一个密文块</span><br><span class="line"> * f表示加密算法，d表示解密算法 那么从plain得到crypt的过程是: crypt = f(plain &amp;circ; preCrypt) &amp;circ;</span><br><span class="line"> * prePlain 所以，从crypt得到plain的过程自然是 plain = d(crypt &amp;circ; prePlain) &amp;circ;</span><br><span class="line"> * preCrypt 此外，算法有它的填充机制，其会在明文前和明文后分别填充一定的字节数，以保证明文长度是8字节的倍数</span><br><span class="line"> * 填充的字节数与原始明文长度有关，填充的方法是:</span><br><span class="line"> *</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> * &lt;code&gt;</span><br><span class="line"> *</span><br><span class="line"> *      ------- 消息填充算法 -----------</span><br><span class="line"> *      a = (明文长度 + 10) mod 8</span><br><span class="line"> *      if(a 不等于 0) a = 8 - a;</span><br><span class="line"> *      b = 随机数 &amp;amp; 0xF8 | a;              这个的作用是把a的值保存了下来</span><br><span class="line"> *      plain[0] = b;                   然后把b做为明文的第0个字节，这样第0个字节就保存了a的信息，这个信息在解密时就要用来找到真正明文的起始位置</span><br><span class="line"> *      plain[1 至 a+2] = 随机数 &amp;amp; 0xFF;    这里用随机数填充明文的第1到第a+2个字节</span><br><span class="line"> *      plain[a+3 至 a+3+明文长度-1] = 明文; 从a+3字节开始才是真正的明文</span><br><span class="line"> *      plain[a+3+明文长度, 最后] = 0;       在最后，填充0，填充到总长度为8的整数为止。到此为止，结束了，这就是最后得到的要加密的明文内容</span><br><span class="line"> *      ------- 消息填充算法 ------------</span><br><span class="line"> *</span><br><span class="line"> * &lt;/code&gt;</span><br><span class="line"> * &lt;/pre&gt;</span><br><span class="line"> *</span><br><span class="line"> * @author luma</span><br><span class="line"> * @author notXX</span><br><span class="line"> */</span><br><span class="line">public class TeaUtil &#123;</span><br><span class="line">    // 指向当前的明文块</span><br><span class="line">    private byte[] plain;</span><br><span class="line">    // 这指向前面一个明文块</span><br><span class="line">    private byte[] prePlain;</span><br><span class="line">    // 输出的密文或者明文</span><br><span class="line">    private byte[] out;</span><br><span class="line">    // 当前加密的密文位置和上一次加密的密文块位置，他们相差8</span><br><span class="line">    private int crypt, preCrypt;</span><br><span class="line">    // 当前处理的加密解密块的位置</span><br><span class="line">    private int pos;</span><br><span class="line">    // 填充数</span><br><span class="line">    private int padding;</span><br><span class="line">    // 密钥</span><br><span class="line">    private byte[] key;</span><br><span class="line">    // 用于加密时，表示当前是否是第一个8字节块，因为加密算法是反馈的</span><br><span class="line">    // 但是最开始的8个字节没有反馈可用，所有需要标明这种情况</span><br><span class="line">    private boolean header = true;</span><br><span class="line">    // 这个表示当前解密开始的位置，之所以要这么一个变量是为了避免当解密到最后时</span><br><span class="line">    // 后面已经没有数据，这时候就会出错，这个变量就是用来判断这种情况免得出错</span><br><span class="line">    private int contextStart;</span><br><span class="line">    // 随机数对象</span><br><span class="line">    private static Random random = new Random();</span><br><span class="line">    // 字节输出流</span><br><span class="line">    private ByteArrayOutputStream baos;</span><br><span class="line">    /**</span><br><span class="line">     * 构造函数</span><br><span class="line">     */</span><br><span class="line">    public TeaUtil() &#123;</span><br><span class="line">        baos = new ByteArrayOutputStream(8);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 把字节数组从offset开始的len个字节转换成一个unsigned int， 因为java里面没有unsigned，所以unsigned</span><br><span class="line">     * int使用long表示的， 如果len大于8，则认为len等于8。如果len小于8，则高位填0 &lt;br&gt;</span><br><span class="line">     * (edited by notxx) 改变了算法, 性能稍微好一点. 在我的机器上测试10000次, 原始算法花费18s, 这个算法花费12s.</span><br><span class="line">     *</span><br><span class="line">     * @param in</span><br><span class="line">     *                   字节数组.</span><br><span class="line">     * @param offset</span><br><span class="line">     *                   从哪里开始转换.</span><br><span class="line">     * @param len</span><br><span class="line">     *                   转换长度, 如果len超过8则忽略后面的</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static long getUnsignedInt(byte[] in, int offset, int len) &#123;</span><br><span class="line">        long ret = 0;</span><br><span class="line">        int end = 0;</span><br><span class="line">        if (len &gt; 8)</span><br><span class="line">            end = offset + 8;</span><br><span class="line">        else</span><br><span class="line">            end = offset + len;</span><br><span class="line">        for (int i = offset; i &lt; end; i++) &#123;</span><br><span class="line">            ret &lt;&lt;= 8;</span><br><span class="line">            ret |= in[i] &amp; 0xff;</span><br><span class="line">        &#125;</span><br><span class="line">        return (ret &amp; 0xffffffffl) | (ret &gt;&gt;&gt; 32);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解密</span><br><span class="line">     * @param in 密文</span><br><span class="line">     * @param offset 密文开始的位置</span><br><span class="line">     * @param len 密文长度</span><br><span class="line">     * @param k 密钥</span><br><span class="line">     * @return 明文</span><br><span class="line">     */</span><br><span class="line">    public byte[] decrypt(byte[] in, int offset, int len, byte[] k) &#123;</span><br><span class="line">        // 检查密钥</span><br><span class="line">        if(k == null)</span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">        crypt = preCrypt = 0;</span><br><span class="line">        this.key = k;</span><br><span class="line">        int count;</span><br><span class="line">        byte[] m = new byte[offset + 8];</span><br><span class="line"></span><br><span class="line">        // 因为QQ消息加密之后至少是16字节，并且肯定是8的倍数，这里检查这种情况</span><br><span class="line">        if((len % 8 != 0) || (len &lt; 16)) return null;</span><br><span class="line">        // 得到消息的头部，关键是得到真正明文开始的位置，这个信息存在第一个字节里面，所以其用解密得到的第一个字节与7做与</span><br><span class="line">        prePlain = decipher(in, offset);</span><br><span class="line">        pos = prePlain[0] &amp; 0x7;</span><br><span class="line">        // 得到真正明文的长度</span><br><span class="line">        count = len - pos - 10;</span><br><span class="line">        // 如果明文长度小于0，那肯定是出错了，比如传输错误之类的，返回</span><br><span class="line">        if(count &lt; 0) return null;</span><br><span class="line"></span><br><span class="line">        // 这个是临时的preCrypt，和加密时第一个8字节块没有prePlain一样，解密时</span><br><span class="line">        // 第一个8字节块也没有preCrypt，所有这里建一个全0的</span><br><span class="line">        for(int i = offset; i &lt; m.length; i++)</span><br><span class="line">            m[i] = 0;</span><br><span class="line">        // 通过了上面的代码，密文应该是没有问题了，我们分配输出缓冲区</span><br><span class="line">        out = new byte[count];</span><br><span class="line">        // 设置preCrypt的位置等于0，注意目前的preCrypt位置是指向m的，因为java没有指针，所以我们在后面要控制当前密文buf的引用</span><br><span class="line">        preCrypt = 0;</span><br><span class="line">        // 当前的密文位置，为什么是8不是0呢？注意前面我们已经解密了头部信息了，现在当然该8了</span><br><span class="line">        crypt = 8;</span><br><span class="line">        // 自然这个也是8</span><br><span class="line">        contextStart = 8;</span><br><span class="line">        // 加1，和加密算法是对应的</span><br><span class="line">        pos++;</span><br><span class="line"></span><br><span class="line">        // 开始跳过头部，如果在这个过程中满了8字节，则解密下一块</span><br><span class="line">        // 因为是解密下一块，所以我们有一个语句 m = in，下一块当然有preCrypt了，我们不再用m了</span><br><span class="line">        // 但是如果不满8，这说明了什么？说明了头8个字节的密文是包含了明文信息的，当然还是要用m把明文弄出来</span><br><span class="line">        // 所以，很显然，满了8的话，说明了头8个字节的密文除了一个长度信息有用之外，其他都是无用的填充</span><br><span class="line">        padding = 1;</span><br><span class="line">        while(padding &lt;= 2) &#123;</span><br><span class="line">            if(pos &lt; 8) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">                padding++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(pos == 8) &#123;</span><br><span class="line">                m = in;</span><br><span class="line">                if(!decrypt8Bytes(in, offset, len)) return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 这里是解密的重要阶段，这个时候头部的填充都已经跳过了，开始解密</span><br><span class="line">        // 注意如果上面一个while没有满8，这里第一个if里面用的就是原始的m，否则这个m就是in了</span><br><span class="line">        int i = 0;</span><br><span class="line">        while(count != 0) &#123;</span><br><span class="line">            if(pos &lt; 8) &#123;</span><br><span class="line">                out[i] = (byte)(m[offset + preCrypt + pos] ^ prePlain[pos]);</span><br><span class="line">                i++;</span><br><span class="line">                count--;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(pos == 8) &#123;</span><br><span class="line">                m = in;</span><br><span class="line">                preCrypt = crypt - 8;</span><br><span class="line">                if(!decrypt8Bytes(in, offset, len))</span><br><span class="line">                    return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 最后的解密部分，上面一个while已经把明文都解出来了，就剩下尾部的填充了，应该全是0</span><br><span class="line">        // 所以这里有检查是否解密了之后是不是0，如果不是的话那肯定出错了，返回null</span><br><span class="line">        for(padding = 1; padding &lt; 8; padding++) &#123;</span><br><span class="line">            if(pos &lt; 8) &#123;</span><br><span class="line">                if((m[offset + preCrypt + pos] ^ prePlain[pos]) != 0)</span><br><span class="line">                    return null;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(pos == 8) &#123;</span><br><span class="line">                m = in;</span><br><span class="line">                preCrypt = crypt;</span><br><span class="line">                if(!decrypt8Bytes(in, offset, len))</span><br><span class="line">                    return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param in</span><br><span class="line">     *            需要被解密的密文</span><br><span class="line">     * @paraminLen</span><br><span class="line">     *            密文长度</span><br><span class="line">     * @param k</span><br><span class="line">     *            密钥</span><br><span class="line">     * @return Message 已解密的消息</span><br><span class="line">     */</span><br><span class="line">    public byte[] decrypt(byte[] in, byte[] k) &#123;</span><br><span class="line">        return decrypt(in, 0, in.length, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 加密</span><br><span class="line">     * @param in 明文字节数组</span><br><span class="line">     * @param offset 开始加密的偏移</span><br><span class="line">     * @param len 加密长度</span><br><span class="line">     * @param k 密钥</span><br><span class="line">     * @return 密文字节数组</span><br><span class="line">     */</span><br><span class="line">    public byte[] encrypt(byte[] in, int offset, int len, byte[] k) &#123;</span><br><span class="line">        // 检查密钥</span><br><span class="line">        if(k == null)</span><br><span class="line">            return in;</span><br><span class="line"></span><br><span class="line">        plain = new byte[8];</span><br><span class="line">        prePlain = new byte[8];</span><br><span class="line">        pos = 1;</span><br><span class="line">        padding = 0;</span><br><span class="line">        crypt = preCrypt = 0;</span><br><span class="line">        this.key = k;</span><br><span class="line">        header = true;</span><br><span class="line"></span><br><span class="line">        // 计算头部填充字节数</span><br><span class="line">        pos = (len + 0x0A) % 8;</span><br><span class="line">        if(pos != 0)</span><br><span class="line">            pos = 8 - pos;</span><br><span class="line">        // 计算输出的密文长度</span><br><span class="line">        out = new byte[len + pos + 10];</span><br><span class="line">        // 这里的操作把pos存到了plain的第一个字节里面</span><br><span class="line">        // 0xF8后面三位是空的，正好留给pos，因为pos是0到7的值，表示文本开始的字节位置</span><br><span class="line">        plain[0] = (byte)((rand() &amp; 0xF8) | pos);</span><br><span class="line"></span><br><span class="line">        // 这里用随机产生的数填充plain[1]到plain[pos]之间的内容</span><br><span class="line">        for(int i = 1; i &lt;= pos; i++)</span><br><span class="line">            plain[i] = (byte)(rand() &amp; 0xFF);</span><br><span class="line">        pos++;</span><br><span class="line">        // 这个就是prePlain，第一个8字节块当然没有prePlain，所以我们做一个全0的给第一个8字节块</span><br><span class="line">        for(int i = 0; i &lt; 8; i++)</span><br><span class="line">            prePlain[i] = 0x0;</span><br><span class="line"></span><br><span class="line">        // 继续填充2个字节的随机数，这个过程中如果满了8字节就加密之</span><br><span class="line">        padding = 1;</span><br><span class="line">        while(padding &lt;= 2) &#123;</span><br><span class="line">            if(pos &lt; 8) &#123;</span><br><span class="line">                plain[pos++] = (byte)(rand() &amp; 0xFF);</span><br><span class="line">                padding++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(pos == 8)</span><br><span class="line">                encrypt8Bytes();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 头部填充完了，这里开始填真正的明文了，也是满了8字节就加密，一直到明文读完</span><br><span class="line">        int i = offset;</span><br><span class="line">        while(len &gt; 0) &#123;</span><br><span class="line">            if(pos &lt; 8) &#123;</span><br><span class="line">                plain[pos++] = in[i++];</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            if(pos == 8)</span><br><span class="line">                encrypt8Bytes();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 最后填上0，以保证是8字节的倍数</span><br><span class="line">        padding = 1;</span><br><span class="line">        while(padding &lt;= 7) &#123;</span><br><span class="line">            if(pos &lt; 8) &#123;</span><br><span class="line">                plain[pos++] = 0x0;</span><br><span class="line">                padding++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(pos == 8)</span><br><span class="line">                encrypt8Bytes();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param in</span><br><span class="line">     *            需要加密的明文</span><br><span class="line">     * @paraminLen</span><br><span class="line">     *            明文长度</span><br><span class="line">     * @param k</span><br><span class="line">     *            密钥</span><br><span class="line">     * @return Message 密文</span><br><span class="line">     */</span><br><span class="line">    public byte[] encrypt(byte[] in, byte[] k) &#123;</span><br><span class="line">        return encrypt(in, 0, in.length, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 加密一个8字节块</span><br><span class="line">     *</span><br><span class="line">     * @param in</span><br><span class="line">     * 明文字节数组</span><br><span class="line">     * @return</span><br><span class="line">     * 密文字节数组</span><br><span class="line">     */</span><br><span class="line">    private byte[] encipher(byte[] in) &#123;</span><br><span class="line">        // 迭代次数，16次</span><br><span class="line">        int loop = 0x10;</span><br><span class="line">        // 得到明文和密钥的各个部分，注意java没有无符号类型，所以为了表示一个无符号的整数</span><br><span class="line">        // 我们用了long，这个long的前32位是全0的，我们通过这种方式模拟无符号整数，后面用到的long也都是一样的</span><br><span class="line">        // 而且为了保证前32位为0，需要和0xFFFFFFFF做一下位与</span><br><span class="line">        long y = getUnsignedInt(in, 0, 4);</span><br><span class="line">        long z = getUnsignedInt(in, 4, 4);</span><br><span class="line">        long a = getUnsignedInt(key, 0, 4);</span><br><span class="line">        long b = getUnsignedInt(key, 4, 4);</span><br><span class="line">        long c = getUnsignedInt(key, 8, 4);</span><br><span class="line">        long d = getUnsignedInt(key, 12, 4);</span><br><span class="line">        // 这是算法的一些控制变量，为什么delta是0x9E3779B9呢？</span><br><span class="line">        // 这个数是TEA算法的delta，实际是就是(sqr(5) - 1) * 2^31 (根号5，减1，再乘2的31次方)</span><br><span class="line">        long sum = 0;</span><br><span class="line">        long delta = 0x9E3779B9;</span><br><span class="line">        delta &amp;= 0xFFFFFFFFL;</span><br><span class="line"></span><br><span class="line">        // 开始迭代了，乱七八糟的，我也看不懂，反正和DES之类的差不多，都是这样倒来倒去</span><br><span class="line">        while (loop-- &gt; 0) &#123;</span><br><span class="line">            sum += delta;</span><br><span class="line">            sum &amp;= 0xFFFFFFFFL;</span><br><span class="line">            y += ((z &lt;&lt; 4) + a) ^ (z + sum) ^ ((z &gt;&gt;&gt; 5) + b);</span><br><span class="line">            y &amp;= 0xFFFFFFFFL;</span><br><span class="line">            z += ((y &lt;&lt; 4) + c) ^ (y + sum) ^ ((y &gt;&gt;&gt; 5) + d);</span><br><span class="line">            z &amp;= 0xFFFFFFFFL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 最后，我们输出密文，因为我用的long，所以需要强制转换一下变成int</span><br><span class="line">        baos.reset();</span><br><span class="line">        writeInt((int)y);</span><br><span class="line">        writeInt((int)z);</span><br><span class="line">        return baos.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解密从offset开始的8字节密文</span><br><span class="line">     *</span><br><span class="line">     * @param in</span><br><span class="line">     * 密文字节数组</span><br><span class="line">     * @param offset</span><br><span class="line">     * 密文开始位置</span><br><span class="line">     * @return</span><br><span class="line">     * 明文</span><br><span class="line">     */</span><br><span class="line">    private byte[] decipher(byte[] in, int offset) &#123;</span><br><span class="line">        // 迭代次数，16次</span><br><span class="line">        int loop = 0x10;</span><br><span class="line">        // 得到密文和密钥的各个部分，注意java没有无符号类型，所以为了表示一个无符号的整数</span><br><span class="line">        // 我们用了long，这个long的前32位是全0的，我们通过这种方式模拟无符号整数，后面用到的long也都是一样的</span><br><span class="line">        // 而且为了保证前32位为0，需要和0xFFFFFFFF做一下位与</span><br><span class="line">        long y = getUnsignedInt(in, offset, 4);</span><br><span class="line">        long z = getUnsignedInt(in, offset + 4, 4);</span><br><span class="line">        long a = getUnsignedInt(key, 0, 4);</span><br><span class="line">        long b = getUnsignedInt(key, 4, 4);</span><br><span class="line">        long c = getUnsignedInt(key, 8, 4);</span><br><span class="line">        long d = getUnsignedInt(key, 12, 4);</span><br><span class="line">        // 算法的一些控制变量，sum在这里也有数了，这个sum和迭代次数有关系</span><br><span class="line">        // 因为delta是这么多，所以sum如果是这么多的话，迭代的时候减减减，减16次，最后</span><br><span class="line">        // 得到0。反正这就是为了得到和加密时相反顺序的控制变量，这样才能解密呀～～</span><br><span class="line">        long sum = 0xE3779B90;</span><br><span class="line">        sum &amp;= 0xFFFFFFFFL;</span><br><span class="line">        long delta = 0x9E3779B9;</span><br><span class="line">        delta &amp;= 0xFFFFFFFFL;</span><br><span class="line"></span><br><span class="line">        // 迭代开始了， @_@</span><br><span class="line">        while(loop-- &gt; 0) &#123;</span><br><span class="line">            z -= ((y &lt;&lt; 4) + c) ^ (y + sum) ^ ((y &gt;&gt;&gt; 5) + d);</span><br><span class="line">            z &amp;= 0xFFFFFFFFL;</span><br><span class="line">            y -= ((z &lt;&lt; 4) + a) ^ (z + sum) ^ ((z &gt;&gt;&gt; 5) + b);</span><br><span class="line">            y &amp;= 0xFFFFFFFFL;</span><br><span class="line">            sum -= delta;</span><br><span class="line">            sum &amp;= 0xFFFFFFFFL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        baos.reset();</span><br><span class="line">        writeInt((int)y);</span><br><span class="line">        writeInt((int)z);</span><br><span class="line">        return baos.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 写入一个整型到输出流，高字节优先</span><br><span class="line">     *</span><br><span class="line">     * @param t</span><br><span class="line">     */</span><br><span class="line">    private void writeInt(int t) &#123;</span><br><span class="line">        baos.write(t &gt;&gt;&gt; 24);</span><br><span class="line">        baos.write(t &gt;&gt;&gt; 16);</span><br><span class="line">        baos.write(t &gt;&gt;&gt; 8);</span><br><span class="line">        baos.write(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解密</span><br><span class="line">     *</span><br><span class="line">     * @param in</span><br><span class="line">     * 密文</span><br><span class="line">     * @return</span><br><span class="line">     * 明文</span><br><span class="line">     */</span><br><span class="line">    private byte[] decipher(byte[] in) &#123;</span><br><span class="line">        return decipher(in, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 加密8字节</span><br><span class="line">     */</span><br><span class="line">    private void encrypt8Bytes() &#123;</span><br><span class="line">        // 这部分完成我上面所说的 plain ^ preCrypt，注意这里判断了是不是第一个8字节块，如果是的话，那个prePlain就当作preCrypt用</span><br><span class="line">        for(pos = 0; pos &lt; 8; pos++) &#123;</span><br><span class="line">            if(header)</span><br><span class="line">                plain[pos] ^= prePlain[pos];</span><br><span class="line">            else</span><br><span class="line">                plain[pos] ^= out[preCrypt + pos];</span><br><span class="line">        &#125;</span><br><span class="line">        // 这个完成我上面说的 f(plain ^ preCrypt)</span><br><span class="line">        byte[] crypted = encipher(plain);</span><br><span class="line">        // 这个没什么，就是拷贝一下，java不像c，所以我只好这么干，c就不用这一步了</span><br><span class="line">        System.arraycopy(crypted, 0, out, crypt, 8);</span><br><span class="line"></span><br><span class="line">        // 这个完成了 f(plain ^ preCrypt) ^ prePlain，ok，下面拷贝一下就行了</span><br><span class="line">        for(pos = 0; pos &lt; 8; pos++)</span><br><span class="line">            out[crypt + pos] ^= prePlain[pos];</span><br><span class="line">        System.arraycopy(plain, 0, prePlain, 0, 8);</span><br><span class="line"></span><br><span class="line">        // 完成了加密，现在是调整crypt，preCrypt等等东西的时候了</span><br><span class="line">        preCrypt = crypt;</span><br><span class="line">        crypt += 8;</span><br><span class="line">        pos = 0;</span><br><span class="line">        header = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解密8个字节</span><br><span class="line">     *</span><br><span class="line">     * @param in</span><br><span class="line">     * 密文字节数组</span><br><span class="line">     * @param offset</span><br><span class="line">     * 从何处开始解密</span><br><span class="line">     * @param len</span><br><span class="line">     * 密文的长度</span><br><span class="line">     * @return</span><br><span class="line">     * true表示解密成功</span><br><span class="line">     */</span><br><span class="line">    private boolean decrypt8Bytes(byte[] in , int offset, int len) &#123;</span><br><span class="line">        // 这里第一步就是判断后面还有没有数据，没有就返回，如果有，就执行 crypt ^ prePlain</span><br><span class="line">        for(pos = 0; pos &lt; 8; pos++) &#123;</span><br><span class="line">            if(contextStart + pos &gt;= len)</span><br><span class="line">                return true;</span><br><span class="line">            prePlain[pos] ^= in[offset + crypt + pos];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 好，这里执行到了 d(crypt ^ prePlain)</span><br><span class="line">        prePlain = decipher(prePlain);</span><br><span class="line">        if(prePlain == null)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        // 解密完成，最后一步好像没做？</span><br><span class="line">        // 这里最后一步放到decrypt里面去做了，因为解密的步骤有点不太一样</span><br><span class="line">        // 调整这些变量的值先</span><br><span class="line">        contextStart += 8;</span><br><span class="line">        crypt += 8;</span><br><span class="line">        pos = 0;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这是个随机因子产生器，用来填充头部的，如果为了调试，可以用一个固定值</span><br><span class="line">     * 随机因子可以使相同的明文每次加密出来的密文都不一样</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     * 随机因子</span><br><span class="line">     */</span><br><span class="line">    private int rand() &#123;</span><br><span class="line">        return random.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用算法加解密：<br><strong>Test.java:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        byte[] KEY = new byte[]&#123;//KEY</span><br><span class="line">                0x00000000, 0x00000000,</span><br><span class="line">                0x00000000, 0x00000000,</span><br><span class="line">                0x00000000, 0x00000000,</span><br><span class="line">                0x00000000, 0x00000000,</span><br><span class="line">                0x00000000, 0x00000000,</span><br><span class="line">                0x00000000, 0x00000000,</span><br><span class="line">                0x00000000, 0x00000000,</span><br><span class="line">                0x00000000, 0x00000000,</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        byte[] content = new byte[]&#123;//加密内容</span><br><span class="line">                0x00000000, 0x00000000,</span><br><span class="line">                0x00000000, 0x00000000,</span><br><span class="line">        &#125;;        </span><br><span class="line">        </span><br><span class="line">        TeaUtil teaUtil = new TeaUtil();</span><br><span class="line">        byte[] enByte = teaUtil.encrypt(content,KEY); //加密后的字节</span><br><span class="line">        byte[] deByte = teaUtil.decrypt(enByte,KEY); //解密后的字节</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;http://wx1.sinaimg.cn/large/e0e01e43gy1fzxvlxiq8nj20zf0kzqv5.jpg&quot; alt=&quot;image&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Te
      
    
    </summary>
    
      <category term="技术杂谈" scheme="http://ddnd.cn/categories/Technique/"/>
    
    
      <category term="TEA算法" scheme="http://ddnd.cn/tags/TEA%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
