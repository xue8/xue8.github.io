<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000">
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top">
  
  
  <title>一文带你快速掌握AQS | 薛8的个人网站 - xue8&#39;s Blog - DDND.CN</title>
  <meta name="description" content="AbstractQueuedSynchronizer简介AbstractQueuedSynchronizer抽象队列同步器，简称为AQS，可用于构建阻塞锁或者其他相关同步器的基础框，是Java并发包的基础工具类。通过AQS这个框架可以对同步状态原子性管理、线程的阻塞和解除阻塞、队列的管理进行统一管理。AQS是抽象类，并不能直接实例化，当需要使用AQS的时候需要继承AQS抽象类并且重写指定的方法，">
<meta name="keywords" content="多线程,AQS">
<meta property="og:type" content="article">
<meta property="og:title" content="一文带你快速掌握AQS">
<meta property="og:url" content="http://ddnd.cn/2019/03/15/java-abstractqueuedsynchronizer/index.html">
<meta property="og:site_name" content="薛8的个人网站 - xue8&#39;s Blog - DDND.CN">
<meta property="og:description" content="AbstractQueuedSynchronizer简介AbstractQueuedSynchronizer抽象队列同步器，简称为AQS，可用于构建阻塞锁或者其他相关同步器的基础框，是Java并发包的基础工具类。通过AQS这个框架可以对同步状态原子性管理、线程的阻塞和解除阻塞、队列的管理进行统一管理。AQS是抽象类，并不能直接实例化，当需要使用AQS的时候需要继承AQS抽象类并且重写指定的方法，">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://ws1.sinaimg.cn/large/e0e01e43ly1g13rtsdq9xj21c61041ky.jpg">
<meta property="og:image" content="http://wx3.sinaimg.cn/large/e0e01e43ly1g13rma1mnmj20v207ngml.jpg">
<meta property="og:image" content="http://ws3.sinaimg.cn/large/e0e01e43ly1g13rmm2wtsj21ep0n4b29.jpg">
<meta property="og:image" content="http://ws1.sinaimg.cn/large/e0e01e43ly1g13rmuy8ikj20rm071js5.jpg">
<meta property="og:image" content="http://ws4.sinaimg.cn/large/e0e01e43ly1g13rn1r0hjj20wc10fgps.jpg">
<meta property="og:image" content="http://wx2.sinaimg.cn/large/e0e01e43ly1g13rn6zuazj20s709j3zt.jpg">
<meta property="og:image" content="http://ws3.sinaimg.cn/large/e0e01e43ly1g13rne0t7dj20qh0pkjt8.jpg">
<meta property="og:image" content="http://ws2.sinaimg.cn/large/e0e01e43ly1g13rnoe29bj213i10f0xf.jpg">
<meta property="og:image" content="http://wx2.sinaimg.cn/large/e0e01e43ly1g13rntqlntj20yw0a9acj.jpg">
<meta property="og:image" content="http://ws2.sinaimg.cn/large/e0e01e43ly1g13ro03soyj21601cx0yr.jpg">
<meta property="og:image" content="http://wx4.sinaimg.cn/large/e0e01e43ly1g13rodrehcj20md0hajy9.jpg">
<meta property="og:image" content="http://ws1.sinaimg.cn/large/e0e01e43ly1g13rooch2sj20y407bdh0.jpg">
<meta property="og:image" content="http://wx2.sinaimg.cn/large/e0e01e43ly1g13rotlu30j20za06wgmq.jpg">
<meta property="og:updated_time" content="2019-03-15T12:52:47.248Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一文带你快速掌握AQS">
<meta name="twitter:description" content="AbstractQueuedSynchronizer简介AbstractQueuedSynchronizer抽象队列同步器，简称为AQS，可用于构建阻塞锁或者其他相关同步器的基础框，是Java并发包的基础工具类。通过AQS这个框架可以对同步状态原子性管理、线程的阻塞和解除阻塞、队列的管理进行统一管理。AQS是抽象类，并不能直接实例化，当需要使用AQS的时候需要继承AQS抽象类并且重写指定的方法，">
<meta name="twitter:image" content="http://ws1.sinaimg.cn/large/e0e01e43ly1g13rtsdq9xj21c61041ky.jpg">
  <!-- Canonical links -->
  <link rel="canonical" href="http://ddnd.cn/2019/03/15/java-abstractqueuedsynchronizer/index.html">
  
    <link rel="alternate" href="/atom.xml" title="薛8的个人网站 - xue8&#39;s Blog - DDND.CN" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  <link rel="stylesheet" href="/css/style.css">
  
  
  
  
</head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope="" itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/xue8" target="_blank">
          <img class="img-circle img-rotate" src="/img/logo.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">薛8</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Web Developer</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Guiling, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="Search">
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="Type something..." x-webkit-speech="">
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope="" itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">Home</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">Archives</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">Categories</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">Tags</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">Links</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">About</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/xue8" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope="" itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">Board</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java-Programming/">Java编程基础</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mybatis-Programming/">Mybatis</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Shiro/">Shiro</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Programming/">Spring</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-MVC/">Spring MVC</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Technique/">技术杂谈</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Computer-Foundation/">计算机基础</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-body">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AQS/">AQS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CAS/">CAS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ConcurrentHashMap/">ConcurrentHashMap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/">HashMap</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hashtable/">Hashtable</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java内存模型/">Java内存模型</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jdbc/">Jdbc</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVC/">MVC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/">Mybatis</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTful/">RESTful</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPC/">RPC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shiro/">Shiro</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-MVC/">Spring MVC</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-MVC/">Spring-MVC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TEA算法/">TEA算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TomcatDBCP/">TomcatDBCP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebSocket/">WebSocket</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/">servlet</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/synchronized/">synchronized</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/volatile/">volatile</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web-xml/">web.xml</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机内存模型/">计算机内存模型</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/连接池/">连接池</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/AQS/" style="font-size: 13px;">AQS</a> <a href="/tags/CAS/" style="font-size: 13px;">CAS</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 13px;">ConcurrentHashMap</a> <a href="/tags/HashMap/" style="font-size: 13.25px;">HashMap</a> <a href="/tags/Hashtable/" style="font-size: 13.25px;">Hashtable</a> <a href="/tags/JVM/" style="font-size: 13px;">JVM</a> <a href="/tags/Java内存模型/" style="font-size: 13px;">Java内存模型</a> <a href="/tags/Jdbc/" style="font-size: 13.5px;">Jdbc</a> <a href="/tags/MVC/" style="font-size: 13px;">MVC</a> <a href="/tags/Mybatis/" style="font-size: 13.75px;">Mybatis</a> <a href="/tags/RESTful/" style="font-size: 13px;">RESTful</a> <a href="/tags/RPC/" style="font-size: 13px;">RPC</a> <a href="/tags/Shiro/" style="font-size: 13.25px;">Shiro</a> <a href="/tags/Spring/" style="font-size: 13.75px;">Spring</a> <a href="/tags/Spring-MVC/" style="font-size: 13.25px;">Spring MVC</a> <a href="/tags/Spring-MVC/" style="font-size: 13px;">Spring-MVC</a> <a href="/tags/TEA算法/" style="font-size: 13px;">TEA算法</a> <a href="/tags/TomcatDBCP/" style="font-size: 13px;">TomcatDBCP</a> <a href="/tags/WebSocket/" style="font-size: 13px;">WebSocket</a> <a href="/tags/servlet/" style="font-size: 13px;">servlet</a> <a href="/tags/synchronized/" style="font-size: 13.25px;">synchronized</a> <a href="/tags/volatile/" style="font-size: 13px;">volatile</a> <a href="/tags/web-xml/" style="font-size: 13px;">web.xml</a> <a href="/tags/多线程/" style="font-size: 14px;">多线程</a> <a href="/tags/计算机内存模型/" style="font-size: 13px;">计算机内存模型</a> <a href="/tags/连接池/" style="font-size: 13px;">连接池</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">Archive</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">12</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Java-Programming/">Java编程基础</a>
              </p>
              <p class="item-title">
                <a href="/2019/03/22/java-synchronized-2/" class="title">深入分析synchronized原理和锁膨胀过程(二)</a>
              </p>
              <p class="item-date">
                <time datetime="2019-03-22T15:10:17.000Z" itemprop="datePublished">2019-03-22</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Java-Programming/">Java编程基础</a>
              </p>
              <p class="item-title">
                <a href="/2019/03/21/java-synchronized/" class="title">synchronized的使用（一）</a>
              </p>
              <p class="item-date">
                <time datetime="2019-03-21T10:14:36.000Z" itemprop="datePublished">2019-03-21</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Java-Programming/">Java编程基础</a>
              </p>
              <p class="item-title">
                <a href="/2019/03/19/java-volatile/" class="title">Java volatile关键字解析</a>
              </p>
              <p class="item-date">
                <time datetime="2019-03-19T07:21:09.000Z" itemprop="datePublished">2019-03-19</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Java-Programming/">Java编程基础</a>
              </p>
              <p class="item-title">
                <a href="/2019/03/15/java-abstractqueuedsynchronizer/" class="title">一文带你快速掌握AQS</a>
              </p>
              <p class="item-date">
                <time datetime="2019-03-15T13:53:03.000Z" itemprop="datePublished">2019-03-15</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Java-Programming/">Java编程基础</a>
              </p>
              <p class="item-title">
                <a href="/2019/03/13/java-cas/" class="title">CAS原理分析及ABA问题详解</a>
              </p>
              <p class="item-date">
                <time datetime="2019-03-13T09:09:33.000Z" itemprop="datePublished">2019-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope="" itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">Catalogue</h3>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#AbstractQueuedSynchronizer简介"><span class="toc-number">1.</span> <span class="toc-text">AbstractQueuedSynchronizer简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS数据结构"><span class="toc-number">2.</span> <span class="toc-text">AQS数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS的功能"><span class="toc-number">3.</span> <span class="toc-text">AQS的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#同步队列"><span class="toc-number">3.1.</span> <span class="toc-text">同步队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#独占模式"><span class="toc-number">3.1.1.</span> <span class="toc-text">独占模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#获取资源"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">获取资源</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#释放资源"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">释放资源</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#共享模式"><span class="toc-number">3.1.2.</span> <span class="toc-text">共享模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#获取资源-1"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">获取资源</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#释放资源-1"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">释放资源</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#普通队列"><span class="toc-number">3.2.</span> <span class="toc-text">普通队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步队列和普通队列的关系"><span class="toc-number">3.3.</span> <span class="toc-text">同步队列和普通队列的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">4.</span> <span class="toc-text">参考</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-java-abstractqueuedsynchronizer" class="article article-type-post" itemscope="" itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      一文带你快速掌握AQS
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2019/03/15/java-abstractqueuedsynchronizer/" class="article-date">
	  <time datetime="2019-03-15T13:53:03.000Z" itemprop="datePublished">2019-03-15</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Java-Programming/">Java编程基础</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/AQS/">AQS</a>, <a class="article-tag-link" href="/tags/多线程/">多线程</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2019/03/15/java-abstractqueuedsynchronizer/#comments" class="article-comment-link">Comments</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">Word Count: 5.8k(words)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">Read Count: 22(minutes)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p><img src="http://ws1.sinaimg.cn/large/e0e01e43ly1g13rtsdq9xj21c61041ky.jpg" alt="image" width="100%"></p>
<h2 id="AbstractQueuedSynchronizer简介"><a href="#AbstractQueuedSynchronizer简介" class="headerlink" title="AbstractQueuedSynchronizer简介"></a>AbstractQueuedSynchronizer简介</h2><p><strong><code>AbstractQueuedSynchronizer</code>抽象队列同步器</strong>，简称为<code>AQS</code>，可用于构建<strong>阻塞锁</strong>或者其他相关<strong>同步器</strong>的基础框，是Java并发包的基础工具类。通过<code>AQS</code>这个框架可以对<strong>同步状态原子性管理、线程的阻塞和解除阻塞、队列的管理</strong>进行统一管理。<br><code>AQS</code>是抽象类，并不能直接实例化，当需要使用<code>AQS</code>的时候需要继承<code>AQS</code>抽象类并且重写指定的方法，这些重写方法包括<strong>线程获取资源和释放资源的方式</strong>(如ReentractLock通过分别重写线程获取和释放资源的方式实现了公平锁和非公平锁)，<strong>同时子类还需要负责共享变量state的维护，如当state为0时表示该锁没有被占，大于0时候代表该锁被一个或多个线程占领(重入锁)</strong>，而队列的维护(获取资源失败入队、线程唤醒、线程的状态等)不需要我们考虑，<code>AQS</code>已经帮我们实现好了。<code>AQS</code>的这种设计模式采用的正是<strong>模板方法模式</strong>。<br><strong>总结起来子类的任务有：</strong>   </p>
<ol>
<li>通过<code>CAS</code>操作维护共享变量<code>state</code>。</li>
<li>重写资源的获取方式。</li>
<li>重写资源释放的方式。<blockquote>
<p>如果对CAS和Java内存模型还不清楚的，建议先了解这两者之后再食用本文，效果更佳！<a href="https://ddnd.cn/2019/03/13/java-cas/">CAS原理分析及ABA问题详解</a>         <a href="https://ddnd.cn/2019/03/11/java-memory-model/">什么是Java内存模型？</a></p>
</blockquote>
</li>
</ol>
<p>完成以上三个任务即可实现自己的锁。<br><code>AQS</code>作为<code>J.U.C</code>的工具类，面向的是需要实现<strong>锁的实现者</strong>，而锁面向的是<strong>锁的使用者</strong>，这两者的区别还是需要搞清楚的。</p>
<h2 id="AQS数据结构"><a href="#AQS数据结构" class="headerlink" title="AQS数据结构"></a>AQS数据结构</h2><p>先看<code>AQS</code>有哪些重要的成员变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的</span><br><span class="line">private transient volatile Node head;</span><br><span class="line"></span><br><span class="line">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span><br><span class="line">private transient volatile Node tail;</span><br><span class="line"></span><br><span class="line">// 这个是最重要的，不过也是最简单的，代表当前锁的状态，0代表没有被占用，大于0代表有线程持有当前锁</span><br><span class="line">// 之所以说大于0，而不是等于1，是因为锁可以重入嘛，每次重入都加上1</span><br><span class="line">private volatile int state;</span><br><span class="line"></span><br><span class="line">// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入</span><br><span class="line">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span><br><span class="line">// if (currentThread == getExclusiveOwnerThread()) &#123;state++&#125;</span><br><span class="line">private transient Thread exclusiveOwnerThread; //继承自AbstractOwnableSynchronizer</span><br></pre></td></tr></table></figure></p>
<p>然后再看看<code>AQS</code>的内部结构，<code>AQS</code>内部数据结构为一个<strong>双向链表</strong>和一个<strong>单向链表</strong>，双链表为同步队列，队列中的每个节点对应一个<code>Node</code>内部类，<code>AQS</code>通过控制链表的节点而达到阻塞、同步的目的，单链表为普通队列，<strong>可以把同步队列理解为储存阻塞状态的线程，而普通队列储存的是等待状态的线程</strong>，普通队列中的线程并不能直接去获取资源，而要先从普通队列转到同步队列中排队获取，一个线程要么是在同步队列中，要么是在普通队列中，不可能同时存在这两个队列里面。</p>
<p><img src="http://wx3.sinaimg.cn/large/e0e01e43ly1g13rma1mnmj20v207ngml.jpg" alt="image"></p>
<blockquote>
<p>Java<strong>阻塞状态</strong>和<strong>等待状态</strong>的线程从Linux内核来看，都是阻塞(等待)状态，它们都会让出CPU时间片。Java为了方便管理线程将“阻塞(等待)”状态细分成了阻塞状态和等待状态，这两个状态的区别<strong>在于由谁去唤醒</strong>，是操作系统还是其他线程。Java线程请求某一个资源失败的时候就会进入<strong>阻塞状态</strong>，处于阻塞态的线程会不断请求资源，一旦请求成功，就会进入就绪队列，等待执行。而当线程调用<code>wait</code>、<code>join</code>、<code>pack</code>函数时候会进入<strong>等待状态</strong>，需要其它线程显性的唤醒否则会无限期的处于等待状态。   </p>
</blockquote>
<p>Java线程6状态图：<br><img src="http://ws3.sinaimg.cn/large/e0e01e43ly1g13rmm2wtsj21ep0n4b29.jpg" alt="image"></p>
<p>内部类<code>Node</code>详解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line">    //代表当前节(线程)点是共享模式</span><br><span class="line">    static final Node SHARED = new Node();</span><br><span class="line">    //代表当前节点(线程)是独占模式</span><br><span class="line">    static final Node EXCLUSIVE = null;</span><br><span class="line">    //代表当前节点(线程)已被取消</span><br><span class="line">    static final int CANCELLED =  1;</span><br><span class="line">    //代表当前节点(线程)的后继节点需要被提醒唤醒</span><br><span class="line">    static final int SIGNAL    = -1;</span><br><span class="line">    //代表节点(线程)在 Condition queue中，等待某一条件</span><br><span class="line">    static final int CONDITION = -2;</span><br><span class="line">    //代表当前节点的后继节点(线程)会传传播唤醒的操作，仅在共享模式下才有作用</span><br><span class="line">    static final int PROPAGATE = -3;</span><br><span class="line">    //代表当前节点的状态，它的取值除了以上说的CANCELLED、SIGNAL、CONDITION、PROPAGATE，同时</span><br><span class="line">    //还可能为0，为0的时候代表当前节点在sync队列中，阻塞着排队获取锁。</span><br><span class="line">    volatile int waitStatus;</span><br><span class="line">    //当前节点的前驱节点</span><br><span class="line">    volatile Node prev;</span><br><span class="line">    //当前节点的后继节点</span><br><span class="line">    volatile Node next;</span><br><span class="line">    //当前节点关联的线程</span><br><span class="line">    volatile Thread thread;</span><br><span class="line">    //在condition队列中的后继节点</span><br><span class="line">    Node nextWaiter;</span><br><span class="line">    </span><br><span class="line">    //判断当前节点是否为共享模式</span><br><span class="line">    final boolean isShared() &#123;</span><br><span class="line">        return nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //返回当前节点的前驱节点 没有前驱节点则抛出异常</span><br><span class="line">    final Node predecessor() throws NullPointerException &#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        if (p == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        else</span><br><span class="line">            return p;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每个线程都关联一个节点，节点的状态也代表着线程的状态，<code>AQS</code>通过对同步队列的管理而达到对线程的管理。</p>
<h2 id="AQS的功能"><a href="#AQS的功能" class="headerlink" title="AQS的功能"></a>AQS的功能</h2><p><code>AQS</code>提供了<code>2</code>大功能，基于双链表的同步队列和基于单链表的条件队列，同步队列维护的是<strong>阻塞状态的线程对应的节点</strong>，这些线程都是阻塞着排队获取锁的，普通队列维护的是<strong>等待状态的线程对应的节点</strong>。</p>
<h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p><code>AQS</code>提供了两种方式去获取资源，分别是<strong>共享模式</strong>和<strong>独占模式</strong>，但是一般锁只会去继承其中一种模式，不会在一个锁里同时存在<strong>共享模式</strong>和<strong>独占模式</strong>两种模式。     </p>
<blockquote>
<p>资源指锁、IO、Socket等</p>
</blockquote>
<p>当一个线程以共享模式或独占模式去获取资源的时候，如果获取失败则将该线程封装成<code>Node</code>节点(同时将该节点标识为共享模式或独占模式)<strong>加入到同步队列的尾部</strong>，<code>AQS</code>实时维护着这个同步队列，这个队列以<strong>FIFO(先进先出)来管理节点的排队</strong>，即资源的转移(获取再释放)的顺序是从头结点开始到尾节点。<br><img src="http://ws1.sinaimg.cn/large/e0e01e43ly1g13rmuy8ikj20rm071js5.jpg" alt="image"></p>
<p>共享模式和独占模式去获取、释放资源都分别对应着一套<code>API</code>，以下分别分析这两套<code>API</code></p>
<blockquote>
<p>独占模式即获取资源的<strong>排他锁</strong>，共享模式及获取资源的<strong>共享锁</strong>。</p>
</blockquote>
<h4 id="独占模式"><a href="#独占模式" class="headerlink" title="独占模式"></a>独占模式</h4><p>独占模式即一个线程获取到资源后，其他线程不能再对资源进行任何操作，只能阻塞获得资源。</p>
<h5 id="获取资源"><a href="#获取资源" class="headerlink" title="获取资源"></a>获取资源</h5><ol>
<li>线程调用子类重写的<code>tryAcquire</code>方法获取资源，如果获取成功，则流程结束，否则继续往下执行。</li>
<li>调用<code>addWaiter</code>方法(详细过程看下面的源码解析)，将该线<strong>程封装成Node节点</strong>，并添加到队列<strong>队尾</strong>。</li>
<li>调用<code>acquireQueued</code>方法让节点以”死循环”方式进行获取资源，为什么死循环加了双引号呢？因为循环并不是一直让节点无间断的去获取资源，节点会经历 获取资源-&gt;失败-&gt;线程进入等待状态-&gt;唤醒-&gt;获取资源……，<strong>线程在死循环的过程会不断等待和唤醒</strong>，节点进入到自旋状态(详细过程看下面的源码解析)，<strong>再循环过程中还会将标识为取消的前驱节点移除队列，同时标识前驱节点状态为SIGNAL</strong>。</li>
<li>线程的等待状态是通过调用<code>LockSupport.lock()</code>方法实现的，这个方法会相应<code>Thread.interrupt</code>，但是不会抛出InterruptedException异常，这点与<code>Thread.sleep</code>、<code>Thread.wait</code>不一样。</li>
</ol>
<p><img src="http://ws4.sinaimg.cn/large/e0e01e43ly1g13rn1r0hjj20wc10fgps.jpg" alt="image"></p>
<p><img src="http://wx2.sinaimg.cn/large/e0e01e43ly1g13rn6zuazj20s709j3zt.jpg" alt="image"></p>
<p><strong>可以看到节点和节点之间在自旋过程中除了前驱节点会唤醒该节点之外基本不会互相通讯</strong></p>
<p><strong>源码分析</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    //该线程调用tryAcquire方法尝试以独占模式获取资源，如果获取失败，则调</span><br><span class="line">    //用addWaiter函数，将线程封装到Node节点中，然后再将Node节点加入到同</span><br><span class="line">    //步队列的尾部，然后再调用acquireQueued让线程进入到阻塞状态，如果获</span><br><span class="line">    //取成功则返回true，然后调用selfInterrupt</span><br><span class="line">    //函数。</span><br><span class="line">    //注意的是，tryAcquire函数就是继承AQS的子类所需要去重写的方法。</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE),arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//AQS的tryAcquire函数并没有获取资源的相关实现，需要继承`AQS`的子类去</span><br><span class="line">//重写这个方法。</span><br><span class="line">protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    Node node = new Node(Thread.currentThread(), mode);</span><br><span class="line">    // Try the fast path of enq; backup to full enq on failure</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    //创建新的节点，并将线程和节点关联。</span><br><span class="line">    //将同步队列的尾节点后继节点指向新节点，</span><br><span class="line">    //将新节点的前驱节点指向尾节点，</span><br><span class="line">    //新节点称为同步队列的尾节点。</span><br><span class="line">    if (pred != null) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        //CAS操作将新节点插入到，成功则返回，不成功则继续下面的enq方法，</span><br><span class="line">        //进行死循环CAS插入，直到成功。</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果上面的CAS操作插入不成功，则调用enq方法 死循环插入 直到成功。</span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    //死循环 直到插入成功。</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        //如果尾节点为null，说明同步队列还未初始化，则CAS操作新建头节点</span><br><span class="line">        if (t == null) &#123; // Must initialize</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //通过CAS操作将节点插入到同步队列尾部</span><br><span class="line">            node.prev = t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//节点以“死循环”的方式去获取资源，为什么死循环加了双引号呢？因为循环并不</span><br><span class="line">//是一直让节点无间断的去获取资源，节点会经历 获取资源-&gt;失败-&gt;线程进入等待</span><br><span class="line">//状态-&gt;唤醒-&gt;获取资源......，线程在死循环的过程会不断等待和唤醒，即节点的自旋。</span><br><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            //获取节点的前驱节点</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            //如果前驱节点为头结点，表示资源正在前驱节点的手上，那该节点</span><br><span class="line">            //去尝试获取资源，如果获取成功则将该节点设置为头结点，并且</span><br><span class="line">            //返回。</span><br><span class="line">            //如果该节点的前驱节点并不是头节点或者是前驱节点是头结点但是</span><br><span class="line">            //该节点获取资源失败，继续往下执行。</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = null; // help GC</span><br><span class="line">                failed = false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            //调用shouldParkAfterFailedAcquire函数，将该节点的前驱节点</span><br><span class="line">            //的状态设置为SIGNAL，告诉前驱节点我要去“睡觉”了，当资源排</span><br><span class="line">            //到你的时候，你就通知我一下让我醒来，即节点做进入等待状态</span><br><span class="line">            //的准备。</span><br><span class="line">            //当节点做好了进入等待状态的准备，则调用parkAndCheckInterrupt</span><br><span class="line">            //函数，让该节点进入到等待状态。</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    //获取前驱节点的状态。</span><br><span class="line">    int ws = pred.waitStatus;</span><br><span class="line">    //如果前驱节点的状态已经为SIGNAL了，即已经做好准备了，那直接返回。</span><br><span class="line">    if (ws == Node.SIGNAL)</span><br><span class="line">        /*</span><br><span class="line">         * This node has already set status asking a release</span><br><span class="line">         * to signal it, so it can safely park.</span><br><span class="line">         */</span><br><span class="line">        return true;</span><br><span class="line">    //如果前驱节点的状态为取消状态，则将前驱节点移除队列，循环这个过程</span><br><span class="line">    //直到前驱节点不为取消状态为止。</span><br><span class="line">    if (ws &gt; 0) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">         * indicate retry.</span><br><span class="line">         */</span><br><span class="line">        do &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    //如果前驱节点没有做好准备(标志状态为SIGNAL)、前驱节点也没有被取消，</span><br><span class="line">    //则使用CAS操作将前驱节点的状态更新为SIGNAL，然后返回false，为什么</span><br><span class="line">    //是返回false呢？因为CAS操作并不保证一定能更新成功，返回false的目的</span><br><span class="line">    //是让acquireQueued函数再执行一次for循环，这个循环第一可以让该节点</span><br><span class="line">    //再尝试获取资源(万一成功了呢 是吧)，第二是让acquireQueued函数再调用</span><br><span class="line">    //一次shouldParkAfterFailedAcquire函数(即本函数)判断节点的前驱节点是</span><br><span class="line">    //否已经设置为SIGNAL状态了。</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /*</span><br><span class="line">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="line">         * need a signal, but don&apos;t park yet.  Caller will need to</span><br><span class="line">         * retry to make sure it cannot acquire before parking.</span><br><span class="line">         */</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用LockSupport.park函数将该线程设置为等待状态</span><br><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    LockSupport.park(this);</span><br><span class="line">    //注意LockSupport遇到Thread.interrupt是会立刻返回的，但是不会抛出异常InterruptedExcept</span><br><span class="line">    //ion，这个需要注意和Thread.wait，Thread.sleep的区别，</span><br><span class="line">    //唤醒的时候 会返回该线程是否为中断唤醒的。</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h5><ol>
<li>线程调用子类重写的<code>tryRelease</code>方法进行释放资源，如果释放成功则继续检查线程(节点)的是否有后继节点，有后继几点则去<strong>唤醒</strong>。</li>
<li>调用<code>unparkSuccessor</code>方法进行后继节点的唤醒，<strong>如果后继节点为取消状态，则从队列的队尾往前遍历，找到一个离节点最近且不为取消状态的节点进行唤醒，如果后继节点不为取消状态则直接唤醒</strong>。</li>
</ol>
<p><img src="http://ws3.sinaimg.cn/large/e0e01e43ly1g13rne0t7dj20qh0pkjt8.jpg" alt="image"><br><strong>源码解析</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    //线程调用tryRelease方法尝试释放资源，如果释放成功则检查该节点是否有后继节点，有的话则</span><br><span class="line">    //调用unpacrkSuccessor()方法去唤醒后继节点。</span><br><span class="line">    //注意的是，tryRelease函数就是继承AQS的子类所需要去重写的方法。</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        //头结点(即释放资源的节点)不为空，头结点的状态不为0，代表有后继节点，需要唤醒。</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    /*</span><br><span class="line">     * If status is negative (i.e., possibly needing signal) try</span><br><span class="line">     * to clear in anticipation of signalling.  It is OK if this</span><br><span class="line">     * fails or if status is changed by waiting thread.</span><br><span class="line">     */</span><br><span class="line">    //获取头结点状态。</span><br><span class="line">    int ws = node.waitStatus;</span><br><span class="line">    //如果状态小于0，即代表有后继节点需要唤醒。</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        //将头结点的状态置为0 因为只需要唤醒一次</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Thread to unpark is held in successor, which is normally</span><br><span class="line">     * just the next node.  But if cancelled or apparently null,</span><br><span class="line">     * traverse backwards from tail to find the actual</span><br><span class="line">     * non-cancelled successor.</span><br><span class="line">     */</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    //如果头结点的后继节点为空 或者 头结点的后继节点处于取消状态，则从尾部开始往前寻找，</span><br><span class="line">    //找到一个离头结点最近 且状态不是取消状态的节点。</span><br><span class="line">    if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s = null;</span><br><span class="line">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            if (t.waitStatus &lt;= 0)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果头结点的后继节点不为取消状态，则直接将后继节点唤醒</span><br><span class="line">    if (s != null)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="共享模式"><a href="#共享模式" class="headerlink" title="共享模式"></a>共享模式</h4><p>共享模式下，线程无论是<strong>获取资源还是释放资源，都可能会唤醒后继节点</strong>。</p>
<h5 id="获取资源-1"><a href="#获取资源-1" class="headerlink" title="获取资源"></a>获取资源</h5><ol>
<li>调用子类重写的<code>tryAcquireShared</code>方法进行资源获取，获取失败则调用<code>doAcquireShared</code>将<strong>线程封装Node节点加入到同步队列队尾</strong>。</li>
<li>调用<code>doAcquireShared</code>方法让节点以”死循环”方式进行获取资源，为什么死循环加了双引号呢？因为循环并不是一直让节点无间断的去获取资源，节点会经历获取资源-&gt;失败-&gt;线程进入等待状态-&gt;唤醒-&gt;获取资源……，线程在死循环的过程会不断等待和唤醒，节点进入到自旋状态(详细过程看下面的源码解析)。<strong>如果线程节点被唤醒后，且获取资源成功，且后继节点为共享模式，那么会唤醒后继节点……唤醒会一直传递下去，直到后继节点不是共享模式，唤醒的节点同样会去获取资源</strong>，这点和独占模式不一样。</li>
</ol>
<p><img src="http://ws2.sinaimg.cn/large/e0e01e43ly1g13rnoe29bj213i10f0xf.jpg" alt="image"></p>
<p><img src="http://wx2.sinaimg.cn/large/e0e01e43ly1g13rntqlntj20yw0a9acj.jpg" alt="image"><br><strong>共享模式资源的获取和独占模式资源的获取流程差不多，就是在获取资源成功后，会唤醒为共享模式的后继节点，然后被唤醒的后继节点也去获取资源</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    //和独占模式的一样，同样是调用子类重写的tryAcquireShared方法以共享模式进行资源获取。</span><br><span class="line">    //如果获取失败，则调用doAcquireShared方法将线程封装成Node节点加入到同步队列的队尾，</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected int tryAcquireShared(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">    //将线程封装到节点中，且将节点加入到队尾中。</span><br><span class="line">    final Node node = addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            //获取线程(节点)的前驱节点。</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            //如果前驱节点为头结点，则该线程尝试获取资源。</span><br><span class="line">            if (p == head) &#123;</span><br><span class="line">                //获取资源。</span><br><span class="line">                int r = tryAcquireShared(arg);</span><br><span class="line">                //获取资源成功则将节点设为头结点。</span><br><span class="line">                if (r &gt;= 0) &#123;</span><br><span class="line">                    //获取成功 对后继SHARED节点持续唤醒</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    if (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //和独占模式的一样。</span><br><span class="line">            //调用shouldParkAfterFailedAcquire函数，将该节点的前驱节点</span><br><span class="line">            //的状态设置为SIGNAL，告诉前驱节点我要去“睡觉”了，当资源排</span><br><span class="line">            //到你的时候，你就通知我一下让我醒来，即节点做进入等待状态的准备。</span><br><span class="line">            //当节点做好了进入等待状态的准备，则调用parkAndCheckInterrupt</span><br><span class="line">            //函数，让该节点进入到等待状态。            </span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">    Node h = head; // Record old head for check below</span><br><span class="line">    setHead(node);</span><br><span class="line">    /*</span><br><span class="line">     * Try to signal next queued node if:</span><br><span class="line">     *   Propagation was indicated by caller,</span><br><span class="line">     *     or was recorded (as h.waitStatus either before</span><br><span class="line">     *     or after setHead) by a previous operation</span><br><span class="line">     *     (note: this uses sign-check of waitStatus because</span><br><span class="line">     *      PROPAGATE status may transition to SIGNAL.)</span><br><span class="line">     * and</span><br><span class="line">     *   The next node is waiting in shared mode,</span><br><span class="line">     *     or we don&apos;t know, because it appears null</span><br><span class="line">     *</span><br><span class="line">     * The conservatism in both of these checks may cause</span><br><span class="line">     * unnecessary wake-ups, but only when there are multiple</span><br><span class="line">     * racing acquires/releases, so most need signals now or soon</span><br><span class="line">     * anyway.</span><br><span class="line">     */</span><br><span class="line">    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||</span><br><span class="line">        (h = head) == null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        //如果节点为共享节点，则调用doReleaseShared函数唤醒后继节点。</span><br><span class="line">        if (s == null || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="释放资源-1"><a href="#释放资源-1" class="headerlink" title="释放资源"></a>释放资源</h5><ol>
<li>调用子类重写的<code>tryReleaseShared</code>方法释放资源，释放成功则调用<code>doReleaseShared</code>方法进行后继节点的唤醒。</li>
<li>如果后继节点为共享模式，则持续唤醒。</li>
</ol>
<p><img src="http://ws2.sinaimg.cn/large/e0e01e43ly1g13ro03soyj21601cx0yr.jpg" alt="image"></p>
<p><strong>共享模式下资源释放流程和独占模式下资源释放的流程差不多，就是在释放后唤醒后继为共享模式的节点，且唤醒的动作是传播下去的，直到后继节点出现不是共享模式的，这个唤醒的过程和共享模式的获取资源的唤醒过程一样。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//调用子类重写的tryReleaseShared方法进行以共享模式释放资源，释放失败则调用doReleaseShared。</span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected boolean tryReleaseShared(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">    /*</span><br><span class="line">     * Ensure that a release propagates, even if there are other</span><br><span class="line">     * in-progress acquires/releases.  This proceeds in the usual</span><br><span class="line">     * way of trying to unparkSuccessor of head if it needs</span><br><span class="line">     * signal. But if it does not, status is set to PROPAGATE to</span><br><span class="line">     * ensure that upon release, propagation continues.</span><br><span class="line">     * Additionally, we must loop in case a new node is added</span><br><span class="line">     * while we are doing this. Also, unlike other uses of</span><br><span class="line">     * unparkSuccessor, we need to know if CAS to reset status</span><br><span class="line">     * fails, if so rechecking.</span><br><span class="line">     */</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h != tail) &#123;</span><br><span class="line">            int ws = h.waitStatus;</span><br><span class="line">            //如果节点标识后继节点需要唤醒，则调用unparkSuccessor方法进行唤醒。</span><br><span class="line">            if (ws == Node.SIGNAL) &#123;</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            // loop to recheck cases</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ws == 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                // loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        if (h == head)                   // loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h3><p>普通队列又称等待队列、条件队列等，普通队列的实现是通过<code>ConditionObject</code>的内之类来完成的，，一开始就介绍了同步队列普通队列的去，不过这里再啰嗦一下，<strong>可以把同步队列理解为储存阻塞状态的线程，而普通队列储存的是等待状态的线程</strong>，普通队列中的线程并不能直接去获取资源，而要先从普通队列转到同步队列中排队获取，一个线程要么是在同步队列中，要么是在普通队列中，不可能同时存在这两个队列里面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * 使当前线程进入等待状态，直到以下4种情况任意一个发生：</span><br><span class="line"> * 1.另一个线程调用该对象的signal()，当前线程恰好是被选中的唤醒线程</span><br><span class="line"> * 2.另一个线程调用该对象的signalAll()</span><br><span class="line"> * 3.另一个线程interrupt当前线程（此时会抛出InterruptedException）</span><br><span class="line"> * 4.虚假唤醒（源自操作系统，发生概率低）</span><br><span class="line"> * ConditionObject要求调用时该线程已经拿到了其外部AQS类的排它锁（acquire成功）</span><br><span class="line"> */</span><br><span class="line">void await() throws InterruptedException;</span><br><span class="line">/* </span><br><span class="line"> * 与await()相同，但是不会被interrupt唤醒</span><br><span class="line"> */</span><br><span class="line">void awaitUninterruptibly();</span><br><span class="line">/* </span><br><span class="line"> * 与await()相同，增加了超时时间，超过超时时间也会停止等待</span><br><span class="line"> * 三个方法功能相似，其返回值代表剩余的超时时间，或是否超时</span><br><span class="line"> */</span><br><span class="line">long awaitNanos(long nanosTimeout) throws InterruptedException;</span><br><span class="line">boolean await(long time, TimeUnit unit) throws InterruptedException;</span><br><span class="line">boolean awaitUntil(Date deadline) throws InterruptedException;</span><br><span class="line">/* </span><br><span class="line"> * 唤醒一个正在等待该条件变量对象的线程</span><br><span class="line"> * ConditionObject会选择等待时间最长的线程来唤醒</span><br><span class="line"> * ConditionObject要求调用时该线程已经拿到了其外部AQS类的排它锁（acquire成功）</span><br><span class="line"> */</span><br><span class="line">void signal();</span><br><span class="line">/* </span><br><span class="line"> * 唤醒所有正在等待该条件变量对象的线程</span><br><span class="line"> * ConditionObject要求调用时该线程已经拿到了其外部AQS类的排它锁（acquire成功）</span><br><span class="line"> */</span><br><span class="line">void signalAll();</span><br></pre></td></tr></table></figure></p>
<p>可以看到，其作用与Object原生的wait()/notify()/notifyAll()很相似，但是增加了更多的功能。下面以awaitUninterruptibly()、signal()为例，阐述一下其内部实现。<br><img src="http://wx4.sinaimg.cn/large/e0e01e43ly1g13rodrehcj20md0hajy9.jpg" alt="image"></p>
<h3 id="同步队列和普通队列的关系"><a href="#同步队列和普通队列的关系" class="headerlink" title="同步队列和普通队列的关系"></a>同步队列和普通队列的关系</h3><p>线程执行<code>condition.await()</code>方法，将节点1从同步队列转移到普通队列中。<br><img src="http://ws1.sinaimg.cn/large/e0e01e43ly1g13rooch2sj20y407bdh0.jpg" alt="image"></p>
<p>线程执行<code>condition.signal()</code>方法，将节点1从普通队列中转移到同步队列。<br><img src="http://wx2.sinaimg.cn/large/e0e01e43ly1g13rotlu30j20za06wgmq.jpg" alt="image"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.fanyilun.me/2016/06/13/%E7%AE%80%E8%BF%B0AbstractQueuedSynchronizer/#2-3-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">简述AbstractQueuedSynchronizer</a><br><a href="https://javadoop.com/post/AbstractQueuedSynchronizer" target="_blank" rel="noopener">一行一行源码分析清楚AbstractQueuedSynchronizer</a><br><a href="http://zhanjindong.com/2015/03/15/java-concurrent-package-aqs-AbstractQueuedSynchronizer" target="_blank" rel="noopener">Java并发包源码学习之AQS框架（四）AbstractQueuedSynchronizer源码分析</a><br><a href="http://blog.zhangjikai.com/2017/04/15/%E3%80%90Java-%E5%B9%B6%E5%8F%91%E3%80%91%E8%AF%A6%E8%A7%A3-AbstractQueuedSynchronizer/" target="_blank" rel="noopener">【Java并发】详解 AbstractQueuedSynchronizer</a><br><a href="http://ifeve.com/introduce-abstractqueuedsynchronizer/" target="_blank" rel="noopener">AbstractQueuedSynchronizer的介绍和原理分析</a>     </p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://ddnd.cn/2019/03/15/java-abstractqueuedsynchronizer/" title="一文带你快速掌握AQS" target="_blank" rel="external">http://ddnd.cn/2019/03/15/java-abstractqueuedsynchronizer/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/xue8" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/img/logo.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/xue8" target="_blank"><span class="text-dark">薛8</span><small class="ml-1x">Web Developer</small></a></h3>
        <div>个人简介。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom="">
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2019/03/19/java-volatile/" title="Java volatile关键字解析"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;Newer</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2019/03/13/java-cas/" title="CAS原理分析及ABA问题详解"><span>Older&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="Catalogue" role="button">
        <span>[&nbsp;</span><span>Catalogue</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope="" itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/xue8" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script src="/js/plugin.min.js"></script>
<script src="/js/application.js"></script>

    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>





   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>